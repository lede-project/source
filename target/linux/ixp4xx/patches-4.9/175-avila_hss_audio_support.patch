--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -47,6 +47,7 @@ source "sound/soc/cirrus/Kconfig"
 source "sound/soc/davinci/Kconfig"
 source "sound/soc/dwc/Kconfig"
 source "sound/soc/fsl/Kconfig"
+source "sound/soc/gw-avila/Kconfig"
 source "sound/soc/jz4740/Kconfig"
 source "sound/soc/nuc900/Kconfig"
 source "sound/soc/omap/Kconfig"
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_SND_SOC)	+= cirrus/
 obj-$(CONFIG_SND_SOC)	+= davinci/
 obj-$(CONFIG_SND_SOC)	+= dwc/
 obj-$(CONFIG_SND_SOC)	+= fsl/
+obj-$(CONFIG_SND_SOC)	+= gw-avila/
 obj-$(CONFIG_SND_SOC)	+= jz4740/
 obj-$(CONFIG_SND_SOC)	+= img/
 obj-$(CONFIG_SND_SOC)	+= intel/
--- /dev/null
+++ b/sound/soc/gw-avila/Kconfig
@@ -0,0 +1,17 @@
+config SND_GW_AVILA_SOC_PCM
+	tristate
+
+config SND_GW_AVILA_SOC_HSS
+	tristate
+
+config SND_GW_AVILA_SOC
+	tristate "SoC Audio for the Gateworks AVILA Family"
+	depends on ARCH_IXP4XX && SND_SOC
+	select SND_GW_AVILA_SOC_PCM
+	select SND_GW_AVILA_SOC_HSS
+	select SND_SOC_TLV320AIC3X
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the Gateworks HSS interface. You will also need
+	  to select the audio interfaces to support below.
+
--- /dev/null
+++ b/sound/soc/gw-avila/Makefile
@@ -0,0 +1,8 @@
+# Gateworks Avila HSS Platform Support
+snd-soc-gw-avila-objs := gw-avila.o ixp4xx_hss.o
+snd-soc-gw-avila-pcm-objs := gw-avila-pcm.o
+snd-soc-gw-avila-hss-objs := gw-avila-hss.o
+
+obj-$(CONFIG_SND_GW_AVILA_SOC) += snd-soc-gw-avila.o
+obj-$(CONFIG_SND_GW_AVILA_SOC_PCM) += snd-soc-gw-avila-pcm.o
+obj-$(CONFIG_SND_GW_AVILA_SOC_HSS) += snd-soc-gw-avila-hss.o
--- /dev/null
+++ b/sound/soc/gw-avila/gw-avila-hss.c
@@ -0,0 +1,103 @@
+/*
+ * gw-avila-hss.c -- HSS Audio Support for Gateworks Avila
+ *
+ * Author:	Chris Lang	<clang@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <asm/irq.h>
+#include <linux/mutex.h>
+#include <linux/gpio.h>
+
+#include "ixp4xx_hss.h"
+#include "gw-avila-hss.h"
+
+#define gw_avila_hss_suspend	NULL
+#define gw_avila_hss_resume	NULL
+
+struct snd_soc_dai_driver gw_avila_hss_dai = {
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
+			SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |
+			SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
+			SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
+			SNDRV_PCM_RATE_KNOT),
+		.formats = SNDRV_PCM_FMTBIT_S16_LE, },
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
+			SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |
+			SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
+			SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
+			SNDRV_PCM_RATE_KNOT),
+		.formats = SNDRV_PCM_FMTBIT_S16_LE, },
+};
+
+static const struct snd_soc_component_driver gw_avila_hss_component = {
+	.name   = "gw_avila_hss",
+};
+
+static int gw_avila_hss_probe(struct platform_device *pdev)
+{
+	int port = (pdev->id < 2) ? 0 : 1;
+	int channel = (pdev->id % 2);
+
+	hss_handle[pdev->id] = hss_init(port, channel);
+	if (!hss_handle[pdev->id]) {
+		return -ENODEV;
+	}
+
+	return snd_soc_register_component(&pdev->dev, &gw_avila_hss_component,
+					  &gw_avila_hss_dai, 1);
+}
+
+static int gw_avila_hss_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+
+	return 0;
+}
+
+static struct platform_driver gw_avila_hss_driver = {
+	.probe    = gw_avila_hss_probe,
+	.remove   = gw_avila_hss_remove,
+	.driver   = {
+		.name = "gw_avila_hss",
+		.owner  = THIS_MODULE,
+	}
+};
+
+static int __init gw_avila_hss_init(void)
+{
+	return platform_driver_register(&gw_avila_hss_driver);
+}
+module_init(gw_avila_hss_init);
+
+static void __exit gw_avila_hss_exit(void)
+{
+	platform_driver_unregister(&gw_avila_hss_driver);
+}
+module_exit(gw_avila_hss_exit);
+
+MODULE_AUTHOR("Chris Lang");
+MODULE_DESCRIPTION("HSS Audio Driver for Gateworks Avila");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/sound/soc/gw-avila/gw-avila-hss.h
@@ -0,0 +1,12 @@
+/*
+ * Author: Chris Lang <clang@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _GW_AVILA_HSS_H
+#define _GW_AVILA_HSS_H
+
+#endif
--- /dev/null
+++ b/sound/soc/gw-avila/gw-avila-pcm.c
@@ -0,0 +1,327 @@
+/*
+ * ALSA PCM interface for the TI DAVINCI processor
+ *
+ * Author:      Chris Lang, <clang@gateworks.com>
+ * Copyright:   (C) 2009 Gateworks Corporation
+ *
+ * Based On:    davinci-evm.c, Author: Vladimir Barinov, <vbarinov@ru.mvista.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <asm/dma.h>
+
+#include "gw-avila-pcm.h"
+#include "gw-avila-hss.h"
+#include "ixp4xx_hss.h"
+
+#define GW_AVILA_PCM_DEBUG 0
+#if GW_AVILA_PCM_DEBUG
+#define DPRINTK(x...) printk(KERN_DEBUG x)
+#else
+#define DPRINTK(x...)
+#endif
+
+static struct snd_pcm_hardware gw_avila_pcm_hardware = {
+	.info = (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		 SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID),
+/*		 SNDRV_PCM_INFO_PAUSE),*/
+	.formats = (SNDRV_PCM_FMTBIT_S16_LE),
+	.rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |
+		  SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |
+		  SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
+		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
+		  SNDRV_PCM_RATE_KNOT),
+	.rate_min = 8000,
+	.rate_max = 8000,
+	.channels_min = 2,
+	.channels_max = 2,
+	.buffer_bytes_max = 64 * 1024, // All of the lines below may need to be changed
+	.period_bytes_min = 128,
+	.period_bytes_max = 4 * 1024,
+	.periods_min = 16,
+	.periods_max = 32,
+	.fifo_size = 0,
+};
+
+struct gw_avila_runtime_data {
+	spinlock_t lock;
+	int period;		/* current DMA period */
+	int master_lch;		/* Master DMA channel */
+	int slave_lch;		/* Slave DMA channel */
+	struct gw_avila_pcm_dma_params *params;	/* DMA params */
+};
+
+static void gw_avila_dma_irq(void *data)
+{
+	struct snd_pcm_substream *substream = data;
+	snd_pcm_period_elapsed(substream);
+}
+
+static int gw_avila_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct hss_device *hdev = runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			hss_tx_start(hdev);
+		else
+			hss_rx_start(hdev);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			hss_tx_stop(hdev);
+		else
+			hss_rx_stop(hdev);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int gw_avila_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct hss_device *hdev = runtime->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		hss_set_tx_callback(hdev, gw_avila_dma_irq, substream);
+		hss_config_tx_dma(hdev, runtime->dma_area, runtime->buffer_size, runtime->period_size);
+	} else {
+		hss_set_rx_callback(hdev, gw_avila_dma_irq, substream);
+		hss_config_rx_dma(hdev, runtime->dma_area, runtime->buffer_size, runtime->period_size);
+	}
+
+	return 0;
+}
+
+static snd_pcm_uframes_t
+gw_avila_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct hss_device *hdev = runtime->private_data;
+
+	unsigned int curr = 0;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		curr = hss_curr_offset_tx(hdev);
+	else
+		curr = hss_curr_offset_rx(hdev);
+  return curr;
+}
+
+static int gw_avila_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+
+	snd_soc_set_runtime_hwparams(substream, &gw_avila_pcm_hardware);
+
+	if (hss_handle[cpu_dai->id] != NULL)
+		runtime->private_data = hss_handle[cpu_dai->id];
+	else {
+		pr_err("hss_handle is NULL\n");
+		return -1;
+	}
+
+	hss_chan_open(hss_handle[cpu_dai->id]);
+
+	return 0;
+}
+
+static int gw_avila_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct hss_device *hdev = runtime->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		memset(hdev->tx_buf, 0, runtime->buffer_size);
+	} else
+		memset(hdev->rx_buf, 0, runtime->buffer_size);
+
+	hss_chan_close(hdev);
+
+	return 0;
+}
+
+static int gw_avila_pcm_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+}
+
+static int gw_avila_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	  memset(runtime->dma_area, 0, runtime->buffer_size);
+
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int gw_avila_pcm_mmap(struct snd_pcm_substream *substream,
+          struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+						runtime->dma_area,
+						runtime->dma_addr,
+						runtime->dma_bytes);
+}
+
+struct snd_pcm_ops gw_avila_pcm_ops = {
+	.open = 	gw_avila_pcm_open,
+	.close = 	gw_avila_pcm_close,
+	.ioctl = 	snd_pcm_lib_ioctl,
+	.hw_params = 	gw_avila_pcm_hw_params,
+	.hw_free = 	gw_avila_pcm_hw_free,
+	.prepare = 	gw_avila_pcm_prepare,
+	.trigger = 	gw_avila_pcm_trigger,
+	.pointer = 	gw_avila_pcm_pointer,
+	.mmap = gw_avila_pcm_mmap,
+};
+
+static int gw_avila_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = gw_avila_pcm_hardware.buffer_bytes_max;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+
+	buf->area = dma_alloc_coherent(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+
+	if (!buf->area) {
+		return -ENOMEM;
+	}
+
+	memset(buf->area, 0xff, size);
+
+	DPRINTK("preallocate_dma_buffer: area=%p, addr=%p, size=%d\n",
+		(void *) buf->area, (void *) buf->addr, size);
+
+	buf->bytes = size;
+
+	return 0;
+}
+
+static void gw_avila_pcm_free(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_coherent(NULL, buf->bytes, buf->area, 0);
+		buf->area = NULL;
+	}
+}
+
+static u64 gw_avila_pcm_dmamask = 0xFFFFFFFF;
+
+static int gw_avila_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+        struct snd_card *card = rtd->card->snd_card;
+        struct snd_pcm *pcm = rtd->pcm;
+        struct snd_soc_dai *dai = rtd->codec_dai;
+	int ret;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &gw_avila_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xFFFFFFFF;
+
+	if (dai->driver->playback.channels_min) {
+		ret = gw_avila_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			return ret;
+	}
+
+	if (dai->driver->capture.channels_min) {
+		ret = gw_avila_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+struct snd_soc_platform_driver gw_avila_soc_platform = {
+	.ops = 	&gw_avila_pcm_ops,
+	.pcm_new = 	gw_avila_pcm_new,
+	.pcm_free = 	gw_avila_pcm_free,
+};
+
+static int gw_avila_pcm_platform_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_platform(&pdev->dev, &gw_avila_soc_platform);
+}
+
+static int gw_avila_pcm_platform_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver gw_avila_pcm_driver = {
+	.driver = {
+		.name = "gw_avila-audio",
+		.owner = THIS_MODULE,
+	},
+	.probe = gw_avila_pcm_platform_probe,
+	.remove = gw_avila_pcm_platform_remove,
+};
+
+static int __init gw_avila_soc_platform_init(void)
+{
+	return platform_driver_register(&gw_avila_pcm_driver);
+}
+module_init(gw_avila_soc_platform_init);
+
+static void __exit gw_avila_soc_platform_exit(void)
+{
+	platform_driver_unregister(&gw_avila_pcm_driver);
+}
+module_exit(gw_avila_soc_platform_exit);
+
+MODULE_AUTHOR("Chris Lang");
+MODULE_DESCRIPTION("Gateworks Avila PCM DMA module");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/sound/soc/gw-avila/gw-avila-pcm.h
@@ -0,0 +1,32 @@
+/*
+ * ALSA PCM interface for the Gateworks Avila platform
+ *
+ * Author:      Chris Lang, <clang@gateworks.com>
+ * Copyright:   (C) 2009 Gateworks Corporation
+ *
+ * Based On:    davinci-evm.c, Author: Vladimir Barinov, <vbarinov@ru.mvista.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _GW_AVILA_PCM_H
+#define _GW_AVILA_PCM_H
+
+#if 0
+struct gw_avila_pcm_dma_params {
+	char *name;		/* stream identifier */
+	int channel;		/* sync dma channel ID */
+	dma_addr_t dma_addr;	/* device physical address for DMA */
+	unsigned int data_type;	/* xfer data type */
+};
+
+struct gw_avila_snd_platform_data {
+	int tx_dma_ch; // XXX Do we need this?
+	int rx_dma_ch; // XXX Do we need this
+};
+extern struct snd_soc_platform gw_avila_soc_platform[];
+#endif
+
+#endif
--- /dev/null
+++ b/sound/soc/gw-avila/gw-avila.c
@@ -0,0 +1,244 @@
+/*
+ * File:         sound/soc/gw-avila/gw_avila.c
+ * Author:       Chris Lang <clang@gateworks.com>
+ *
+ * Created:      Tue June 06 2008
+ * Description:  Board driver for Gateworks Avila
+ *
+ * Modified:
+ *               Copyright 2009 Gateworks Corporation
+ *
+ * Bugs:         What Bugs?
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <asm/dma.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+
+#include "ixp4xx_hss.h"
+#include "gw-avila-hss.h"
+#include "gw-avila-pcm.h"
+
+#define CODEC_FREQ 33333000
+
+static int gw_avila_board_startup(struct snd_pcm_substream *substream)
+{
+	pr_debug("%s enter\n", __func__);
+	return 0;
+}
+
+static int gw_avila_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+
+	int ret = 0;
+
+	/* set codec DAI configuration */
+	if (cpu_dai->id % 2) {
+  		ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF | SND_SOC_DAIFMT_CBS_CFS);
+			snd_soc_dai_set_tdm_slot(codec_dai, 0, 0, 1, 32);
+	} else {
+	  	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF | SND_SOC_DAIFMT_CBM_CFM);
+			snd_soc_dai_set_tdm_slot(codec_dai, 0, 0, 0, 32);
+	}
+
+	if (ret < 0)
+	    return ret;
+
+	/* set the codec system clock */
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, CODEC_FREQ, SND_SOC_CLOCK_OUT);
+	if (ret < 0)
+	    return ret;
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget aic3x_dapm_widgets[] = {
+  SND_SOC_DAPM_HP("Headphone Jack", NULL),
+  SND_SOC_DAPM_LINE("Line Out", NULL),
+  SND_SOC_DAPM_LINE("Line In", NULL),
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+  {"Headphone Jack", NULL, "HPLOUT"},
+  {"Headphone Jack", NULL, "HPROUT"},
+
+  /* Line Out connected to LLOUT, RLOUT */
+  {"Line Out", NULL, "LLOUT"},
+  {"Line Out", NULL, "RLOUT"},
+
+  /* Line In connected to (LINE1L | LINE2L), (LINE1R | LINE2R) */
+  {"LINE1L", NULL, "Line In"},
+  {"LINE1R", NULL, "Line In"},
+};
+
+/* Logic for a aic3x as connected on a davinci-evm */
+static int avila_aic3x_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+
+  /* Add davinci-evm specific widgets */
+  snd_soc_dapm_new_controls(dapm, aic3x_dapm_widgets,
+          ARRAY_SIZE(aic3x_dapm_widgets));
+
+  /* Set up davinci-evm specific audio path audio_map */
+  snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
+
+  /* not connected */
+  snd_soc_dapm_disable_pin(dapm, "MONO_LOUT");
+  //snd_soc_dapm_disable_pin(dapm, "HPLCOM");
+  //snd_soc_dapm_disable_pin(dapm, "HPRCOM");
+  snd_soc_dapm_disable_pin(dapm, "MIC3L");
+  snd_soc_dapm_disable_pin(dapm, "MIC3R");
+  snd_soc_dapm_disable_pin(dapm, "LINE2L");
+  snd_soc_dapm_disable_pin(dapm, "LINE2R");
+
+  /* always connected */
+	snd_soc_dapm_enable_pin(dapm, "Headphone Jack");
+  snd_soc_dapm_enable_pin(dapm, "Line Out");
+  snd_soc_dapm_enable_pin(dapm, "Line In");
+
+  snd_soc_dapm_sync(dapm);
+
+	return 0;
+}
+
+static struct snd_soc_ops gw_avila_board_ops = {
+	.startup = gw_avila_board_startup,
+	.hw_params = gw_avila_hw_params,
+};
+
+static struct snd_soc_dai_link gw_avila_board_dai[] = {
+	{
+		.name = "HSS-0",
+		.stream_name = "HSS-0",
+		.cpu_dai_name = "gw_avila_hss.0",
+		.codec_dai_name = "tlv320aic3x-hifi",
+		.codec_name = "tlv320aic3x-codec.0-001b",
+		.platform_name = "gw_avila-audio.0",
+		.init = avila_aic3x_init,
+		.ops = &gw_avila_board_ops,
+	},{
+		.name = "HSS-1",
+		.stream_name = "HSS-1",
+		.cpu_dai_name = "gw_avila_hss.1",
+		.codec_dai_name = "tlv320aic3x-hifi",
+		.codec_name = "tlv320aic3x-codec.0-001a",
+		.platform_name = "gw_avila-audio.1",
+		.init = avila_aic3x_init,
+		.ops = &gw_avila_board_ops,
+	},{
+		.name = "HSS-2",
+		.stream_name = "HSS-2",
+		.cpu_dai_name = "gw_avila_hss.2",
+		.codec_dai_name = "tlv320aic3x-hifi",
+		.codec_name = "tlv320aic3x-codec.0-0019",
+		.platform_name = "gw_avila-audio.2",
+		.init = avila_aic3x_init,
+		.ops = &gw_avila_board_ops,
+	},{
+		.name = "HSS-3",
+		.stream_name = "HSS-3",
+		.cpu_dai_name = "gw_avila_hss.3",
+		.codec_dai_name = "tlv320aic3x-hifi",
+		.codec_name = "tlv320aic3x-codec.0-0018",
+		.platform_name = "gw_avila-audio.3",
+		.init = avila_aic3x_init,
+		.ops = &gw_avila_board_ops,
+	},
+};
+
+static struct snd_soc_card gw_avila_board[] = {
+	{
+		.name = "gw_avila-board.0",
+		.owner = THIS_MODULE,
+		.dai_link = &gw_avila_board_dai[0],
+		.num_links = 1,
+	},{
+		.name = "gw_avila-board.1",
+		.owner = THIS_MODULE,
+		.dai_link = &gw_avila_board_dai[1],
+		.num_links = 1,
+	},{
+		.name = "gw_avila-board.2",
+		.owner = THIS_MODULE,
+		.dai_link = &gw_avila_board_dai[2],
+		.num_links = 1,
+	},{
+		.name = "gw_avila-board.3",
+		.owner = THIS_MODULE,
+		.dai_link = &gw_avila_board_dai[3],
+		.num_links = 1,
+	}
+};
+
+static struct platform_device *gw_avila_board_snd_device[4];
+
+static int __init gw_avila_board_init(void)
+{
+	int ret;
+	struct port *port;
+	int i;
+
+	if ((hss_port[0] = kzalloc(sizeof(*port), GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+
+	if ((hss_port[1] = kzalloc(sizeof(*port), GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < 4; i++) {
+		gw_avila_board_snd_device[i] = platform_device_alloc("soc-audio", i);
+		if (!gw_avila_board_snd_device[i]) {
+			return -ENOMEM;
+		}
+
+		platform_set_drvdata(gw_avila_board_snd_device[i], &gw_avila_board[i]);
+		ret = platform_device_add(gw_avila_board_snd_device[i]);
+
+		if (ret) {
+			platform_device_put(gw_avila_board_snd_device[i]);
+		}
+	}
+	return ret;
+}
+
+static void __exit gw_avila_board_exit(void)
+{
+	int i;
+	for (i = 0; i < 4; i++)
+		platform_device_unregister(gw_avila_board_snd_device[i]);
+}
+
+module_init(gw_avila_board_init);
+module_exit(gw_avila_board_exit);
+
+/* Module information */
+MODULE_AUTHOR("Chris Lang");
+MODULE_DESCRIPTION("ALSA SoC HSS Audio gw_avila board");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/sound/soc/gw-avila/ixp4xx_hss.c
@@ -0,0 +1,902 @@
+/*
+ * Intel IXP4xx HSS (synchronous serial port) driver for Linux
+ *
+ * Copyright (C) 2009 Chris Lang <clang@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/bitops.h>
+#include <linux/cdev.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/fs.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+#include <mach/npe.h>
+#include <mach/qmgr.h>
+
+#include "ixp4xx_hss.h"
+
+/*****************************************************************************
+ * global variables
+ ****************************************************************************/
+
+void hss_chan_read(unsigned long data);
+static char lock_init = 0;
+static spinlock_t npe_lock;
+static struct npe *npe;
+
+static const struct {
+	int tx, txdone, rx, rxfree, chan;
+}queue_ids[2] = {{HSS0_PKT_TX0_QUEUE, HSS0_PKT_TXDONE_QUEUE, HSS0_PKT_RX_QUEUE,
+		  HSS0_PKT_RXFREE0_QUEUE, HSS0_CHL_RXTRIG_QUEUE},
+		 {HSS1_PKT_TX0_QUEUE, HSS1_PKT_TXDONE_QUEUE, HSS1_PKT_RX_QUEUE,
+		  HSS1_PKT_RXFREE0_QUEUE, HSS1_CHL_RXTRIG_QUEUE},
+};
+
+struct port *hss_port[2];
+struct hss_device *hss_handle[32];
+EXPORT_SYMBOL(hss_handle);
+
+/*****************************************************************************
+ * utility functions
+ ****************************************************************************/
+
+#ifndef __ARMEB__
+static inline void memcpy_swab32(u32 *dest, u32 *src, int cnt)
+{
+	int i;
+	for (i = 0; i < cnt; i++)
+		dest[i] = swab32(src[i]);
+}
+#endif
+
+static inline unsigned int sub_offset(unsigned int a, unsigned int b,
+				      unsigned int modulo)
+{
+	return (modulo /* make sure the result >= 0 */ + a - b) % modulo;
+}
+
+/*****************************************************************************
+ * HSS access
+ ****************************************************************************/
+
+static void hss_config_load(struct port *port)
+{
+	struct msg msg;
+
+	do {
+		memset(&msg, 0, sizeof(msg));
+		msg.cmd = PORT_CONFIG_LOAD;
+		msg.hss_port = port->id;
+		if (npe_send_message(npe, &msg, "HSS_LOAD_CONFIG"))
+			break;
+		if (npe_recv_message(npe, &msg, "HSS_LOAD_CONFIG"))
+			break;
+
+		/* HSS_LOAD_CONFIG for port #1 returns port_id = #4 */
+		if (msg.cmd != PORT_CONFIG_LOAD || msg.data32)
+			break;
+
+		/* HDLC may stop working without this */
+		npe_recv_message(npe, &msg, "FLUSH_IT");
+		return;
+	} while (0);
+
+	printk(KERN_CRIT "HSS-%i: unable to reload HSS configuration\n",
+	       port->id);
+	BUG();
+}
+
+static void hss_config_set_pcr(struct port *port)
+{
+	struct msg msg;
+
+	do {
+		memset(&msg, 0, sizeof(msg));
+		msg.cmd = PORT_CONFIG_WRITE;
+		msg.hss_port = port->id;
+		msg.index = HSS_CONFIG_TX_PCR;
+#if 0
+		msg.data32 = PCR_FRM_SYNC_RISINGEDGE | PCR_MSB_ENDIAN |
+			PCR_TX_DATA_ENABLE | PCR_TX_UNASS_HIGH_IMP | PCR_TX_V56K_HIGH_IMP | PCR_TX_FB_HIGH_IMP;
+#else
+		msg.data32 = PCR_FRM_SYNC_RISINGEDGE | PCR_MSB_ENDIAN |
+			PCR_TX_DATA_ENABLE | PCR_TX_FB_HIGH_IMP | PCR_DCLK_EDGE_RISING;
+#endif
+		if (port->frame_size % 8 == 0)
+			msg.data32 |= PCR_SOF_NO_FBIT;
+
+		if (npe_send_message(npe, &msg, "HSS_SET_TX_PCR"))
+			break;
+
+		msg.index = HSS_CONFIG_RX_PCR;
+		msg.data32 &= ~ (PCR_DCLK_EDGE_RISING | PCR_FCLK_EDGE_RISING | PCR_TX_DATA_ENABLE);
+
+		if (npe_send_message(npe, &msg, "HSS_SET_RX_PCR"))
+			break;
+		return;
+	} while (0);
+
+	printk(KERN_CRIT "HSS-%i: unable to set HSS PCR registers\n", port->id);
+	BUG();
+}
+
+static void hss_config_set_core(struct port *port)
+{
+	struct msg msg;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.cmd = PORT_CONFIG_WRITE;
+	msg.hss_port = port->id;
+	msg.index = HSS_CONFIG_CORE_CR;
+#if 0
+	msg.data32 = 0 | CCR_LOOPBACK |
+		(port->id ? CCR_SECOND_HSS : 0);
+#else
+	msg.data32 = 0 |
+		(port->id ? CCR_SECOND_HSS : 0);
+#endif
+	if (npe_send_message(npe, &msg, "HSS_SET_CORE_CR")) {
+		printk(KERN_CRIT "HSS-%i: unable to set HSS core control"
+		       " register\n", port->id);
+		BUG();
+	}
+}
+
+static void hss_config_set_line(struct port *port)
+{
+	struct msg msg;
+
+	hss_config_set_pcr(port);
+	hss_config_set_core(port);
+
+	memset(&msg, 0, sizeof(msg));
+	msg.cmd = PORT_CONFIG_WRITE;
+	msg.hss_port = port->id;
+	msg.index = HSS_CONFIG_CLOCK_CR;
+	msg.data32 = CLK42X_SPEED_8192KHZ /* FIXME */;
+	if (npe_send_message(npe, &msg, "HSS_SET_CLOCK_CR")) {
+		printk(KERN_CRIT "HSS-%i: unable to set HSS clock control"
+		       " register\n", port->id);
+		BUG();
+	}
+}
+
+static void hss_config_set_rx_frame(struct port *port)
+{
+	struct msg msg;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.cmd = PORT_CONFIG_WRITE;
+	msg.hss_port = port->id;
+	msg.index = HSS_CONFIG_RX_FCR;
+	msg.data16a = port->frame_sync_offset;
+	msg.data16b = port->frame_size - 1;
+	if (npe_send_message(npe, &msg, "HSS_SET_RX_FCR")) {
+		printk(KERN_CRIT "HSS-%i: unable to set HSS RX frame size"
+		       " and offset\n", port->id);
+		BUG();
+	}
+}
+
+static void hss_config_set_frame(struct port *port)
+{
+	struct msg msg;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.cmd = PORT_CONFIG_WRITE;
+	msg.hss_port = port->id;
+	msg.index = HSS_CONFIG_TX_FCR;
+	msg.data16a = TX_FRAME_SYNC_OFFSET;
+	msg.data16b = port->frame_size - 1;
+	if (npe_send_message(npe, &msg, "HSS_SET_TX_FCR")) {
+		printk(KERN_CRIT "HSS-%i: unable to set HSS TX frame size"
+		       " and offset\n", port->id);
+		BUG();
+	}
+	hss_config_set_rx_frame(port);
+}
+
+static void hss_config_set_lut(struct port *port)
+{
+	struct msg msg;
+	int chan_count = 32;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.cmd = PORT_CONFIG_WRITE;
+	msg.hss_port = port->id;
+
+	msg.index = HSS_CONFIG_TX_LUT;
+	msg.data32 = 0xffffffff;
+	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
+	msg.index += 4;
+	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
+	msg.data32 = 0x0;
+	msg.index += 4;
+	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
+	msg.index += 4;
+	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
+	msg.index += 4;
+	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
+	msg.index += 4;
+	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
+	msg.index += 4;
+	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
+	msg.index += 4;
+	npe_send_message(npe, &msg, "HSS_SET_TX_LUT");
+
+	msg.index = HSS_CONFIG_RX_LUT;
+	msg.data32 = 0xffffffff;
+	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
+	msg.index += 4;
+	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
+	msg.data32 = 0x0;
+	msg.index += 4;
+	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
+	msg.index += 4;
+	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
+	msg.index += 4;
+	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
+	msg.index += 4;
+	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
+	msg.index += 4;
+	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
+	msg.index += 4;
+	npe_send_message(npe, &msg, "HSS_SET_RX_LUT");
+
+	hss_config_set_frame(port);
+
+	memset(&msg, 0, sizeof(msg));
+	msg.cmd = CHAN_NUM_CHANS_WRITE;
+	msg.hss_port = port->id;
+	msg.data8a = chan_count;
+	if (npe_send_message(npe, &msg, "CHAN_NUM_CHANS_WRITE")) {
+		printk(KERN_CRIT "HSS-%i: unable to set HSS channel count\n",
+		       port->id);
+		BUG();
+	}
+}
+
+static u32 hss_config_get_status(struct port *port)
+{
+	struct msg msg;
+
+	do {
+		memset(&msg, 0, sizeof(msg));
+		msg.cmd = PORT_ERROR_READ;
+		msg.hss_port = port->id;
+		if (npe_send_message(npe, &msg, "PORT_ERROR_READ"))
+			break;
+		if (npe_recv_message(npe, &msg, "PORT_ERROR_READ"))
+			break;
+
+		return msg.data32;
+	} while (0);
+
+	printk(KERN_CRIT "HSS-%i: unable to read HSS status\n", port->id);
+	BUG();
+}
+
+static void hss_config_start_chan(struct port *port)
+{
+	struct msg msg;
+
+	port->chan_last_tx = 0;
+	port->chan_last_rx = 0;
+
+	do {
+		memset(&msg, 0, sizeof(msg));
+		msg.cmd = CHAN_RX_BUF_ADDR_WRITE;
+		msg.hss_port = port->id;
+		msg.data32 = port->chan_rx_buf_phys;
+		if (npe_send_message(npe, &msg, "CHAN_RX_BUF_ADDR_WRITE"))
+			break;
+
+		memset(&msg, 0, sizeof(msg));
+		msg.cmd = CHAN_TX_BUF_ADDR_WRITE;
+		msg.hss_port = port->id;
+		msg.data32 = port->chan_tx_pointers_phys;
+		if (npe_send_message(npe, &msg, "CHAN_TX_BUF_ADDR_WRITE"))
+			break;
+
+		memset(&msg, 0, sizeof(msg));
+		msg.cmd = CHAN_FLOW_ENABLE;
+		msg.hss_port = port->id;
+		if (npe_send_message(npe, &msg, "CHAN_FLOW_ENABLE"))
+			break;
+		port->chan_started = 1;
+		return;
+	} while (0);
+
+	printk(KERN_CRIT "HSS-%i: unable to start channelized flow\n",
+	       port->id);
+	BUG();
+}
+
+static void hss_config_stop_chan(struct port *port)
+{
+	struct msg msg;
+
+	if (!port->chan_started)
+		return;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.cmd = CHAN_FLOW_DISABLE;
+	msg.hss_port = port->id;
+	if (npe_send_message(npe, &msg, "CHAN_FLOW_DISABLE")) {
+		printk(KERN_CRIT "HSS-%i: unable to stop channelized flow\n",
+		       port->id);
+		BUG();
+	}
+	hss_config_get_status(port); /* make sure it's halted */
+	port->chan_started = 0;
+}
+
+static int hss_config_load_firmware(struct port *port)
+{
+	struct msg msg;
+
+	if (port->initialized)
+		return 0;
+
+	if (!npe_running(npe)) {
+		int err;
+		if ((err = npe_load_firmware(npe, "NPE-A-HSS",
+					     port->dev)))
+			return err;
+	}
+
+	do {
+		/* HSS main configuration */
+		hss_config_set_line(port);
+
+		hss_config_set_frame(port);
+
+		/* Channelized operation settings */
+		memset(&msg, 0, sizeof(msg));
+		msg.cmd = CHAN_TX_BLK_CFG_WRITE;
+		msg.hss_port = port->id;
+		msg.data8b = (CHAN_TX_LIST_FRAMES & ~7) / 2;
+		msg.data8a = msg.data8b / 4;
+		msg.data8d = CHAN_TX_LIST_FRAMES - msg.data8b;
+		msg.data8c = msg.data8d / 4;
+		if (npe_send_message(npe, &msg, "CHAN_TX_BLK_CFG_WRITE"))
+			break;
+
+		memset(&msg, 0, sizeof(msg));
+		msg.cmd = CHAN_RX_BUF_CFG_WRITE;
+		msg.hss_port = port->id;
+		msg.data8a = CHAN_RX_TRIGGER / 8;
+		msg.data8b = CHAN_RX_FRAMES;
+		if (npe_send_message(npe, &msg, "CHAN_RX_BUF_CFG_WRITE"))
+			break;
+
+		memset(&msg, 0, sizeof(msg));
+		msg.cmd = CHAN_TX_BUF_SIZE_WRITE;
+		msg.hss_port = port->id;
+		msg.data8a = CHAN_TX_LISTS;
+		if (npe_send_message(npe, &msg, "CHAN_TX_BUF_SIZE_WRITE"))
+			break;
+
+		port->initialized = 1;
+		return 0;
+	} while (0);
+
+	printk(KERN_CRIT "HSS-%i: unable to start HSS operation\n", port->id);
+	BUG();
+}
+
+void hss_chan_irq(void *pdev)
+{
+	struct port *port = pdev;
+
+	qmgr_disable_irq(queue_ids[port->id].chan);
+
+	tasklet_hi_schedule(&port->task);
+}
+
+
+int hss_prepare_chan(struct port *port)
+{
+	int err, i, j;
+	u32 *temp;
+	u32 temp2;
+	u8 *temp3;
+
+	if (port->initialized)
+		return 0;
+
+	if ((err = hss_config_load_firmware(port)))
+		return err;
+
+	if ((err = qmgr_request_queue(queue_ids[port->id].chan,
+				      CHAN_QUEUE_LEN, 0, 0, "%s:hss", "hss")))
+		return err;
+
+	port->chan_tx_buf = dma_alloc_coherent(port->dev, chan_tx_buf_len(port), &port->chan_tx_buf_phys, GFP_DMA);
+	memset(port->chan_tx_buf, 0, chan_tx_buf_len(port));
+
+	port->chan_tx_pointers = dma_alloc_coherent(port->dev, chan_tx_buf_len(port) / CHAN_TX_LIST_FRAMES * 4, &port->chan_tx_pointers_phys, GFP_DMA);
+
+	temp3 = port->chan_tx_buf;
+	for (i = 0; i < CHAN_TX_LISTS; i++) {
+		for (j = 0; j < 8; j++) {
+			port->tx_lists[i][j] = temp3;
+			temp3 += CHAN_TX_LIST_FRAMES * 4;
+		}
+	}
+
+	temp = port->chan_tx_pointers;
+	temp2 = port->chan_tx_buf_phys;
+	for (i = 0; i < CHAN_TX_LISTS; i++)
+	{
+		for (j = 0; j < 32; j++)
+		{
+			*temp = temp2;
+			temp2 += CHAN_TX_LIST_FRAMES;
+			temp++;
+		}
+	}
+
+	port->chan_rx_buf = dma_alloc_coherent(port->dev, chan_rx_buf_len(port), &port->chan_rx_buf_phys, GFP_DMA);
+
+	for (i = 0; i < 8; i++) {
+		temp3 = port->chan_rx_buf + (i * 4 * 128);
+		for (j = 0; j < 8; j++) {
+			port->rx_frames[i][j] = temp3;
+			temp3 += CHAN_RX_TRIGGER;
+		}
+	}
+
+	qmgr_set_irq(queue_ids[port->id].chan, QUEUE_IRQ_SRC_NOT_EMPTY,
+		     hss_chan_irq, port);
+
+	return 0;
+
+}
+
+int hss_tx_start(struct hss_device *hdev)
+{
+	unsigned long flags;
+	struct port *port = hdev->port;
+
+	hdev->tx_loc = 0;
+	hdev->tx_frame = 0;
+
+	set_bit((1 << hdev->id), &port->chan_tx_bitmap);
+
+	if (!port->chan_started)
+	{
+		qmgr_enable_irq(queue_ids[port->id].chan);
+		spin_lock_irqsave(&npe_lock, flags);
+		hss_config_start_chan(port);
+		spin_unlock_irqrestore(&npe_lock, flags);
+		hss_chan_irq(port);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(hss_tx_start);
+
+int hss_rx_start(struct hss_device *hdev)
+{
+	unsigned long flags;
+	struct port *port = hdev->port;
+
+	hdev->rx_loc = 0;
+	hdev->rx_frame = 0;
+
+	set_bit((1 << hdev->id), &port->chan_rx_bitmap);
+
+	if (!port->chan_started)
+	{
+		qmgr_enable_irq(queue_ids[port->id].chan);
+		spin_lock_irqsave(&npe_lock, flags);
+		hss_config_start_chan(port);
+		spin_unlock_irqrestore(&npe_lock, flags);
+		hss_chan_irq(port);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(hss_rx_start);
+
+int hss_tx_stop(struct hss_device *hdev)
+{
+	struct port *port = hdev->port;
+
+	clear_bit((1 << hdev->id), &port->chan_tx_bitmap);
+
+	return 0;
+}
+EXPORT_SYMBOL(hss_tx_stop);
+
+int hss_rx_stop(struct hss_device *hdev)
+{
+	struct port *port = hdev->port;
+
+	clear_bit((1 << hdev->id), &port->chan_rx_bitmap);
+
+	return 0;
+}
+EXPORT_SYMBOL(hss_rx_stop);
+
+int hss_chan_open(struct hss_device *hdev)
+{
+	struct port *port = hdev->port;
+	int i, err = 0;
+
+	if (port->chan_open)
+		return 0;
+
+	if (port->mode == MODE_HDLC) {
+		err = -ENOSYS;
+		goto out;
+	}
+
+	if (port->mode == MODE_G704 && port->channels[0] == hdev->id) {
+		err = -EBUSY; /* channel #0 is used for G.704 signaling */
+		goto out;
+	}
+
+	for (i = MAX_CHANNELS; i > port->frame_size / 8; i--)
+		if (port->channels[i - 1] == hdev->id) {
+			err = -ECHRNG; /* frame too short */
+			goto out;
+		}
+
+	hdev->rx_loc = hdev->tx_loc = 0;
+	hdev->rx_frame = hdev->tx_frame = 0;
+
+	//clear_bit((1 << hdev->id), &port->chan_rx_bitmap);
+	//clear_bit((1 << hdev->id), &port->chan_tx_bitmap);
+
+	if (!port->initialized) {
+		hss_prepare_chan(port);
+
+		hss_config_stop_chan(port);
+		hdev->open_count++;
+		port->chan_open_count++;
+
+		hss_config_set_lut(port);
+		hss_config_load(port);
+
+	}
+	port->chan_open = 1;
+
+out:
+	return err;
+}
+EXPORT_SYMBOL(hss_chan_open);
+
+int hss_chan_close(struct hss_device *hdev)
+{
+	return 0;
+}
+EXPORT_SYMBOL(hss_chan_close);
+
+void hss_chan_read(unsigned long data)
+{
+	struct port *port = (void *)data;
+	struct hss_device *hdev;
+	u8 *hw_buf, *save_buf;
+	u8 *buf;
+	u32 v;
+  unsigned int tx_list, rx_frame;
+	int i, j, channel;
+	u8 more_work = 0;
+
+/*
+	My Data in the hardware buffer is scattered by channels into 4 trunks
+	as follows for rx
+
+					channel 0					channel 1					channel 2					channel 3
+Trunk 1	=	0			-> 	127			128		->	255			256		->	383			384		->	512
+Trunk 2 =	513		->	639			640		->	768			769		->	895			896		->	1023
+Trunk 3 =	1024	->	1151		1152	->	1207		1208	->	1407		1408	->	1535
+Trunk 4 = 1535	->	1663		1664	->	1791		1792	->	1920		1921	->	2047
+
+	I will get CHAN_RX_TRIGGER worth of bytes out of each channel on each trunk
+	with each IRQ
+
+	For TX Data, it is split into 8 lists with each list containing 16 bytes per
+	channel
+
+Trunk 1 = 0		->	16				17		->	32			33		->	48			49		->	64
+Trunk 2 = 65	->	80				81		->	96			97		->	112			113		->	128
+Trunk	3	=	129	->	144				145		->	160			161		->	176			177		->	192
+Trunk	4	=	193	->	208				209		->	224			225		->	240			241		->	256
+
+*/
+
+
+	while ((v = qmgr_get_entry(queue_ids[port->id].chan)))
+	{
+		tx_list = (v >> 8) & 0xFF;
+		rx_frame = v & 0xFF;
+
+		if (tx_list == 7)
+			tx_list = 0;
+		else
+			tx_list++;
+		for (channel = 0; channel < 8; channel++) {
+
+			hdev = port->chan_devices[channel];
+			if (!hdev)
+				continue;
+
+			if (test_bit(1 << channel, &port->chan_tx_bitmap)) {
+				buf = (u8 *)hdev->tx_buf + hdev->tx_loc;
+#if 0
+				hw_buf = (u8 *)port->chan_tx_buf;
+				hw_buf += (tx_list * CHAN_TX_LIST_FRAMES * 32);
+				hw_buf += (4 * CHAN_TX_LIST_FRAMES * channel);
+				save_buf = hw_buf;
+#else
+				save_buf = port->tx_lists[tx_list][channel];
+#endif
+				for (i = 0; i < CHAN_TX_LIST_FRAMES; i++) {
+					hw_buf = save_buf + i;
+					for (j = 0; j < 4; j++) {
+						*hw_buf = *(buf++);
+						hw_buf += CHAN_TX_LIST_FRAMES;
+					}
+
+					hdev->tx_loc += 4;
+					hdev->tx_frame++;
+					if (hdev->tx_loc >= hdev->tx_buffer_size) {
+						hdev->tx_loc = 0;
+						buf = (u8 *)hdev->tx_buf;
+					}
+				}
+			} else {
+#if 0
+				hw_buf = (u8 *)port->chan_tx_buf;
+				hw_buf += (tx_list * CHAN_TX_LIST_FRAMES * 32);
+				hw_buf += (4 * CHAN_TX_LIST_FRAMES * channel);
+#else
+				hw_buf = port->tx_lists[tx_list][channel];
+#endif
+				memset(hw_buf, 0, 64);
+			}
+
+			if (hdev->tx_frame >= hdev->tx_period_size && test_bit(1 << channel, &port->chan_tx_bitmap))
+			{
+				hdev->tx_frame %= hdev->tx_period_size;
+				if (hdev->tx_callback)
+					hdev->tx_callback(hdev->tx_data);
+				more_work = 1;
+			}
+
+			if (test_bit(1 << channel, &port->chan_rx_bitmap)) {
+				buf = (u8 *)hdev->rx_buf + hdev->rx_loc;
+#if 0
+				hw_buf = (u8 *)port->chan_rx_buf;
+				hw_buf += (4 * CHAN_RX_FRAMES * channel);
+				hw_buf += rx_frame;
+				save_buf = hw_buf;
+#else
+				save_buf = port->rx_frames[channel][rx_frame >> 4];
+#endif
+				for (i = 0; i < CHAN_RX_TRIGGER; i++) {
+					hw_buf = save_buf + i;
+					for (j = 0; j < 4; j++) {
+						*(buf++) = *hw_buf;
+						hw_buf += CHAN_RX_FRAMES;
+					}
+					hdev->rx_loc += 4;
+					hdev->rx_frame++;
+					if (hdev->rx_loc >= hdev->rx_buffer_size) {
+						hdev->rx_loc = 0;
+						buf = (u8 *)hdev->rx_buf;
+					}
+				}
+			}
+
+			if (hdev->rx_frame >= hdev->rx_period_size && test_bit(1 << channel, &port->chan_rx_bitmap))
+			{
+				hdev->rx_frame %= hdev->rx_period_size;
+				if (hdev->rx_callback)
+					hdev->rx_callback(hdev->rx_data);
+				more_work = 1;
+			}
+		}
+#if 0
+		if (more_work)
+		{
+			tasklet_hi_schedule(&port->task);
+			return;
+		}
+#endif
+	}
+
+	qmgr_enable_irq(queue_ids[port->id].chan);
+
+	return;
+
+}
+
+struct hss_device *hss_chan_create(struct port *port, unsigned int channel)
+{
+	struct hss_device *chan_dev;
+	unsigned long flags;
+
+	chan_dev = kzalloc(sizeof(struct hss_device), GFP_KERNEL);
+
+	spin_lock_irqsave(&npe_lock, flags);
+
+	chan_dev->id = channel;
+	chan_dev->port = port;
+
+	port->channels[channel] = channel;
+
+	port->chan_devices[channel] = chan_dev;
+
+	spin_unlock_irqrestore(&npe_lock, flags);
+
+	return chan_dev;
+}
+
+/*****************************************************************************
+ * initialization
+ ****************************************************************************/
+
+static struct platform_device gw_avila_hss_device_0 = {
+  .name     = "ixp4xx_hss",
+  .id       = 0,
+};
+
+static struct platform_device gw_avila_hss_device_1 = {
+  .name     = "ixp4xx_hss",
+  .id       = 1,
+};
+
+static struct platform_device *gw_avila_hss_port_0;
+static struct platform_device *gw_avila_hss_port_1;
+static u64 hss_dmamask = 0xFFFFFFFF;
+
+struct hss_device *hss_init(int id, int channel)
+{
+	struct port *port = hss_port[id];
+	struct hss_device *hdev;
+	int ret;
+
+	if (!lock_init)
+	{
+		spin_lock_init(&npe_lock);
+		lock_init = 1;
+		npe = npe_request(0);
+	}
+
+	if (!port->init) {
+		if (id == 0) {
+			gw_avila_hss_port_0 = platform_device_alloc("hss-port", 0);
+
+			platform_set_drvdata(gw_avila_hss_port_0, &gw_avila_hss_device_0);
+			port->dev = &gw_avila_hss_port_0->dev;
+
+			if (!port->dev->dma_mask)
+		    port->dev->dma_mask = &hss_dmamask;
+		  if (!port->dev->coherent_dma_mask)
+	    	port->dev->coherent_dma_mask = 0xFFFFFFFF;
+
+			ret = platform_device_add(gw_avila_hss_port_0);
+
+		  if (ret)
+	  	  platform_device_put(gw_avila_hss_port_0);
+
+			tasklet_init(&port->task, hss_chan_read, (unsigned long) port);
+		}
+		else
+		{
+			gw_avila_hss_port_1 = platform_device_alloc("hss-port", 1);
+
+			platform_set_drvdata(gw_avila_hss_port_1, &gw_avila_hss_device_1);
+			port->dev = &gw_avila_hss_port_1->dev;
+
+			if (!port->dev->dma_mask)
+		    port->dev->dma_mask = &hss_dmamask;
+		  if (!port->dev->coherent_dma_mask)
+	    	port->dev->coherent_dma_mask = 0xFFFFFFFF;
+
+			ret = platform_device_add(gw_avila_hss_port_1);
+
+		  if (ret)
+	  	  platform_device_put(gw_avila_hss_port_1);
+
+			tasklet_init(&port->task, hss_chan_read, (unsigned long) port);
+		}
+
+		port->init = 1;
+		port->id = id;
+		port->clock_type = CLOCK_EXT;
+		port->clock_rate = 8192000;
+		port->frame_size = 256; /* E1 */
+		port->mode = MODE_RAW;
+		port->next_rx_frame = 0;
+		memset(port->channels, CHANNEL_UNUSED, sizeof(port->channels));
+	}
+
+	hdev = hss_chan_create(port, channel);
+
+	return hdev;
+}
+EXPORT_SYMBOL(hss_init);
+
+int hss_set_tx_callback(struct hss_device *hdev, void (*tx_callback)(void *), void *tx_data)
+{
+  BUG_ON(tx_callback == NULL);
+  hdev->tx_callback = tx_callback;
+  hdev->tx_data = tx_data;
+
+  return 0;
+}
+EXPORT_SYMBOL(hss_set_tx_callback);
+
+int hss_set_rx_callback(struct hss_device *hdev, void (*rx_callback)(void *), void *rx_data)
+{
+  BUG_ON(rx_callback == NULL);
+  hdev->rx_callback = rx_callback;
+  hdev->rx_data = rx_data;
+
+  return 0;
+}
+EXPORT_SYMBOL(hss_set_rx_callback);
+
+int hss_config_rx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size)
+{
+	/*
+	 * Period Size and Buffer Size are in Frames which are u32
+	 * We convert the u32 *buf to u8 in order to make channel reads
+	 * and rx_loc easier
+	 */
+
+	hdev->rx_buf = (u8 *)buf;
+	hdev->rx_buffer_size = buffer_size << 2;
+	hdev->rx_period_size = period_size;
+
+	return 0;
+}
+EXPORT_SYMBOL(hss_config_rx_dma);
+
+int hss_config_tx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size)
+{
+	/*
+	 * Period Size and Buffer Size are in Frames which are u32
+	 * We convert the u32 *buf to u8 in order to make channel reads
+	 * and rx_loc easier
+	 */
+
+	hdev->tx_buf = (u8 *)buf;
+	hdev->tx_buffer_size = buffer_size << 2;
+	hdev->tx_period_size = period_size;
+
+	return 0;
+}
+EXPORT_SYMBOL(hss_config_tx_dma);
+
+unsigned long hss_curr_offset_rx(struct hss_device *hdev)
+{
+	return hdev->rx_loc >> 2;
+}
+EXPORT_SYMBOL(hss_curr_offset_rx);
+
+unsigned long hss_curr_offset_tx(struct hss_device *hdev)
+{
+	return hdev->tx_loc >> 2;
+}
+EXPORT_SYMBOL(hss_curr_offset_tx);
+
+MODULE_AUTHOR("Chris Lang");
+MODULE_DESCRIPTION("Intel IXP4xx HSS Audio driver");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/sound/soc/gw-avila/ixp4xx_hss.h
@@ -0,0 +1,401 @@
+/*
+ *
+ *
+ * Copyright (C) 2009 Gateworks Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/bitops.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/fs.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <mach/npe.h>
+#include <mach/qmgr.h>
+#include <linux/interrupt.h>
+
+//#include <linux/hdlc.h> XXX We aren't HDLC
+
+#define DEBUG_QUEUES		0
+#define DEBUG_DESC		0
+#define DEBUG_RX		0
+#define DEBUG_TX		0
+#define DEBUG_PKT_BYTES		0
+#define DEBUG_CLOSE		0
+#define DEBUG_FRAMER		0
+
+#define DRV_NAME		"ixp4xx_hss"
+
+#define PKT_EXTRA_FLAGS		0 /* orig 1 */
+#define TX_FRAME_SYNC_OFFSET	0 /* channelized */
+#define PKT_NUM_PIPES		1 /* 1, 2 or 4 */
+#define PKT_PIPE_FIFO_SIZEW	4 /* total 4 dwords per HSS */
+
+#define RX_DESCS		512 /* also length of all RX queues */
+#define TX_DESCS		512 /* also length of all TX queues */
+
+//#define POOL_ALLOC_SIZE		(sizeof(struct desc) * (RX_DESCS + TX_DESCS))
+#define RX_SIZE			(HDLC_MAX_MRU + 4) /* NPE needs more space */
+#define MAX_CLOSE_WAIT		1000 /* microseconds */
+#define HSS_COUNT		2
+#define MIN_FRAME_SIZE		16   /* bits */
+#define MAX_FRAME_SIZE		257  /* 256 bits + framing bit */
+#define MAX_CHANNELS		(MAX_FRAME_SIZE / 8)
+#define MAX_CHAN_DEVICES	32
+#define CHANNEL_HDLC		0xFE
+#define CHANNEL_UNUSED		0xFF
+
+#define NAPI_WEIGHT		16
+#define CHAN_RX_TRIGGER		16 /* 8 RX frames = 1 ms @ E1 */
+#define CHAN_RX_FRAMES		128
+#define CHAN_RX_TRUNKS		1
+#define MAX_CHAN_RX_BAD_SYNC	(CHAN_RX_TRIGGER / 2 /* pairs */ - 3)
+
+#define CHAN_TX_LIST_FRAMES	CHAN_RX_TRIGGER /* bytes/channel per list, 16 - 48 */
+#define CHAN_TX_LISTS		8
+#define CHAN_TX_TRUNKS CHAN_RX_TRUNKS
+#define CHAN_TX_FRAMES		(CHAN_TX_LIST_FRAMES * CHAN_TX_LISTS)
+
+#define CHAN_QUEUE_LEN		32 /* minimum possible */
+
+#define chan_rx_buf_len(port)	(port->frame_size / 8 * CHAN_RX_FRAMES * CHAN_RX_TRUNKS)
+#define chan_tx_buf_len(port) (port->frame_size / 8 * CHAN_TX_FRAMES * CHAN_TX_TRUNKS)
+
+/* Queue IDs */
+#define HSS0_CHL_RXTRIG_QUEUE	12	/* orig size = 32 dwords */
+#define HSS0_PKT_RX_QUEUE	13	/* orig size = 32 dwords */
+#define HSS0_PKT_TX0_QUEUE	14	/* orig size = 16 dwords */
+#define HSS0_PKT_TX1_QUEUE	15
+#define HSS0_PKT_TX2_QUEUE	16
+#define HSS0_PKT_TX3_QUEUE	17
+#define HSS0_PKT_RXFREE0_QUEUE	18	/* orig size = 16 dwords */
+#define HSS0_PKT_RXFREE1_QUEUE	19
+#define HSS0_PKT_RXFREE2_QUEUE	20
+#define HSS0_PKT_RXFREE3_QUEUE	21
+#define HSS0_PKT_TXDONE_QUEUE	22	/* orig size = 64 dwords */
+
+#define HSS1_CHL_RXTRIG_QUEUE	10
+#define HSS1_PKT_RX_QUEUE	0
+#define HSS1_PKT_TX0_QUEUE	5
+#define HSS1_PKT_TX1_QUEUE	6
+#define HSS1_PKT_TX2_QUEUE	7
+#define HSS1_PKT_TX3_QUEUE	8
+#define HSS1_PKT_RXFREE0_QUEUE	1
+#define HSS1_PKT_RXFREE1_QUEUE	2
+#define HSS1_PKT_RXFREE2_QUEUE	3
+#define HSS1_PKT_RXFREE3_QUEUE	4
+#define HSS1_PKT_TXDONE_QUEUE	9
+
+#define NPE_PKT_MODE_HDLC		0
+#define NPE_PKT_MODE_RAW		1
+#define NPE_PKT_MODE_56KMODE		2
+#define NPE_PKT_MODE_56KENDIAN_MSB	4
+
+/* PKT_PIPE_HDLC_CFG_WRITE flags */
+#define PKT_HDLC_IDLE_ONES		0x1 /* default = flags */
+#define PKT_HDLC_CRC_32			0x2 /* default = CRC-16 */
+#define PKT_HDLC_MSB_ENDIAN		0x4 /* default = LE */
+
+
+/* hss_config, PCRs */
+/* Frame sync sampling, default = active low */
+#define PCR_FRM_SYNC_ACTIVE_HIGH	0x40000000
+#define PCR_FRM_SYNC_FALLINGEDGE	0x80000000
+#define PCR_FRM_SYNC_RISINGEDGE		0xC0000000
+
+/* Frame sync pin: input (default) or output generated off a given clk edge */
+#define PCR_FRM_SYNC_OUTPUT_FALLING	0x20000000
+#define PCR_FRM_SYNC_OUTPUT_RISING	0x30000000
+
+/* Frame and data clock sampling on edge, default = falling */
+#define PCR_FCLK_EDGE_RISING		0x08000000
+#define PCR_DCLK_EDGE_RISING		0x04000000
+
+/* Clock direction, default = input */
+#define PCR_SYNC_CLK_DIR_OUTPUT		0x02000000
+
+/* Generate/Receive frame pulses, default = enabled */
+#define PCR_FRM_PULSE_DISABLED		0x01000000
+
+ /* Data rate is full (default) or half the configured clk speed */
+#define PCR_HALF_CLK_RATE		0x00200000
+
+/* Invert data between NPE and HSS FIFOs? (default = no) */
+#define PCR_DATA_POLARITY_INVERT	0x00100000
+
+/* TX/RX endianness, default = LSB */
+#define PCR_MSB_ENDIAN			0x00080000
+
+/* Normal (default) / open drain mode (TX only) */
+#define PCR_TX_PINS_OPEN_DRAIN		0x00040000
+
+/* No framing bit transmitted and expected on RX? (default = framing bit) */
+#define PCR_SOF_NO_FBIT			0x00020000
+
+/* Drive data pins? */
+#define PCR_TX_DATA_ENABLE		0x00010000
+
+/* Voice 56k type: drive the data pins low (default), high, high Z */
+#define PCR_TX_V56K_HIGH		0x00002000
+#define PCR_TX_V56K_HIGH_IMP		0x00004000
+
+/* Unassigned type: drive the data pins low (default), high, high Z */
+#define PCR_TX_UNASS_HIGH		0x00000800
+#define PCR_TX_UNASS_HIGH_IMP		0x00001000
+
+/* T1 @ 1.544MHz only: Fbit dictated in FIFO (default) or high Z */
+#define PCR_TX_FB_HIGH_IMP		0x00000400
+
+/* 56k data endiannes - which bit unused: high (default) or low */
+#define PCR_TX_56KE_BIT_0_UNUSED	0x00000200
+
+/* 56k data transmission type: 32/8 bit data (default) or 56K data */
+#define PCR_TX_56KS_56K_DATA		0x00000100
+
+/* hss_config, cCR */
+/* Number of packetized clients, default = 1 */
+#define CCR_NPE_HFIFO_2_HDLC		0x04000000
+#define CCR_NPE_HFIFO_3_OR_4HDLC	0x08000000
+
+/* default = no loopback */
+#define CCR_LOOPBACK			0x02000000
+
+/* HSS number, default = 0 (first) */
+#define CCR_SECOND_HSS			0x01000000
+
+
+/* hss_config, clkCR: main:10, num:10, denom:12 */
+#define CLK42X_SPEED_EXP	((0x3FF << 22) | (  2 << 12) |   15) /*65 KHz*/
+
+#define CLK42X_SPEED_512KHZ	((  130 << 22) | (  2 << 12) |   15)
+#define CLK42X_SPEED_1536KHZ	((   43 << 22) | ( 18 << 12) |   47)
+#define CLK42X_SPEED_1544KHZ	((   43 << 22) | ( 33 << 12) |  192)
+#define CLK42X_SPEED_2048KHZ	((   32 << 22) | ( 34 << 12) |   63)
+#define CLK42X_SPEED_4096KHZ	((   16 << 22) | ( 34 << 12) |  127)
+#define CLK42X_SPEED_8192KHZ	((    8 << 22) | ( 34 << 12) |  255)
+
+#define CLK46X_SPEED_512KHZ	((  130 << 22) | ( 24 << 12) |  127)
+#define CLK46X_SPEED_1536KHZ	((   43 << 22) | (152 << 12) |  383)
+#define CLK46X_SPEED_1544KHZ	((   43 << 22) | ( 66 << 12) |  385)
+#define CLK46X_SPEED_2048KHZ	((   32 << 22) | (280 << 12) |  511)
+#define CLK46X_SPEED_4096KHZ	((   16 << 22) | (280 << 12) | 1023)
+#define CLK46X_SPEED_8192KHZ	((    8 << 22) | (280 << 12) | 2047)
+
+
+/* hss_config, LUT entries */
+#define TDMMAP_UNASSIGNED	0
+#define TDMMAP_HDLC		1	/* HDLC - packetized */
+#define TDMMAP_VOICE56K		2	/* Voice56K - 7-bit channelized */
+#define TDMMAP_VOICE64K		3	/* Voice64K - 8-bit channelized */
+
+/* offsets into HSS config */
+#define HSS_CONFIG_TX_PCR	0x00 /* port configuration registers */
+#define HSS_CONFIG_RX_PCR	0x04
+#define HSS_CONFIG_CORE_CR	0x08 /* loopback control, HSS# */
+#define HSS_CONFIG_CLOCK_CR	0x0C /* clock generator control */
+#define HSS_CONFIG_TX_FCR	0x10 /* frame configuration registers */
+#define HSS_CONFIG_RX_FCR	0x14
+#define HSS_CONFIG_TX_LUT	0x18 /* channel look-up tables */
+#define HSS_CONFIG_RX_LUT	0x38
+
+
+/* NPE command codes */
+/* writes the ConfigWord value to the location specified by offset */
+#define PORT_CONFIG_WRITE		0x40
+
+/* triggers the NPE to load the contents of the configuration table */
+#define PORT_CONFIG_LOAD		0x41
+
+/* triggers the NPE to return an HssErrorReadResponse message */
+#define PORT_ERROR_READ			0x42
+
+/* reset NPE internal status and enable the HssChannelized operation */
+#define CHAN_FLOW_ENABLE		0x43
+#define CHAN_FLOW_DISABLE		0x44
+#define CHAN_IDLE_PATTERN_WRITE		0x45
+#define CHAN_NUM_CHANS_WRITE		0x46
+#define CHAN_RX_BUF_ADDR_WRITE		0x47
+#define CHAN_RX_BUF_CFG_WRITE		0x48
+#define CHAN_TX_BLK_CFG_WRITE		0x49
+#define CHAN_TX_BUF_ADDR_WRITE		0x4A
+#define CHAN_TX_BUF_SIZE_WRITE		0x4B
+#define CHAN_TSLOTSWITCH_ENABLE		0x4C
+#define CHAN_TSLOTSWITCH_DISABLE	0x4D
+
+/* downloads the gainWord value for a timeslot switching channel associated
+   with bypassNum */
+#define CHAN_TSLOTSWITCH_GCT_DOWNLOAD	0x4E
+
+/* triggers the NPE to reset internal status and enable the HssPacketized
+   operation for the flow specified by pPipe */
+#define PKT_PIPE_FLOW_ENABLE		0x50
+#define PKT_PIPE_FLOW_DISABLE		0x51
+#define PKT_NUM_PIPES_WRITE		0x52
+#define PKT_PIPE_FIFO_SIZEW_WRITE	0x53
+#define PKT_PIPE_HDLC_CFG_WRITE		0x54
+#define PKT_PIPE_IDLE_PATTERN_WRITE	0x55
+#define PKT_PIPE_RX_SIZE_WRITE		0x56
+#define PKT_PIPE_MODE_WRITE		0x57
+
+/* HDLC packet status values - desc->status */
+#define ERR_SHUTDOWN		1 /* stop or shutdown occurrance */
+#define ERR_HDLC_ALIGN		2 /* HDLC alignment error */
+#define ERR_HDLC_FCS		3 /* HDLC Frame Check Sum error */
+#define ERR_RXFREE_Q_EMPTY	4 /* RX-free queue became empty while receiving
+				     this packet (if buf_len < pkt_len) */
+#define ERR_HDLC_TOO_LONG	5 /* HDLC frame size too long */
+#define ERR_HDLC_ABORT		6 /* abort sequence received */
+#define ERR_DISCONNECTING	7 /* disconnect is in progress */
+
+#define CLOCK_EXT 0
+#define CLOCK_INT 1
+
+enum mode {MODE_HDLC = 0, MODE_RAW, MODE_G704};
+enum rx_tx_bit {
+	TX_BIT = 0,
+	RX_BIT = 1
+};
+enum chan_bit {
+	CHAN_0 = (1 << 0),
+	CHAN_1 = (1 << 1),
+	CHAN_2 = (1 << 2),
+	CHAN_3 = (1 << 3),
+	CHAN_4 = (1 << 4),
+	CHAN_5 = (1 << 5),
+	CHAN_6 = (1 << 6),
+	CHAN_7 = (1 << 7),
+	CHAN_8 = (1 << 8),
+	CHAN_9 = (1 << 9),
+	CHAN_10 = (1 << 10),
+	CHAN_11 = (1 << 11),
+	CHAN_12 = (1 << 12),
+	CHAN_13 = (1 << 13),
+	CHAN_14 = (1 << 14),
+	CHAN_15 = (1 << 15)
+};
+
+enum alignment { NOT_ALIGNED = 0, EVEN_FIRST, ODD_FIRST };
+
+#ifdef __ARMEB__
+typedef struct sk_buff buffer_t;
+#define free_buffer dev_kfree_skb
+#define free_buffer_irq dev_kfree_skb_irq
+#else
+typedef void buffer_t;
+#define free_buffer kfree
+#define free_buffer_irq kfree
+#endif
+
+struct hss_device {
+	struct port *port;
+	unsigned int open_count, excl_open;
+	unsigned long tx_loc, rx_loc; /* bytes */
+	unsigned long tx_frame, rx_frame; /* Frames */
+	u8 id, chan_count;
+	u8 log_channels[MAX_CHANNELS];
+
+  u8 *rx_buf;
+  u8 *tx_buf;
+
+	size_t rx_buffer_size;
+	size_t rx_period_size;
+	size_t tx_buffer_size;
+	size_t tx_period_size;
+
+  void (*rx_callback)(void *data);
+  void *rx_data;
+  void (*tx_callback)(void *data);
+  void *tx_data;
+  void *private_data;
+};
+
+extern struct hss_device *hss_handle[32];
+extern struct port *hss_port[2];
+
+struct port {
+	unsigned char init;
+
+	struct device *dev;
+
+	struct tasklet_struct task;
+	unsigned int id;
+	unsigned long chan_rx_bitmap;
+	unsigned long chan_tx_bitmap;
+	unsigned char chan_open;
+
+	/* the following fields must be protected by npe_lock */
+	enum mode mode;
+	unsigned int clock_type, clock_rate, loopback;
+	unsigned int frame_size, frame_sync_offset;
+	unsigned int next_rx_frame;
+
+	struct hss_device *chan_devices[MAX_CHAN_DEVICES];
+	u32 chan_tx_buf_phys, chan_rx_buf_phys;
+	u32	chan_tx_pointers_phys;
+	u32 *chan_tx_pointers;
+	u8 *chan_rx_buf;
+	u8 *chan_tx_buf;
+	u8 *tx_lists[CHAN_TX_LISTS][8];
+	u8 *rx_frames[8][CHAN_TX_LISTS];
+	unsigned int chan_open_count, hdlc_open;
+	unsigned int chan_started, initialized, just_set_offset;
+	unsigned int chan_last_rx, chan_last_tx;
+
+	/* assigned channels, may be invalid with given frame length or mode */
+	u8 channels[MAX_CHANNELS];
+	int msg_count;
+};
+
+/* NPE message structure */
+struct msg {
+#ifdef __ARMEB__
+	u8 cmd, unused, hss_port, index;
+	union {
+		struct { u8 data8a, data8b, data8c, data8d; };
+		struct { u16 data16a, data16b; };
+		struct { u32 data32; };
+	};
+#else
+	u8 index, hss_port, unused, cmd;
+	union {
+		struct { u8 data8d, data8c, data8b, data8a; };
+		struct { u16 data16b, data16a; };
+		struct { u32 data32; };
+	};
+#endif
+};
+
+#define rx_desc_phys(port, n)	((port)->desc_tab_phys +		\
+				 (n) * sizeof(struct desc))
+#define rx_desc_ptr(port, n)	(&(port)->desc_tab[n])
+
+#define tx_desc_phys(port, n)	((port)->desc_tab_phys +		\
+				 ((n) + RX_DESCS) * sizeof(struct desc))
+#define tx_desc_ptr(port, n)	(&(port)->desc_tab[(n) + RX_DESCS])
+
+int hss_prepare_chan(struct port *port);
+void hss_chan_stop(struct port *port);
+
+struct hss_device *hss_init(int id, int channel);
+int hss_chan_open(struct hss_device *hdev);
+int hss_chan_close(struct hss_device *hdev);
+
+int hss_set_tx_callback(struct hss_device *hdev, void (*tx_callback)(void *), void *tx_data);
+int hss_set_rx_callback(struct hss_device *hdev, void (*rx_callback)(void *), void *rx_data);
+int hss_tx_start(struct hss_device *hdev);
+int hss_tx_stop(struct hss_device *hdev);
+int hss_rx_start(struct hss_device *hdev);
+int hss_rx_stop(struct hss_device *hdev);
+
+int hss_config_rx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size);
+int hss_config_tx_dma(struct hss_device *hdev, void *buf, size_t buffer_size, size_t period_size);
+unsigned long hss_curr_offset_rx(struct hss_device *hdev);
+unsigned long hss_curr_offset_tx(struct hss_device *hdev);
+

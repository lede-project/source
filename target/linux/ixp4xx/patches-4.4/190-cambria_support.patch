--- a/arch/arm/mach-ixp4xx/Kconfig
+++ b/arch/arm/mach-ixp4xx/Kconfig
@@ -21,6 +21,14 @@ config MACH_AVILA
 	  Avila Network Platform. For more information on this platform,
 	  see <file:Documentation/arm/IXP4xx>.
 
+config MACH_CAMBRIA
+	bool "Cambria"
+	select PCI
+	help
+	  Say 'Y' here if you want your kernel to support the Gateworks
+	  Cambria series. For more information on this platform,
+	  see <file:Documentation/arm/IXP4xx>.
+
 config MACH_LOFT
     bool "Loft"
     depends on MACH_AVILA
@@ -218,7 +226,7 @@ config CPU_IXP46X
 
 config CPU_IXP43X
 	bool
-	depends on MACH_KIXRP435
+	depends on MACH_KIXRP435 || MACH_CAMBRIA
 	default y
 
 config MACH_GTWX5715
--- a/arch/arm/mach-ixp4xx/Makefile
+++ b/arch/arm/mach-ixp4xx/Makefile
@@ -7,6 +7,7 @@ obj-pci-n	:=
 
 obj-pci-$(CONFIG_ARCH_IXDP4XX)		+= ixdp425-pci.o
 obj-pci-$(CONFIG_MACH_AVILA)		+= avila-pci.o
+obj-pci-$(CONFIG_MACH_CAMBRIA)		+= cambria-pci.o
 obj-pci-$(CONFIG_MACH_IXDPG425)		+= ixdpg425-pci.o
 obj-pci-$(CONFIG_ARCH_ADI_COYOTE)	+= coyote-pci.o
 obj-pci-$(CONFIG_MACH_GTWX5715)		+= gtwx5715-pci.o
@@ -31,6 +32,7 @@ obj-y	+= common.o
 
 obj-$(CONFIG_ARCH_IXDP4XX)	+= ixdp425-setup.o
 obj-$(CONFIG_MACH_AVILA)	+= avila-setup.o
+obj-$(CONFIG_MACH_CAMBRIA)	+= cambria-setup.o
 obj-$(CONFIG_MACH_IXDPG425)	+= coyote-setup.o
 obj-$(CONFIG_ARCH_ADI_COYOTE)	+= coyote-setup.o
 obj-$(CONFIG_MACH_GTWX5715)	+= gtwx5715-setup.o
--- /dev/null
+++ b/arch/arm/mach-ixp4xx/cambria-pci.c
@@ -0,0 +1,78 @@
+/*
+ * arch/arch/mach-ixp4xx/cambria-pci.c
+ *
+ * PCI setup routines for Gateworks Cambria series
+ *
+ * Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ * based on coyote-pci.c:
+ *	Copyright (C) 2002 Jungo Software Technologies.
+ *	Copyright (C) 2003 MontaVista Softwrae, Inc.
+ *
+ * Maintainer: Imre Kaloz <kaloz@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+
+#include <asm/mach/pci.h>
+
+extern void ixp4xx_pci_preinit(void);
+extern int ixp4xx_setup(int nr, struct pci_sys_data *sys);
+extern struct pci_bus *ixp4xx_scan_bus(int nr, struct pci_sys_data *sys);
+
+void __init cambria_pci_preinit(void)
+{
+	irq_set_irq_type(IRQ_IXP4XX_GPIO11, IRQ_TYPE_LEVEL_LOW);
+	irq_set_irq_type(IRQ_IXP4XX_GPIO10, IRQ_TYPE_LEVEL_LOW);
+	irq_set_irq_type(IRQ_IXP4XX_GPIO9, IRQ_TYPE_LEVEL_LOW);
+	irq_set_irq_type(IRQ_IXP4XX_GPIO8, IRQ_TYPE_LEVEL_LOW);
+
+	ixp4xx_pci_preinit();
+}
+
+static int __init cambria_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	if (slot == 1)
+		return IRQ_IXP4XX_GPIO11;
+	else if (slot == 2)
+		return IRQ_IXP4XX_GPIO10;
+	else if (slot == 3)
+		return IRQ_IXP4XX_GPIO9;
+	else if (slot == 4)
+		return IRQ_IXP4XX_GPIO8;
+	else if (slot == 6)
+		return IRQ_IXP4XX_GPIO10;
+	else if (slot == 15)
+		return IRQ_IXP4XX_GPIO8;
+
+	else return -1;
+}
+
+struct hw_pci cambria_pci __initdata = {
+	.nr_controllers = 1,
+	.preinit =        cambria_pci_preinit,
+	.ops =            &ixp4xx_ops,
+	.setup =          ixp4xx_setup,
+	.map_irq =        cambria_map_irq,
+};
+
+int __init cambria_pci_init(void)
+{
+	if (machine_is_cambria())
+		pci_common_init(&cambria_pci);
+	return 0;
+}
+
+subsys_initcall(cambria_pci_init);
--- /dev/null
+++ b/arch/arm/mach-ixp4xx/cambria-setup.c
@@ -0,0 +1,1003 @@
+/*
+ * arch/arm/mach-ixp4xx/cambria-setup.c
+ *
+ * Board setup for the Gateworks Cambria series
+ *
+ * Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ * Copyright (C) 2012 Gateworks Corporation <support@gateworks.com>
+ *
+ * based on coyote-setup.c:
+ *      Copyright (C) 2003-2005 MontaVista Software, Inc.
+ *
+ * Author: Imre Kaloz <kaloz@openwrt.org>
+ *         Tim Harvey <tharvey@gateworks.com>
+ */
+
+#include <linux/device.h>
+#include <linux/gpio_keys.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_data/at24.h>
+#include <linux/i2c/gw_i2c_pld.h>
+#include <linux/platform_data/pca953x.h>
+#include <linux/if_ether.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/leds.h>
+#include <linux/memory.h>
+#include <linux/netdevice.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/slab.h>
+#include <linux/socket.h>
+#include <linux/types.h>
+#include <linux/tty.h>
+#include <linux/irq.h>
+#include <linux/usb/ehci_pdriver.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+#include <asm/setup.h>
+
+#define ARRAY_AND_SIZE(x)       (x), ARRAY_SIZE(x)
+
+struct cambria_board_info {
+	unsigned char	*model;
+	void		(*setup)(void);
+};
+
+static struct cambria_board_info *cambria_info __initdata;
+
+static struct flash_platform_data cambria_flash_data = {
+	.map_name	= "cfi_probe",
+	.width		= 2,
+};
+
+static struct resource cambria_flash_resource = {
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device cambria_flash = {
+	.name		= "IXP4XX-Flash",
+	.id		= 0,
+	.dev		= {
+		.platform_data = &cambria_flash_data,
+	},
+	.num_resources	= 1,
+	.resource	= &cambria_flash_resource,
+};
+
+static struct i2c_gpio_platform_data cambria_i2c_gpio_data = {
+	.sda_pin	= 7,
+	.scl_pin	= 6,
+};
+
+static struct platform_device cambria_i2c_gpio = {
+	.name		= "i2c-gpio",
+	.id		= 0,
+	.dev = {
+		.platform_data	= &cambria_i2c_gpio_data,
+	},
+};
+
+#ifdef SFP_SERIALID
+static struct i2c_gpio_platform_data cambria_i2c_gpio_sfpa_data = {
+	.sda_pin	= 113,
+	.scl_pin	= 112,
+	.sda_is_open_drain = 0,
+	.scl_is_open_drain = 0,
+};
+
+static struct platform_device cambria_i2c_gpio_sfpa = {
+	.name		= "i2c-gpio",
+	.id		= 1,
+	.dev = {
+		.platform_data	= &cambria_i2c_gpio_sfpa_data,
+	},
+};
+
+static struct i2c_gpio_platform_data cambria_i2c_gpio_sfpb_data = {
+	.sda_pin	= 115,
+	.scl_pin	= 114,
+	.sda_is_open_drain = 0,
+	.scl_is_open_drain = 0,
+};
+
+static struct platform_device cambria_i2c_gpio_sfpb = {
+	.name		= "i2c-gpio",
+	.id		= 2,
+	.dev = {
+		.platform_data	= &cambria_i2c_gpio_sfpb_data,
+	},
+};
+#endif // #ifdef SFP_SERIALID
+
+static struct eth_plat_info cambria_npec_data = {
+	.phy		= 1,
+	.rxq		= 4,
+	.txreadyq	= 21,
+};
+
+static struct eth_plat_info cambria_npea_data = {
+	.phy		= 2,
+	.rxq		= 2,
+	.txreadyq	= 19,
+};
+
+static struct platform_device cambria_npec_device = {
+	.name			= "ixp4xx_eth",
+	.id			= IXP4XX_ETH_NPEC,
+	.dev.platform_data	= &cambria_npec_data,
+	.dev.coherent_dma_mask	= DMA_BIT_MASK(32),
+};
+
+static struct platform_device cambria_npea_device = {
+	.name			= "ixp4xx_eth",
+	.id			= IXP4XX_ETH_NPEA,
+	.dev.platform_data	= &cambria_npea_data,
+	.dev.coherent_dma_mask	= DMA_BIT_MASK(32),
+};
+
+static struct resource cambria_uart_resource = {
+	.start	= IXP4XX_UART1_BASE_PHYS,
+	.end	= IXP4XX_UART1_BASE_PHYS + 0x0fff,
+	.flags	= IORESOURCE_MEM,
+};
+
+static struct plat_serial8250_port cambria_uart_data[] = {
+	{
+		.mapbase	= IXP4XX_UART1_BASE_PHYS,
+		.membase	= (char *)IXP4XX_UART1_BASE_VIRT + REG_OFFSET,
+		.irq		= IRQ_IXP4XX_UART1,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= IXP4XX_UART_XTAL,
+	},
+	{ },
+};
+
+static struct platform_device cambria_uart = {
+	.name		= "serial8250",
+	.id		= PLAT8250_DEV_PLATFORM,
+	.dev = {
+		.platform_data	= cambria_uart_data,
+	},
+	.num_resources	= 1,
+	.resource	= &cambria_uart_resource,
+};
+
+static struct resource cambria_optional_uart_resources[] = {
+	{
+		.start	= 0x52000000,
+		.end	= 0x52000fff,
+		.flags	= IORESOURCE_MEM
+	},
+	{
+		.start	= 0x53000000,
+		.end	= 0x53000fff,
+		.flags	= IORESOURCE_MEM
+	},
+	{
+		.start	= 0x52000000,
+		.end	= 0x52000fff,
+		.flags	= IORESOURCE_MEM
+	},
+	{
+		.start	= 0x52000000,
+		.end	= 0x52000fff,
+		.flags	= IORESOURCE_MEM
+	},
+	{
+		.start	= 0x52000000,
+		.end	= 0x52000fff,
+		.flags	= IORESOURCE_MEM
+	},
+	{
+		.start	= 0x52000000,
+		.end	= 0x52000fff,
+		.flags	= IORESOURCE_MEM
+	},
+	{
+		.start	= 0x52000000,
+		.end	= 0x52000fff,
+		.flags	= IORESOURCE_MEM
+	},
+	{
+		.start	= 0x53000000,
+		.end	= 0x53000fff,
+		.flags	= IORESOURCE_MEM
+	}
+};
+
+static struct plat_serial8250_port cambria_optional_uart_data[] = {
+	{
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM_DELAY,
+		.regshift	= 0,
+		.uartclk	= 1843200,
+		.rw_delay	= 10,
+	},
+	{
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM_DELAY,
+		.regshift	= 0,
+		.uartclk	= 1843200,
+		.rw_delay	= 10,
+	},
+	{
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 0,
+		.uartclk	= 18432000,
+	},
+	{
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 0,
+		.uartclk	= 18432000,
+	},
+	{
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 0,
+		.uartclk	= 18432000,
+	},
+	{
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 0,
+		.uartclk	= 18432000,
+	},
+	{
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 0,
+		.uartclk	= 18432000,
+	},
+  { },
+};
+
+static struct platform_device cambria_optional_uart = {
+	.name		= "serial8250",
+	.id		= PLAT8250_DEV_PLATFORM1,
+	.dev.platform_data	= cambria_optional_uart_data,
+	.num_resources	= 2,
+	.resource	= cambria_optional_uart_resources,
+};
+
+static struct resource cambria_pata_resources[] = {
+	{
+		.flags	= IORESOURCE_MEM
+	},
+	{
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "intrq",
+		.start	= IRQ_IXP4XX_GPIO12,
+		.end	= IRQ_IXP4XX_GPIO12,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct ixp4xx_pata_data cambria_pata_data = {
+	.cs0_bits	= 0xbfff3c03,
+	.cs1_bits	= 0xbfff3c03,
+};
+
+static struct platform_device cambria_pata = {
+	.name			= "pata_ixp4xx_cf",
+	.id			= 0,
+	.dev.platform_data      = &cambria_pata_data,
+	.num_resources		= ARRAY_SIZE(cambria_pata_resources),
+	.resource		= cambria_pata_resources,
+};
+
+static struct gpio_led cambria_gpio_leds[] = {
+	{
+		.name		= "user",
+		.gpio		= 5,
+		.active_low 	= 1,
+	},
+	{
+		.name		= "user2",
+		.gpio		= 0,
+		.active_low 	= 1,
+	},
+	{
+		.name		= "user3",
+		.gpio		= 0,
+		.active_low 	= 1,
+	},
+	{
+		.name		= "user4",
+		.gpio		= 0,
+		.active_low 	= 1,
+	}
+};
+
+static struct gpio_led_platform_data cambria_gpio_leds_data = {
+	.num_leds	= 1,
+	.leds		= cambria_gpio_leds,
+};
+
+static struct platform_device cambria_gpio_leds_device = {
+	.name		= "leds-gpio",
+	.id		= -1,
+	.dev.platform_data = &cambria_gpio_leds_data,
+};
+
+static struct resource cambria_gpio_resources[] = {
+	{
+		.name = "gpio",
+		.flags  = 0,
+	},
+};
+
+static struct gpio cambria_gpios_gw2350[] = {
+	// ARM GPIO
+#if 0 // configured from bootloader
+	{  0, GPIOF_IN,            "ARM_DIO0" },
+	{  1, GPIOF_IN,            "ARM_DIO1" },
+	{  2, GPIOF_IN,            "ARM_DIO2" },
+	{  3, GPIOF_IN,            "ARM_DIO3" },
+	{  4, GPIOF_IN,            "ARM_DIO4" },
+	{  5, GPIOF_IN,            "ARM_DIO5" },
+	{ 12, GPIOF_OUT_INIT_HIGH, "WDOGEN#" },
+#endif
+	{  8, GPIOF_IN,            "ARM_DIO8" },
+	{  9, GPIOF_IN,            "ARM_DIO9" },
+};
+
+static struct gpio cambria_gpios_gw2358[] = {
+	// ARM GPIO
+#if 0 // configured from bootloader
+	{  0, GPIOF_IN,            "*VINLOW#" },
+	{  2, GPIOF_IN,            "*GPS_PPS" },
+	{  3, GPIOF_IN,            "*GPS_IRQ#" },
+	{  4, GPIOF_IN,            "*RS485_IRQ#" },
+	{  5, GPIOF_IN,            "*SER_EN#" },
+	{ 14, GPIOF_OUT_INIT_HIGH, "*WDOGEN#" },
+#endif
+};
+
+static struct gpio cambria_gpios_gw2359[] = {
+	// ARM GPIO
+#if 0 // configured from bootloader
+	{  0, GPIOF_IN,            "*PCA_IRQ#" },
+	{  1, GPIOF_IN,            "ARM_DIO1" },
+	{  2, GPIOF_IN,            "ARM_DIO2" },
+	{  3, GPIOF_IN,            "ARM_DIO3" },
+	{  4, GPIOF_IN,            "ARM_DIO4" },
+	{  5, GPIOF_IN,            "ARM_DIO5" },
+	{  8, GPIOF_OUT_INIT_HIGH, "*WDOGEN#" },
+#endif
+	{ 11, GPIOF_OUT_INIT_HIGH, "*SER_EN"   },       // console serial enable
+	{ 12, GPIOF_IN,            "*GSC_IRQ#" },
+	{ 13, GPIOF_OUT_INIT_HIGH, "*PCIE_RST#"},
+	// GSC GPIO
+#if !(IS_ENABLED(CONFIG_KEYBOARD_GPIO_POLLED))
+	{100, GPIOF_IN,            "*USER_PB#" },
+#endif
+	{103, GPIOF_OUT_INIT_HIGH, "*5V_EN" },         // 5V aux supply enable
+	{108, GPIOF_IN,            "*SMUXDA0" },
+	{109, GPIOF_IN,            "*SMUXDA1" },
+	{110, GPIOF_IN,            "*SMUXDA2" },
+	{111, GPIOF_IN,            "*SMUXDB0" },
+	{112, GPIOF_IN,            "*SMUXDB1" },
+	{113, GPIOF_IN,            "*SMUXDB2" },
+	// PCA GPIO
+	{118, GPIOF_IN,            "*USIM2_DET#"},     // USIM2 Detect
+	{120, GPIOF_OUT_INIT_LOW,  "*USB1_PCI_SEL"},   // USB1  Select (1=PCI, 0=FP)
+	{121, GPIOF_OUT_INIT_LOW,  "*USB2_PCI_SEL"},   // USB2  Select (1=PCI, 0=FP)
+	{122, GPIOF_IN,            "*USIM1_DET#"},     // USIM1 Detect
+	{123, GPIOF_OUT_INIT_HIGH, "*COM1_DTR#" },     // J21/J10
+	{124, GPIOF_IN,            "*COM1_DSR#" },     // J21/J10
+	{127, GPIOF_IN,            "PCA_DIO0" },
+	{128, GPIOF_IN,            "PCA_DIO1" },
+	{129, GPIOF_IN,            "PCA_DIO2" },
+	{130, GPIOF_IN,            "PCA_DIO3" },
+	{131, GPIOF_IN,            "PCA_DIO4" },
+};
+
+static struct gpio cambria_gpios_gw2360[] = {
+	// ARM GPIO
+	{  0, GPIOF_IN,            "*PCA_IRQ#" },
+	{ 11, GPIOF_OUT_INIT_LOW, "*SER0_EN#" },
+	{ 12, GPIOF_IN,            "*GSC_IRQ#" },
+	{ 13, GPIOF_OUT_INIT_HIGH, "*PCIE_RST#"},
+	// GSC GPIO
+#if !(IS_ENABLED(CONFIG_KEYBOARD_GPIO_POLLED))
+	{100, GPIOF_IN,            "*USER_PB#" },
+#endif
+	{108, GPIOF_OUT_INIT_LOW,  "*ENET1_EN#" },     // ENET1 TX Enable
+	{109, GPIOF_IN,            "*ENET1_PRES#" },   // ENET1 Detect (0=SFP present)
+	{110, GPIOF_OUT_INIT_LOW,  "*ENET2_EN#" },     // ENET2 TX Enable
+	{111, GPIOF_IN,            "*ENET2_PRES#"},    // ENET2 Detect (0=SFP present)
+	// PCA GPIO
+	{116, GPIOF_OUT_INIT_HIGH, "*USIM2_LOC"},      // USIM2 Select (1=Loc, 0=Rem)
+	{117, GPIOF_IN,            "*USIM2_DET_LOC#" },// USIM2 Detect (Local Slot)
+	{118, GPIOF_IN,            "*USIM2_DET_REM#" },// USIM2 Detect (Remote Slot)
+	{120, GPIOF_OUT_INIT_LOW,  "*USB1_PCI_SEL"},   // USB1  Select (1=PCIe1, 0=J1)
+	{121, GPIOF_OUT_INIT_LOW,  "*USB2_PCI_SEL"},   // USB2  Select (1=PCIe2, 0=J1)
+	{122, GPIOF_IN,            "*USIM1_DET#"},     // USIM1 Detect
+	{127, GPIOF_IN,            "DIO0" },
+	{128, GPIOF_IN,            "DIO1" },
+	{129, GPIOF_IN,            "DIO2" },
+	{130, GPIOF_IN,            "DIO3" },
+	{131, GPIOF_IN,            "DIO4" },
+};
+
+static struct latch_led cambria_latch_leds[] = {
+	{
+		.name	= "ledA",  /* green led */
+		.bit	= 0,
+	},
+	{
+		.name	= "ledB",  /* green led */
+		.bit	= 1,
+	},
+	{
+		.name	= "ledC",  /* green led */
+		.bit	= 2,
+	},
+	{
+		.name	= "ledD",  /* green led */
+		.bit	= 3,
+	},
+	{
+		.name	= "ledE",  /* green led */
+		.bit	= 4,
+	},
+	{
+		.name	= "ledF",  /* green led */
+		.bit	= 5,
+	},
+	{
+		.name	= "ledG",  /* green led */
+		.bit	= 6,
+	},
+	{
+		.name	= "ledH",  /* green led */
+		.bit	= 7,
+	}
+};
+
+static struct latch_led_platform_data cambria_latch_leds_data = {
+	.num_leds	= 8,
+	.leds		= cambria_latch_leds,
+	.mem		= 0x53F40000,
+};
+
+static struct platform_device cambria_latch_leds_device = {
+	.name		= "leds-latch",
+	.id		= -1,
+	.dev.platform_data = &cambria_latch_leds_data,
+};
+
+static struct resource cambria_usb0_resources[] = {
+	{
+		.start	= 0xCD000000,
+		.end	= 0xCD000300,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= 32,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource cambria_usb1_resources[] = {
+	{
+		.start	= 0xCE000000,
+		.end	= 0xCE000300,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= 33,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 ehci_dma_mask = ~(u32)0;
+
+static struct usb_ehci_pdata cambria_usb_pdata = {
+	.big_endian_desc = 1,
+	.big_endian_mmio = 1,
+	.has_tt = 1,
+	.caps_offset = 0x100,
+};
+
+static struct platform_device cambria_usb0_device =  {
+	.name		= "ehci-platform",
+	.id		= 0,
+	.resource	= cambria_usb0_resources,
+	.num_resources	= ARRAY_SIZE(cambria_usb0_resources),
+	.dev = {
+		.dma_mask		= &ehci_dma_mask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data = &cambria_usb_pdata,
+	},
+};
+
+static struct platform_device cambria_usb1_device = {
+	.name		= "ehci-platform",
+	.id		= 1,
+	.resource	= cambria_usb1_resources,
+	.num_resources	= ARRAY_SIZE(cambria_usb1_resources),
+	.dev = {
+		.dma_mask		= &ehci_dma_mask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data = &cambria_usb_pdata,
+	},
+};
+
+static struct gw_i2c_pld_platform_data gw_i2c_pld_data0 = {
+	.gpio_base	= 16,
+	.nr_gpio	= 8,
+};
+
+static struct gw_i2c_pld_platform_data gw_i2c_pld_data1 = {
+	.gpio_base	= 24,
+	.nr_gpio	= 2,
+};
+
+
+static struct gpio_keys_button cambria_gpio_buttons[] = {
+	{
+		.desc		= "user",
+		.type		= EV_KEY,
+		.code		= BTN_0,
+		.debounce_interval = 6,
+		.gpio		= 25,
+	}
+};
+
+static struct gpio_keys_platform_data cambria_gpio_buttons_data = {
+	.poll_interval	= 500,
+	.nbuttons	= 1,
+	.buttons	= cambria_gpio_buttons,
+};
+
+static struct platform_device cambria_gpio_buttons_device = {
+	.name			= "gpio-keys-polled",
+	.id			= -1,
+	.dev.platform_data	= &cambria_gpio_buttons_data,
+};
+
+static struct platform_device *cambria_devices[] __initdata = {
+	&cambria_i2c_gpio,
+	&cambria_flash,
+	&cambria_uart,
+};
+
+static int cambria_register_gpio(struct gpio *array, size_t num)
+{
+	int i, err, ret;
+
+	ret = 0;
+	for (i = 0; i < num; i++, array++) {
+		const char *label = array->label;
+		if (label[0] == '*')
+			label++;
+		err = gpio_request_one(array->gpio, array->flags, label);
+		if (err)
+			ret = err;
+		else {
+			err = gpio_export(array->gpio, array->label[0] != '*');
+		}
+	}
+	return ret;
+}
+
+static void __init cambria_gw23xx_setup(void)
+{
+	cambria_gpio_resources[0].start = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) |\
+																		(1 << 5) | (1 << 8) | (1 << 9) | (1 << 12);
+	cambria_gpio_resources[0].end = cambria_gpio_resources[0].start;
+
+	platform_device_register(&cambria_npec_device);
+	platform_device_register(&cambria_npea_device);
+}
+
+static void __init cambria_gw2350_setup(void)
+{
+	*IXP4XX_EXP_CS2 = 0xBFFF3C43;
+	irq_set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
+	cambria_optional_uart_data[0].mapbase	= 0x52FF0000;
+	cambria_optional_uart_data[0].membase	= (void __iomem *)ioremap(0x52FF0000, 0x0fff);
+	cambria_optional_uart_data[0].irq		= IRQ_IXP4XX_GPIO3;
+
+	*IXP4XX_EXP_CS3 = 0xBFFF3C43;
+	irq_set_irq_type(IRQ_IXP4XX_GPIO4, IRQ_TYPE_EDGE_RISING);
+	cambria_optional_uart_data[1].mapbase	= 0x53FF0000;
+	cambria_optional_uart_data[1].membase	= (void __iomem *)ioremap(0x53FF0000, 0x0fff);
+	cambria_optional_uart_data[1].irq		= IRQ_IXP4XX_GPIO4;
+
+	cambria_gpio_resources[0].start = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) |\
+																		(1 << 5) | (1 << 8) | (1 << 9) | (1 << 12);
+	cambria_gpio_resources[0].end = cambria_gpio_resources[0].start;
+
+	platform_device_register(&cambria_optional_uart);
+	platform_device_register(&cambria_npec_device);
+	platform_device_register(&cambria_npea_device);
+
+	platform_device_register(&cambria_usb0_device);
+	platform_device_register(&cambria_usb1_device);
+
+	platform_device_register(&cambria_gpio_leds_device);
+
+	/* gpio config (/sys/class/gpio) */
+	cambria_register_gpio(ARRAY_AND_SIZE(cambria_gpios_gw2350));
+}
+
+static void __init cambria_gw2358_setup(void)
+{
+	*IXP4XX_EXP_CS3 = 0xBFFF3C43; // bit0 = 16bit vs 8bit bus
+	irq_set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
+	cambria_optional_uart_data[0].mapbase	= 0x53FC0000;
+	cambria_optional_uart_data[0].membase	= (void __iomem *)ioremap(0x53FC0000, 0x0fff);
+	cambria_optional_uart_data[0].irq		= IRQ_IXP4XX_GPIO3;
+
+	irq_set_irq_type(IRQ_IXP4XX_GPIO4, IRQ_TYPE_EDGE_RISING);
+	cambria_optional_uart_data[1].mapbase	= 0x53F80000;
+	cambria_optional_uart_data[1].membase	= (void __iomem *)ioremap(0x53F80000, 0x0fff);
+	cambria_optional_uart_data[1].irq		= IRQ_IXP4XX_GPIO4;
+
+	cambria_gpio_resources[0].start = (1 << 14) | (1 << 16) | (1 << 17) | (1 << 18) |\
+																		(1 << 19) | (1 << 20) | (1 << 24) | (1 << 25);
+	cambria_gpio_resources[0].end = cambria_gpio_resources[0].start;
+
+	platform_device_register(&cambria_optional_uart);
+
+	platform_device_register(&cambria_npec_device);
+	platform_device_register(&cambria_npea_device);
+
+	platform_device_register(&cambria_usb0_device);
+	platform_device_register(&cambria_usb1_device);
+
+	platform_device_register(&cambria_pata);
+
+	cambria_gpio_leds[0].gpio = 24;
+	platform_device_register(&cambria_gpio_leds_device);
+
+	platform_device_register(&cambria_latch_leds_device);
+
+	platform_device_register(&cambria_gpio_buttons_device);
+
+	/* gpio config (/sys/class/gpio) */
+	cambria_register_gpio(ARRAY_AND_SIZE(cambria_gpios_gw2358));
+}
+
+static void __init cambria_gw2359_setup(void)
+{
+#if defined(CONFIG_MVSWITCH_PHY) || defined(CONFIG_MVSWITCH_PHY_MODULE)
+	/* The mvswitch driver has some hard-coded values which could
+	 * easily be turned into a platform resource if needed.  For now they
+	 * match our hardware configuration:
+	 *  MV_BASE    0x10 - phy base address
+	 *  MV_WANPORT 0 - Port0 (ENET2) is WAN (SFP module)
+	 *  MV_CPUPORT 5 - Port5 is CPU NPEA (eth1)
+	 *
+	 * The mvswitch driver registers a fixup which forces a driver match
+	 * if phy_addr matches MV_BASE
+	 *
+	 * Two static defautl VLAN's are created: WAN port in 1, and all other ports
+	 * in the other.
+	 */
+	cambria_npea_data.phy = 0x10; // mvswitch driver catches this
+#else
+	// Switch Port5 to CPU is MII<->MII (no PHY) - this disables the genphy driver
+	cambria_npea_data.phy = IXP4XX_ETH_PHY_MAX_ADDR;
+	// CPU NPE-C is in bridge bypass mode to Port4 PHY@0x14
+	cambria_npec_data.phy = 0x14;
+#endif
+	platform_device_register(&cambria_npec_device);
+	platform_device_register(&cambria_npea_device);
+
+	platform_device_register(&cambria_usb0_device);
+	platform_device_register(&cambria_usb1_device);
+
+	cambria_gpio_leds_data.num_leds = 3;
+	cambria_gpio_leds[0].name = "user1";
+	cambria_gpio_leds[0].gpio = 125; // PNLLED1#
+	cambria_gpio_leds[1].gpio = 126; // PNLLED3#
+	cambria_gpio_leds[2].gpio = 119; // PNLLED4#
+	platform_device_register(&cambria_gpio_leds_device);
+
+#if (IS_ENABLED(CONFIG_KEYBOARD_GPIO_POLLED))
+	cambria_gpio_buttons[0].gpio = 100;
+	platform_device_register(&cambria_gpio_buttons_device);
+#endif
+
+	/* gpio config (/sys/class/gpio) */
+	cambria_register_gpio(ARRAY_AND_SIZE(cambria_gpios_gw2359));
+}
+
+static void __init cambria_gw2360_setup(void)
+{
+	/* The GW2360 has 8 UARTs in addition to the 1 IXP4xxx UART.
+	 * The chip-selects are expanded via a 3-to-8 decoder and CS2
+	 * and they are 8bit devices
+	 */
+	*IXP4XX_EXP_CS2 = 0xBFFF3C43;
+	cambria_optional_uart_data[0].mapbase = 0x52000000;
+	cambria_optional_uart_data[0].membase = (void __iomem *)ioremap(0x52000000, 0x0fff);
+	cambria_optional_uart_data[0].uartclk = 18432000;
+	cambria_optional_uart_data[0].iotype  = UPIO_MEM;
+	cambria_optional_uart_data[0].irq     = IRQ_IXP4XX_GPIO2;
+	irq_set_irq_type(IRQ_IXP4XX_GPIO2, IRQ_TYPE_EDGE_RISING);
+
+	cambria_optional_uart_data[1].mapbase = 0x52000008;
+	cambria_optional_uart_data[1].membase = (void __iomem *)ioremap(0x52000008, 0x0fff);
+	cambria_optional_uart_data[1].uartclk = 18432000;
+	cambria_optional_uart_data[1].iotype  = UPIO_MEM;
+	cambria_optional_uart_data[1].irq     = IRQ_IXP4XX_GPIO3;
+	irq_set_irq_type(IRQ_IXP4XX_GPIO3, IRQ_TYPE_EDGE_RISING);
+
+	cambria_optional_uart_data[2].mapbase = 0x52000010;
+	cambria_optional_uart_data[2].membase = (void __iomem *)ioremap(0x52000010, 0x0fff);
+	cambria_optional_uart_data[2].uartclk = 18432000;
+	cambria_optional_uart_data[2].iotype  = UPIO_MEM;
+	cambria_optional_uart_data[2].irq     = IRQ_IXP4XX_GPIO4;
+	irq_set_irq_type(IRQ_IXP4XX_GPIO4, IRQ_TYPE_EDGE_RISING);
+
+	cambria_optional_uart_data[3].mapbase = 0x52000018;
+	cambria_optional_uart_data[3].membase = (void __iomem *)ioremap(0x52000018, 0x0fff);
+	cambria_optional_uart_data[3].uartclk = 18432000;
+	cambria_optional_uart_data[3].iotype  = UPIO_MEM;
+	cambria_optional_uart_data[3].irq     = IRQ_IXP4XX_GPIO5;
+	irq_set_irq_type(IRQ_IXP4XX_GPIO5, IRQ_TYPE_EDGE_RISING);
+
+	cambria_optional_uart_data[4].mapbase = 0x52000020;
+	cambria_optional_uart_data[4].membase = (void __iomem *)ioremap(0x52000020, 0x0fff);
+	cambria_optional_uart_data[4].uartclk = 18432000;
+	cambria_optional_uart_data[4].iotype  = UPIO_MEM;
+	cambria_optional_uart_data[4].irq     = IRQ_IXP4XX_GPIO8;
+	irq_set_irq_type(IRQ_IXP4XX_GPIO8, IRQ_TYPE_EDGE_RISING);
+
+	cambria_optional_uart_data[5].mapbase = 0x52000028;
+	cambria_optional_uart_data[5].membase = (void __iomem *)ioremap(0x52000028, 0x0fff);
+	cambria_optional_uart_data[5].uartclk = 18432000;
+	cambria_optional_uart_data[5].iotype  = UPIO_MEM;
+	cambria_optional_uart_data[5].irq     = IRQ_IXP4XX_GPIO9;
+	irq_set_irq_type(IRQ_IXP4XX_GPIO9, IRQ_TYPE_EDGE_RISING);
+
+	cambria_optional_uart_data[6].mapbase = 0x52000030;
+	cambria_optional_uart_data[6].membase = (void __iomem *)ioremap(0x52000030, 0x0fff);
+	cambria_optional_uart_data[6].uartclk = 18432000;
+	cambria_optional_uart_data[6].iotype  = UPIO_MEM;
+	cambria_optional_uart_data[6].irq     = IRQ_IXP4XX_GPIO10;
+	irq_set_irq_type(IRQ_IXP4XX_GPIO10, IRQ_TYPE_EDGE_RISING);
+
+	cambria_optional_uart.num_resources   = 7,
+	platform_device_register(&cambria_optional_uart);
+
+#if defined(CONFIG_MVSWITCH_PHY) || defined(CONFIG_MVSWITCH_PHY_MODULE)
+	/* The mvswitch driver has some hard-coded values which could
+	 * easily be turned into a platform resource if needed.  For now they
+	 * match our hardware configuration:
+	 *  MV_BASE    0x10 - phy base address
+	 *  MV_WANPORT 0 - Port0 (ENET2) is WAN (SFP module)
+	 *  MV_CPUPORT 5 - Port5 is CPU NPEA (eth1)
+	 *
+	 * The mvswitch driver registers a fixup which forces a driver match
+	 * if phy_addr matches MV_BASE
+	 *
+	 * Two static defautl VLAN's are created: WAN port in 1, and all other ports
+	 * in the other.
+	 */
+	cambria_npea_data.phy = 0x10; // mvswitch driver catches this
+#else
+	// Switch Port5 to CPU is MII<->MII (no PHY) - this disables the generic PHY driver
+	cambria_npea_data.phy = IXP4XX_ETH_PHY_MAX_ADDR;
+#endif
+
+	// disable genphy autonegotiation on NPE-C PHY (eth1) as its 100BaseFX
+	//cambria_npec_data.noautoneg = 1;   // disable autoneg
+	cambria_npec_data.speed_10 = 0;    // 100mbps
+	cambria_npec_data.half_duplex = 0; // full-duplex
+	platform_device_register(&cambria_npec_device);
+	platform_device_register(&cambria_npea_device);
+
+	platform_device_register(&cambria_usb0_device);
+	platform_device_register(&cambria_usb1_device);
+
+	cambria_gpio_leds_data.num_leds = 3;
+	cambria_gpio_leds[0].name = "user1";
+	cambria_gpio_leds[0].gpio = 125;
+	cambria_gpio_leds[1].gpio = 126;
+	cambria_gpio_leds[2].gpio = 119;
+	platform_device_register(&cambria_gpio_leds_device);
+
+#if (IS_ENABLED(CONFIG_KEYBOARD_GPIO_POLLED))
+	cambria_gpio_buttons[0].gpio = 100;
+	platform_device_register(&cambria_gpio_buttons_device);
+#endif
+
+#ifdef SFP_SERIALID
+	/* the SFP modules each have an i2c bus for serial ident via GSC GPIO
+	 * To use these the i2c-gpio driver must be changed to use the _cansleep
+	 * varients of gpio_get_value/gpio_set_value (I don't know why it doesn't
+	 * use that anyway as it doesn't operate in an IRQ context).
+	 * Additionally the i2c-gpio module must set the gpio to output-high prior
+	 * to changing direction to an input to enable internal Pullups
+	 */
+	platform_device_register(&cambria_i2c_gpio_sfpa);
+	platform_device_register(&cambria_i2c_gpio_sfpb);
+#endif
+
+	/* gpio config (/sys/class/gpio) */
+	cambria_register_gpio(ARRAY_AND_SIZE(cambria_gpios_gw2360));
+}
+
+static struct cambria_board_info cambria_boards[] __initdata = {
+	{
+		.model	= "GW2350",
+		.setup	= cambria_gw2350_setup,
+	}, {
+		.model	= "GW2351",
+		.setup	= cambria_gw2350_setup,
+	}, {
+		.model	= "GW2358",
+		.setup	= cambria_gw2358_setup,
+	}, {
+		.model	= "GW2359",
+		.setup	= cambria_gw2359_setup,
+	}, {
+		.model	= "GW2360",
+		.setup	= cambria_gw2360_setup,
+	}, {
+		.model	= "GW2371",
+		.setup	= cambria_gw2358_setup,
+	}
+};
+
+static struct cambria_board_info * __init cambria_find_board_info(char *model)
+{
+	int i;
+	model[6] = '\0';
+
+	for (i = 0; i < ARRAY_SIZE(cambria_boards); i++) {
+		struct cambria_board_info *info = &cambria_boards[i];
+		if (strcmp(info->model, model) == 0)
+			return info;
+	}
+
+	return NULL;
+}
+
+static struct memory_accessor *at24_mem_acc;
+
+static void at24_setup(struct memory_accessor *mem_acc, void *context)
+{
+	char mac_addr[ETH_ALEN];
+	char model[7];
+
+	at24_mem_acc = mem_acc;
+
+	/* Read MAC addresses */
+	if (at24_mem_acc->read(at24_mem_acc, mac_addr, 0x0, 6) == 6) {
+		memcpy(&cambria_npec_data.hwaddr, mac_addr, ETH_ALEN);
+	}
+	if (at24_mem_acc->read(at24_mem_acc, mac_addr, 0x6, 6) == 6) {
+		memcpy(&cambria_npea_data.hwaddr, mac_addr, ETH_ALEN);
+	}
+
+	/* Read the first 6 bytes of the model number */
+	if (at24_mem_acc->read(at24_mem_acc, model, 0x20, 6) == 6) {
+		cambria_info = cambria_find_board_info(model);
+	}
+
+}
+
+static struct at24_platform_data cambria_eeprom_info = {
+	.byte_len	= 1024,
+	.page_size	= 16,
+	.flags		= AT24_FLAG_READONLY,
+	.setup		= at24_setup,
+};
+
+static struct pca953x_platform_data cambria_pca_data = {
+	.gpio_base = 100,
+	.irq_base = -1,
+};
+
+static struct pca953x_platform_data cambria_pca2_data = {
+	.gpio_base = 116,
+	.irq_base = -1,
+};
+
+static struct i2c_board_info __initdata cambria_i2c_board_info[] = {
+	{
+		I2C_BOARD_INFO("pca9555", 0x23),
+		.platform_data = &cambria_pca_data,
+	},
+	{
+		I2C_BOARD_INFO("pca9555", 0x27),
+		.platform_data = &cambria_pca2_data,
+	},
+	{
+		I2C_BOARD_INFO("ds1672", 0x68),
+	},
+	{
+		I2C_BOARD_INFO("gsp", 0x29),
+	},
+	{
+		I2C_BOARD_INFO("ad7418", 0x28),
+	},
+	{
+		I2C_BOARD_INFO("24c08", 0x51),
+		.platform_data	= &cambria_eeprom_info
+	},
+	{
+		I2C_BOARD_INFO("gw_i2c_pld", 0x56),
+		.platform_data	= &gw_i2c_pld_data0,
+	},
+	{
+		I2C_BOARD_INFO("gw_i2c_pld", 0x57),
+		.platform_data	= &gw_i2c_pld_data1,
+	},
+};
+
+static void __init cambria_init(void)
+{
+	ixp4xx_sys_init();
+
+	cambria_flash_resource.start = IXP4XX_EXP_BUS_BASE(0);
+	cambria_flash_resource.end = IXP4XX_EXP_BUS_BASE(0) + SZ_32M - 1;
+
+	*IXP4XX_EXP_CS0 |= IXP4XX_FLASH_WRITABLE; // make sure window is writable
+	*IXP4XX_EXP_CS1 = *IXP4XX_EXP_CS0;
+
+	platform_add_devices(ARRAY_AND_SIZE(cambria_devices));
+
+	cambria_pata_resources[0].start = 0x53e00000;
+	cambria_pata_resources[0].end = 0x53e3ffff;
+
+	cambria_pata_resources[1].start = 0x53e40000;
+	cambria_pata_resources[1].end = 0x53e7ffff;
+
+	cambria_pata_data.cs0_cfg = IXP4XX_EXP_CS3;
+	cambria_pata_data.cs1_cfg = IXP4XX_EXP_CS3;
+
+	i2c_register_board_info(0, ARRAY_AND_SIZE(cambria_i2c_board_info));
+}
+
+static int __init cambria_model_setup(void)
+{
+	if (!machine_is_cambria())
+		return 0;
+
+	if (cambria_info) {
+		printk(KERN_DEBUG "Running on Gateworks Cambria %s\n",
+				cambria_info->model);
+		cambria_info->setup();
+	} else {
+		printk(KERN_INFO "Unknown/missing Cambria model number"
+				" -- defaults will be used\n");
+		cambria_gw23xx_setup();
+	}
+
+	return 0;
+}
+late_initcall(cambria_model_setup);
+
+MACHINE_START(CAMBRIA, "Gateworks Cambria series")
+	/* Maintainer: Imre Kaloz <kaloz@openwrt.org> */
+	.map_io		= ixp4xx_map_io,
+	.init_irq	= ixp4xx_init_irq,
+	.init_time	= ixp4xx_timer_init,
+	.atag_offset	= 0x0100,
+	.init_machine	= cambria_init,
+#if defined(CONFIG_PCI)
+	.dma_zone_size	= SZ_64M,
+#endif
+	.restart	= ixp4xx_restart,
+MACHINE_END

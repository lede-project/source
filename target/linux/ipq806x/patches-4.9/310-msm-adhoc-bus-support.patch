From: Christian Lamparter <chunkeey@googlemail.com>
Subject: BUS: add MSM_BUS
--- a/drivers/bus/Makefile
+++ b/drivers/bus/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_BRCMSTB_GISB_ARB)	+= brcmst
 obj-$(CONFIG_IMX_WEIM)		+= imx-weim.o
 obj-$(CONFIG_MIPS_CDMM)		+= mips_cdmm.o
 obj-$(CONFIG_MVEBU_MBUS) 	+= mvebu-mbus.o
+obj-$(CONFIG_BUS_TOPOLOGY_ADHOC)+= msm_bus/
 
 # Interconnect bus driver for OMAP SoCs.
 obj-$(CONFIG_OMAP_INTERCONNECT)	+= omap_l3_smx.o omap_l3_noc.o
--- a/drivers/bus/Kconfig
+++ b/drivers/bus/Kconfig
@@ -92,6 +92,8 @@ config MVEBU_MBUS
 	  Driver needed for the MBus configuration on Marvell EBU SoCs
 	  (Kirkwood, Dove, Orion5x, MV78XX0 and Armada 370/XP).
 
+source "drivers/bus/msm_bus/Kconfig"
+
 config OMAP_INTERCONNECT
 	tristate "OMAP INTERCONNECT DRIVER"
 	depends on ARCH_OMAP2PLUS
--- /dev/null
+++ b/include/dt-bindings/msm/msm-bus-ids.h
@@ -0,0 +1,869 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MSM_BUS_IDS_H
+#define __MSM_BUS_IDS_H
+
+/* Topology related enums */
+#define	MSM_BUS_FAB_DEFAULT 0
+#define	MSM_BUS_FAB_APPSS 0
+#define	MSM_BUS_FAB_SYSTEM 1024
+#define	MSM_BUS_FAB_MMSS 2048
+#define	MSM_BUS_FAB_SYSTEM_FPB 3072
+#define	MSM_BUS_FAB_CPSS_FPB 4096
+
+#define	MSM_BUS_FAB_BIMC 0
+#define	MSM_BUS_FAB_SYS_NOC 1024
+#define	MSM_BUS_FAB_MMSS_NOC 2048
+#define	MSM_BUS_FAB_OCMEM_NOC 3072
+#define	MSM_BUS_FAB_PERIPH_NOC 4096
+#define	MSM_BUS_FAB_CONFIG_NOC 5120
+#define	MSM_BUS_FAB_OCMEM_VNOC 6144
+#define	MSM_BUS_FAB_MMSS_AHB 2049
+#define	MSM_BUS_FAB_A0_NOC 6145
+#define	MSM_BUS_FAB_A1_NOC 6146
+#define	MSM_BUS_FAB_A2_NOC 6147
+
+#define	MSM_BUS_MASTER_FIRST 1
+#define	MSM_BUS_MASTER_AMPSS_M0 1
+#define	MSM_BUS_MASTER_AMPSS_M1 2
+#define	MSM_BUS_APPSS_MASTER_FAB_MMSS 3
+#define	MSM_BUS_APPSS_MASTER_FAB_SYSTEM 4
+#define	MSM_BUS_SYSTEM_MASTER_FAB_APPSS 5
+#define	MSM_BUS_MASTER_SPS 6
+#define	MSM_BUS_MASTER_ADM_PORT0 7
+#define	MSM_BUS_MASTER_ADM_PORT1 8
+#define	MSM_BUS_SYSTEM_MASTER_ADM1_PORT0 9
+#define	MSM_BUS_MASTER_ADM1_PORT1 10
+#define	MSM_BUS_MASTER_LPASS_PROC 11
+#define	MSM_BUS_MASTER_MSS_PROCI 12
+#define	MSM_BUS_MASTER_MSS_PROCD 13
+#define	MSM_BUS_MASTER_MSS_MDM_PORT0 14
+#define	MSM_BUS_MASTER_LPASS 15
+#define	MSM_BUS_SYSTEM_MASTER_CPSS_FPB 16
+#define	MSM_BUS_SYSTEM_MASTER_SYSTEM_FPB 17
+#define	MSM_BUS_SYSTEM_MASTER_MMSS_FPB 18
+#define	MSM_BUS_MASTER_ADM1_CI 19
+#define	MSM_BUS_MASTER_ADM0_CI 20
+#define	MSM_BUS_MASTER_MSS_MDM_PORT1 21
+#define	MSM_BUS_MASTER_MDP_PORT0 22
+#define	MSM_BUS_MASTER_MDP_PORT1 23
+#define	MSM_BUS_MMSS_MASTER_ADM1_PORT0 24
+#define	MSM_BUS_MASTER_ROTATOR 25
+#define	MSM_BUS_MASTER_GRAPHICS_3D 26
+#define	MSM_BUS_MASTER_JPEG_DEC 27
+#define	MSM_BUS_MASTER_GRAPHICS_2D_CORE0 28
+#define	MSM_BUS_MASTER_VFE 29
+#define	MSM_BUS_MASTER_VPE 30
+#define	MSM_BUS_MASTER_JPEG_ENC 31
+#define	MSM_BUS_MASTER_GRAPHICS_2D_CORE1 32
+#define	MSM_BUS_MMSS_MASTER_APPS_FAB 33
+#define	MSM_BUS_MASTER_HD_CODEC_PORT0 34
+#define	MSM_BUS_MASTER_HD_CODEC_PORT1 35
+#define	MSM_BUS_MASTER_SPDM 36
+#define	MSM_BUS_MASTER_RPM 37
+#define	MSM_BUS_MASTER_MSS 38
+#define	MSM_BUS_MASTER_RIVA 39
+#define	MSM_BUS_MASTER_SNOC_VMEM 40
+#define	MSM_BUS_MASTER_MSS_SW_PROC 41
+#define	MSM_BUS_MASTER_MSS_FW_PROC 42
+#define	MSM_BUS_MASTER_HMSS 43
+#define	MSM_BUS_MASTER_GSS_NAV 44
+#define	MSM_BUS_MASTER_PCIE 45
+#define	MSM_BUS_MASTER_SATA 46
+#define	MSM_BUS_MASTER_CRYPTO 47
+#define	MSM_BUS_MASTER_VIDEO_CAP 48
+#define	MSM_BUS_MASTER_GRAPHICS_3D_PORT1 49
+#define	MSM_BUS_MASTER_VIDEO_ENC 50
+#define	MSM_BUS_MASTER_VIDEO_DEC 51
+#define	MSM_BUS_MASTER_LPASS_AHB 52
+#define	MSM_BUS_MASTER_QDSS_BAM 53
+#define	MSM_BUS_MASTER_SNOC_CFG 54
+#define	MSM_BUS_MASTER_CRYPTO_CORE0 55
+#define	MSM_BUS_MASTER_CRYPTO_CORE1 56
+#define	MSM_BUS_MASTER_MSS_NAV 57
+#define	MSM_BUS_MASTER_OCMEM_DMA 58
+#define	MSM_BUS_MASTER_WCSS 59
+#define	MSM_BUS_MASTER_QDSS_ETR 60
+#define	MSM_BUS_MASTER_USB3 61
+#define	MSM_BUS_MASTER_JPEG 62
+#define	MSM_BUS_MASTER_VIDEO_P0 63
+#define	MSM_BUS_MASTER_VIDEO_P1 64
+#define	MSM_BUS_MASTER_MSS_PROC 65
+#define	MSM_BUS_MASTER_JPEG_OCMEM 66
+#define	MSM_BUS_MASTER_MDP_OCMEM 67
+#define	MSM_BUS_MASTER_VIDEO_P0_OCMEM 68
+#define	MSM_BUS_MASTER_VIDEO_P1_OCMEM 69
+#define	MSM_BUS_MASTER_VFE_OCMEM 70
+#define	MSM_BUS_MASTER_CNOC_ONOC_CFG 71
+#define	MSM_BUS_MASTER_RPM_INST 72
+#define	MSM_BUS_MASTER_RPM_DATA 73
+#define	MSM_BUS_MASTER_RPM_SYS 74
+#define	MSM_BUS_MASTER_DEHR 75
+#define	MSM_BUS_MASTER_QDSS_DAP 76
+#define	MSM_BUS_MASTER_TIC 77
+#define	MSM_BUS_MASTER_SDCC_1 78
+#define	MSM_BUS_MASTER_SDCC_3 79
+#define	MSM_BUS_MASTER_SDCC_4 80
+#define	MSM_BUS_MASTER_SDCC_2 81
+#define	MSM_BUS_MASTER_TSIF 82
+#define	MSM_BUS_MASTER_BAM_DMA 83
+#define	MSM_BUS_MASTER_BLSP_2 84
+#define	MSM_BUS_MASTER_USB_HSIC 85
+#define	MSM_BUS_MASTER_BLSP_1 86
+#define	MSM_BUS_MASTER_USB_HS 87
+#define	MSM_BUS_MASTER_PNOC_CFG 88
+#define	MSM_BUS_MASTER_V_OCMEM_GFX3D 89
+#define	MSM_BUS_MASTER_IPA 90
+#define	MSM_BUS_MASTER_QPIC 91
+#define	MSM_BUS_MASTER_MDPE 92
+#define	MSM_BUS_MASTER_USB_HS2 93
+#define	MSM_BUS_MASTER_VPU 94
+#define	MSM_BUS_MASTER_UFS 95
+#define	MSM_BUS_MASTER_BCAST 96
+#define	MSM_BUS_MASTER_CRYPTO_CORE2 97
+#define	MSM_BUS_MASTER_EMAC 98
+#define	MSM_BUS_MASTER_VPU_1 99
+#define	MSM_BUS_MASTER_PCIE_1 100
+#define	MSM_BUS_MASTER_USB3_1 101
+#define	MSM_BUS_MASTER_CNOC_MNOC_MMSS_CFG 102
+#define	MSM_BUS_MASTER_CNOC_MNOC_CFG 103
+#define	MSM_BUS_MASTER_TCU_0 104
+#define	MSM_BUS_MASTER_TCU_1 105
+#define	MSM_BUS_MASTER_CPP 106
+#define	MSM_BUS_MASTER_AUDIO 107
+#define	MSM_BUS_MASTER_PCIE_2 108
+#define	MSM_BUS_MASTER_BLSP_BAM 109
+#define	MSM_BUS_MASTER_USB2_BAM 110
+#define	MSM_BUS_MASTER_ADDS_DMA0 111
+#define	MSM_BUS_MASTER_ADDS_DMA1 112
+#define	MSM_BUS_MASTER_ADDS_DMA2 113
+#define	MSM_BUS_MASTER_ADDS_DMA3 114
+#define	MSM_BUS_MASTER_QPIC_BAM 115
+#define	MSM_BUS_MASTER_SDCC_BAM 116
+#define	MSM_BUS_MASTER_DDRC_SNOC 117
+#define	MSM_BUS_MASTER_WSS_0  118
+#define	MSM_BUS_MASTER_WSS_1  119
+#define	MSM_BUS_MASTER_ESS 120
+#define	MSM_BUS_MASTER_QDSS_BAMNDP 121
+#define	MSM_BUS_MASTER_QDSS_SNOC_CFG 122
+#define	MSM_BUS_MASTER_LAST 130
+
+#define	MSM_BUS_SYSTEM_FPB_MASTER_SYSTEM MSM_BUS_SYSTEM_MASTER_SYSTEM_FPB
+#define	MSM_BUS_CPSS_FPB_MASTER_SYSTEM MSM_BUS_SYSTEM_MASTER_CPSS_FPB
+
+#define	MSM_BUS_SNOC_MM_INT_0 10000
+#define	MSM_BUS_SNOC_MM_INT_1 10001
+#define	MSM_BUS_SNOC_MM_INT_2 10002
+#define	MSM_BUS_SNOC_MM_INT_BIMC 10003
+#define	MSM_BUS_SNOC_INT_0 10004
+#define	MSM_BUS_SNOC_INT_1 10005
+#define	MSM_BUS_SNOC_INT_BIMC 10006
+#define	MSM_BUS_SNOC_BIMC_0_MAS 10007
+#define	MSM_BUS_SNOC_BIMC_1_MAS 10008
+#define	MSM_BUS_SNOC_QDSS_INT 10009
+#define	MSM_BUS_PNOC_SNOC_MAS 10010
+#define	MSM_BUS_PNOC_SNOC_SLV 10011
+#define	MSM_BUS_PNOC_INT_0 10012
+#define	MSM_BUS_PNOC_INT_1 10013
+#define	MSM_BUS_PNOC_M_0 10014
+#define	MSM_BUS_PNOC_M_1 10015
+#define	MSM_BUS_BIMC_SNOC_MAS 10016
+#define	MSM_BUS_BIMC_SNOC_SLV 10017
+#define	MSM_BUS_PNOC_SLV_0 10018
+#define	MSM_BUS_PNOC_SLV_1 10019
+#define	MSM_BUS_PNOC_SLV_2 10020
+#define	MSM_BUS_PNOC_SLV_3 10021
+#define	MSM_BUS_PNOC_SLV_4 10022
+#define	MSM_BUS_PNOC_SLV_8 10023
+#define	MSM_BUS_PNOC_SLV_9 10024
+#define	MSM_BUS_SNOC_BIMC_0_SLV 10025
+#define	MSM_BUS_SNOC_BIMC_1_SLV 10026
+#define	MSM_BUS_MNOC_BIMC_MAS 10027
+#define	MSM_BUS_MNOC_BIMC_SLV 10028
+#define	MSM_BUS_BIMC_MNOC_MAS 10029
+#define	MSM_BUS_BIMC_MNOC_SLV 10030
+#define	MSM_BUS_SNOC_BIMC_MAS 10031
+#define	MSM_BUS_SNOC_BIMC_SLV 10032
+#define	MSM_BUS_CNOC_SNOC_MAS 10033
+#define	MSM_BUS_CNOC_SNOC_SLV 10034
+#define	MSM_BUS_SNOC_CNOC_MAS 10035
+#define	MSM_BUS_SNOC_CNOC_SLV 10036
+#define	MSM_BUS_OVNOC_SNOC_MAS 10037
+#define	MSM_BUS_OVNOC_SNOC_SLV 10038
+#define	MSM_BUS_SNOC_OVNOC_MAS 10039
+#define	MSM_BUS_SNOC_OVNOC_SLV 10040
+#define	MSM_BUS_SNOC_PNOC_MAS 10041
+#define	MSM_BUS_SNOC_PNOC_SLV 10042
+#define	MSM_BUS_BIMC_INT_APPS_EBI 10043
+#define	MSM_BUS_BIMC_INT_APPS_SNOC 10044
+#define	MSM_BUS_SNOC_BIMC_2_MAS 10045
+#define	MSM_BUS_SNOC_BIMC_2_SLV 10046
+#define	MSM_BUS_PNOC_SLV_5 10047
+#define	MSM_BUS_PNOC_SLV_6 10048
+#define	MSM_BUS_PNOC_INT_2 10049
+#define	MSM_BUS_PNOC_INT_3 10050
+#define	MSM_BUS_PNOC_INT_4 10051
+#define	MSM_BUS_PNOC_INT_5 10052
+#define	MSM_BUS_PNOC_INT_6 10053
+#define	MSM_BUS_PNOC_INT_7 10054
+#define	MSM_BUS_BIMC_SNOC_1_MAS 10055
+#define	MSM_BUS_BIMC_SNOC_1_SLV 10056
+#define	MSM_BUS_PNOC_A1NOC_MAS 10057
+#define	MSM_BUS_PNOC_A1NOC_SLV 10058
+#define	MSM_BUS_CNOC_A1NOC_MAS 10059
+#define	MSM_BUS_A0NOC_SNOC_MAS 10060
+#define	MSM_BUS_A0NOC_SNOC_SLV 10061
+#define	MSM_BUS_A1NOC_SNOC_SLV 10062
+#define	MSM_BUS_A1NOC_SNOC_MAS 10063
+#define	MSM_BUS_A2NOC_SNOC_MAS 10064
+#define	MSM_BUS_A2NOC_SNOC_SLV 10065
+#define	MSM_BUS_PNOC_SLV_7 10066
+#define	MSM_BUS_INT_LAST 10067
+
+#define	MSM_BUS_SLAVE_FIRST 512
+#define	MSM_BUS_SLAVE_EBI_CH0 512
+#define	MSM_BUS_SLAVE_EBI_CH1 513
+#define	MSM_BUS_SLAVE_AMPSS_L2 514
+#define	MSM_BUS_APPSS_SLAVE_FAB_MMSS 515
+#define	MSM_BUS_APPSS_SLAVE_FAB_SYSTEM 516
+#define	MSM_BUS_SYSTEM_SLAVE_FAB_APPS 517
+#define	MSM_BUS_SLAVE_SPS 518
+#define	MSM_BUS_SLAVE_SYSTEM_IMEM 519
+#define	MSM_BUS_SLAVE_AMPSS 520
+#define	MSM_BUS_SLAVE_MSS 521
+#define	MSM_BUS_SLAVE_LPASS 522
+#define	MSM_BUS_SYSTEM_SLAVE_CPSS_FPB 523
+#define	MSM_BUS_SYSTEM_SLAVE_SYSTEM_FPB 524
+#define	MSM_BUS_SYSTEM_SLAVE_MMSS_FPB 525
+#define	MSM_BUS_SLAVE_CORESIGHT 526
+#define	MSM_BUS_SLAVE_RIVA 527
+#define	MSM_BUS_SLAVE_SMI 528
+#define	MSM_BUS_MMSS_SLAVE_FAB_APPS 529
+#define	MSM_BUS_MMSS_SLAVE_FAB_APPS_1 530
+#define	MSM_BUS_SLAVE_MM_IMEM 531
+#define	MSM_BUS_SLAVE_CRYPTO 532
+#define	MSM_BUS_SLAVE_SPDM 533
+#define	MSM_BUS_SLAVE_RPM 534
+#define	MSM_BUS_SLAVE_RPM_MSG_RAM 535
+#define	MSM_BUS_SLAVE_MPM 536
+#define	MSM_BUS_SLAVE_PMIC1_SSBI1_A 537
+#define	MSM_BUS_SLAVE_PMIC1_SSBI1_B 538
+#define	MSM_BUS_SLAVE_PMIC1_SSBI1_C 539
+#define	MSM_BUS_SLAVE_PMIC2_SSBI2_A 540
+#define	MSM_BUS_SLAVE_PMIC2_SSBI2_B 541
+#define	MSM_BUS_SLAVE_GSBI1_UART 542
+#define	MSM_BUS_SLAVE_GSBI2_UART 543
+#define	MSM_BUS_SLAVE_GSBI3_UART 544
+#define	MSM_BUS_SLAVE_GSBI4_UART 545
+#define	MSM_BUS_SLAVE_GSBI5_UART 546
+#define	MSM_BUS_SLAVE_GSBI6_UART 547
+#define	MSM_BUS_SLAVE_GSBI7_UART 548
+#define	MSM_BUS_SLAVE_GSBI8_UART 549
+#define	MSM_BUS_SLAVE_GSBI9_UART 550
+#define	MSM_BUS_SLAVE_GSBI10_UART 551
+#define	MSM_BUS_SLAVE_GSBI11_UART 552
+#define	MSM_BUS_SLAVE_GSBI12_UART 553
+#define	MSM_BUS_SLAVE_GSBI1_QUP 554
+#define	MSM_BUS_SLAVE_GSBI2_QUP 555
+#define	MSM_BUS_SLAVE_GSBI3_QUP 556
+#define	MSM_BUS_SLAVE_GSBI4_QUP 557
+#define	MSM_BUS_SLAVE_GSBI5_QUP 558
+#define	MSM_BUS_SLAVE_GSBI6_QUP 559
+#define	MSM_BUS_SLAVE_GSBI7_QUP 560
+#define	MSM_BUS_SLAVE_GSBI8_QUP 561
+#define	MSM_BUS_SLAVE_GSBI9_QUP 562
+#define	MSM_BUS_SLAVE_GSBI10_QUP 563
+#define	MSM_BUS_SLAVE_GSBI11_QUP 564
+#define	MSM_BUS_SLAVE_GSBI12_QUP 565
+#define	MSM_BUS_SLAVE_EBI2_NAND 566
+#define	MSM_BUS_SLAVE_EBI2_CS0 567
+#define	MSM_BUS_SLAVE_EBI2_CS1 568
+#define	MSM_BUS_SLAVE_EBI2_CS2 569
+#define	MSM_BUS_SLAVE_EBI2_CS3 570
+#define	MSM_BUS_SLAVE_EBI2_CS4 571
+#define	MSM_BUS_SLAVE_EBI2_CS5 572
+#define	MSM_BUS_SLAVE_USB_FS1 573
+#define	MSM_BUS_SLAVE_USB_FS2 574
+#define	MSM_BUS_SLAVE_TSIF 575
+#define	MSM_BUS_SLAVE_MSM_TSSC 576
+#define	MSM_BUS_SLAVE_MSM_PDM 577
+#define	MSM_BUS_SLAVE_MSM_DIMEM 578
+#define	MSM_BUS_SLAVE_MSM_TCSR 579
+#define	MSM_BUS_SLAVE_MSM_PRNG 580
+#define	MSM_BUS_SLAVE_GSS 581
+#define	MSM_BUS_SLAVE_SATA 582
+#define	MSM_BUS_SLAVE_USB3 583
+#define	MSM_BUS_SLAVE_WCSS 584
+#define	MSM_BUS_SLAVE_OCIMEM 585
+#define	MSM_BUS_SLAVE_SNOC_OCMEM 586
+#define	MSM_BUS_SLAVE_SERVICE_SNOC 587
+#define	MSM_BUS_SLAVE_QDSS_STM 588
+#define	MSM_BUS_SLAVE_CAMERA_CFG 589
+#define	MSM_BUS_SLAVE_DISPLAY_CFG 590
+#define	MSM_BUS_SLAVE_OCMEM_CFG 591
+#define	MSM_BUS_SLAVE_CPR_CFG 592
+#define	MSM_BUS_SLAVE_CPR_XPU_CFG 593
+#define	MSM_BUS_SLAVE_MISC_CFG 594
+#define	MSM_BUS_SLAVE_MISC_XPU_CFG 595
+#define	MSM_BUS_SLAVE_VENUS_CFG 596
+#define	MSM_BUS_SLAVE_MISC_VENUS_CFG 597
+#define	MSM_BUS_SLAVE_GRAPHICS_3D_CFG 598
+#define	MSM_BUS_SLAVE_MMSS_CLK_CFG 599
+#define	MSM_BUS_SLAVE_MMSS_CLK_XPU_CFG 600
+#define	MSM_BUS_SLAVE_MNOC_MPU_CFG 601
+#define	MSM_BUS_SLAVE_ONOC_MPU_CFG 602
+#define	MSM_BUS_SLAVE_SERVICE_MNOC 603
+#define	MSM_BUS_SLAVE_OCMEM 604
+#define	MSM_BUS_SLAVE_SERVICE_ONOC 605
+#define	MSM_BUS_SLAVE_SDCC_1 606
+#define	MSM_BUS_SLAVE_SDCC_3 607
+#define	MSM_BUS_SLAVE_SDCC_2 608
+#define	MSM_BUS_SLAVE_SDCC_4 609
+#define	MSM_BUS_SLAVE_BAM_DMA 610
+#define	MSM_BUS_SLAVE_BLSP_2 611
+#define	MSM_BUS_SLAVE_USB_HSIC 612
+#define	MSM_BUS_SLAVE_BLSP_1 613
+#define	MSM_BUS_SLAVE_USB_HS 614
+#define	MSM_BUS_SLAVE_PDM 615
+#define	MSM_BUS_SLAVE_PERIPH_APU_CFG 616
+#define	MSM_BUS_SLAVE_PNOC_MPU_CFG 617
+#define	MSM_BUS_SLAVE_PRNG 618
+#define	MSM_BUS_SLAVE_SERVICE_PNOC 619
+#define	MSM_BUS_SLAVE_CLK_CTL 620
+#define	MSM_BUS_SLAVE_CNOC_MSS 621
+#define	MSM_BUS_SLAVE_SECURITY 622
+#define	MSM_BUS_SLAVE_TCSR 623
+#define	MSM_BUS_SLAVE_TLMM 624
+#define	MSM_BUS_SLAVE_CRYPTO_0_CFG 625
+#define	MSM_BUS_SLAVE_CRYPTO_1_CFG 626
+#define	MSM_BUS_SLAVE_IMEM_CFG 627
+#define	MSM_BUS_SLAVE_MESSAGE_RAM 628
+#define	MSM_BUS_SLAVE_BIMC_CFG 629
+#define	MSM_BUS_SLAVE_BOOT_ROM 630
+#define	MSM_BUS_SLAVE_CNOC_MNOC_MMSS_CFG 631
+#define	MSM_BUS_SLAVE_PMIC_ARB 632
+#define	MSM_BUS_SLAVE_SPDM_WRAPPER 633
+#define	MSM_BUS_SLAVE_DEHR_CFG 634
+#define	MSM_BUS_SLAVE_QDSS_CFG 635
+#define	MSM_BUS_SLAVE_RBCPR_CFG 636
+#define	MSM_BUS_SLAVE_RBCPR_QDSS_APU_CFG 637
+#define	MSM_BUS_SLAVE_SNOC_MPU_CFG 638
+#define	MSM_BUS_SLAVE_CNOC_ONOC_CFG 639
+#define	MSM_BUS_SLAVE_CNOC_MNOC_CFG 640
+#define	MSM_BUS_SLAVE_PNOC_CFG 641
+#define	MSM_BUS_SLAVE_SNOC_CFG 642
+#define	MSM_BUS_SLAVE_EBI1_DLL_CFG 643
+#define	MSM_BUS_SLAVE_PHY_APU_CFG 644
+#define	MSM_BUS_SLAVE_EBI1_PHY_CFG 645
+#define	MSM_BUS_SLAVE_SERVICE_CNOC 646
+#define	MSM_BUS_SLAVE_IPS_CFG 647
+#define	MSM_BUS_SLAVE_QPIC 648
+#define	MSM_BUS_SLAVE_DSI_CFG 649
+#define	MSM_BUS_SLAVE_UFS_CFG 650
+#define	MSM_BUS_SLAVE_RBCPR_CX_CFG 651
+#define	MSM_BUS_SLAVE_RBCPR_MX_CFG 652
+#define	MSM_BUS_SLAVE_PCIE_CFG 653
+#define	MSM_BUS_SLAVE_USB_PHYS_CFG 654
+#define	MSM_BUS_SLAVE_VIDEO_CAP_CFG 655
+#define	MSM_BUS_SLAVE_AVSYNC_CFG 656
+#define	MSM_BUS_SLAVE_CRYPTO_2_CFG 657
+#define	MSM_BUS_SLAVE_VPU_CFG 658
+#define	MSM_BUS_SLAVE_BCAST_CFG 659
+#define	MSM_BUS_SLAVE_KLM_CFG 660
+#define	MSM_BUS_SLAVE_GENI_IR_CFG 661
+#define	MSM_BUS_SLAVE_OCMEM_GFX 662
+#define	MSM_BUS_SLAVE_CATS_128 663
+#define	MSM_BUS_SLAVE_OCMEM_64 664
+#define MSM_BUS_SLAVE_PCIE_0 665
+#define MSM_BUS_SLAVE_PCIE_1 666
+#define	MSM_BUS_SLAVE_PCIE_0_CFG 667
+#define	MSM_BUS_SLAVE_PCIE_1_CFG 668
+#define	MSM_BUS_SLAVE_SRVC_MNOC 669
+#define	MSM_BUS_SLAVE_USB_HS2 670
+#define	MSM_BUS_SLAVE_AUDIO	671
+#define	MSM_BUS_SLAVE_TCU	672
+#define	MSM_BUS_SLAVE_APPSS	673
+#define	MSM_BUS_SLAVE_PCIE_PARF	674
+#define	MSM_BUS_SLAVE_USB3_PHY_CFG	675
+#define	MSM_BUS_SLAVE_IPA_CFG	676
+#define	MSM_BUS_SLAVE_A0NOC_SNOC 677
+#define	MSM_BUS_SLAVE_A1NOC_SNOC 678
+#define	MSM_BUS_SLAVE_A2NOC_SNOC 679
+#define	MSM_BUS_SLAVE_HMSS_L3 680
+#define	MSM_BUS_SLAVE_PIMEM_CFG 681
+#define	MSM_BUS_SLAVE_DCC_CFG 682
+#define	MSM_BUS_SLAVE_QDSS_RBCPR_APU_CFG 683
+#define	MSM_BUS_SLAVE_PCIE_2_CFG 684
+#define	MSM_BUS_SLAVE_PCIE20_AHB2PHY 685
+#define	MSM_BUS_SLAVE_A0NOC_CFG 686
+#define	MSM_BUS_SLAVE_A1NOC_CFG 687
+#define	MSM_BUS_SLAVE_A2NOC_CFG 688
+#define	MSM_BUS_SLAVE_A1NOC_MPU_CFG 689
+#define	MSM_BUS_SLAVE_A2NOC_MPU_CFG 690
+#define	MSM_BUS_SLAVE_A0NOC_SMMU_CFG 691
+#define	MSM_BUS_SLAVE_A1NOC_SMMU_CFG 692
+#define	MSM_BUS_SLAVE_A2NOC_SMMU_CFG 693
+#define	MSM_BUS_SLAVE_LPASS_SMMU_CFG 694
+#define	MSM_BUS_SLAVE_MMAGIC_CFG 695
+#define	MSM_BUS_SLAVE_VENUS_THROTTLE_CFG 696
+#define	MSM_BUS_SLAVE_SSC_CFG 697
+#define	MSM_BUS_SLAVE_DSA_CFG 698
+#define	MSM_BUS_SLAVE_DSA_MPU_CFG 699
+#define	MSM_BUS_SLAVE_DISPLAY_THROTTLE_CFG 700
+#define	MSM_BUS_SLAVE_SMMU_CPP_CFG 701
+#define	MSM_BUS_SLAVE_SMMU_JPEG_CFG 702
+#define	MSM_BUS_SLAVE_SMMU_MDP_CFG 703
+#define	MSM_BUS_SLAVE_SMMU_ROTATOR_CFG 704
+#define	MSM_BUS_SLAVE_SMMU_VENUS_CFG 705
+#define	MSM_BUS_SLAVE_SMMU_VFE_CFG 706
+#define	MSM_BUS_SLAVE_A0NOC_MPU_CFG 707
+#define	MSM_BUS_SLAVE_VMEM_CFG 708
+#define	MSM_BUS_SLAVE_CAMERA_THROTTLE_CFG 700
+#define	MSM_BUS_SLAVE_VMEM 709
+#define	MSM_BUS_SLAVE_AHB2PHY 710
+#define	MSM_BUS_SLAVE_PIMEM 711
+#define	MSM_BUS_SLAVE_SNOC_VMEM 712
+#define	MSM_BUS_SLAVE_PCIE_2 713
+#define	MSM_BUS_SLAVE_RBCPR_MX 714
+#define	MSM_BUS_SLAVE_RBCPR_CX 715
+#define	MSM_BUS_SLAVE_PRNG_APU_CFG 716
+#define	MSM_BUS_SLAVE_PERIPH_MPU_CFG 717
+#define	MSM_BUS_SLAVE_GCNT 718
+#define	MSM_BUS_SLAVE_ADSS_CFG 719
+#define	MSM_BUS_SLAVE_ADSS_VMIDMT_CFG 720
+#define	MSM_BUS_SLAVE_QHSS_APU_CFG 721
+#define	MSM_BUS_SLAVE_MDIO 722
+#define	MSM_BUS_SLAVE_FEPHY_CFG 723
+#define	MSM_BUS_SLAVE_SRIF 724
+#define	MSM_BUS_SLAVE_LAST 730
+#define	MSM_BUS_SLAVE_DDRC_CFG 731
+#define	MSM_BUS_SLAVE_DDRC_APU_CFG 732
+#define	MSM_BUS_SLAVE_MPU0_CFG 733
+#define	MSM_BUS_SLAVE_MPU1_CFG 734
+#define	MSM_BUS_SLAVE_MPU2_CFG 734
+#define	MSM_BUS_SLAVE_ESS_VMIDMT_CFG 735
+#define	MSM_BUS_SLAVE_ESS_APU_CFG 736
+#define	MSM_BUS_SLAVE_USB2_CFG 737
+#define	MSM_BUS_SLAVE_BLSP_CFG 738
+#define	MSM_BUS_SLAVE_QPIC_CFG 739
+#define	MSM_BUS_SLAVE_SDCC_CFG 740
+#define	MSM_BUS_SLAVE_WSS0_VMIDMT_CFG 741
+#define	MSM_BUS_SLAVE_WSS0_APU_CFG 742
+#define	MSM_BUS_SLAVE_WSS1_VMIDMT_CFG 743
+#define	MSM_BUS_SLAVE_WSS1_APU_CFG 744
+#define	MSM_BUS_SLAVE_SRVC_PCNOC 745
+#define	MSM_BUS_SLAVE_SNOC_DDRC 746
+#define	MSM_BUS_SLAVE_A7SS 747
+#define	MSM_BUS_SLAVE_WSS0_CFG 748
+#define	MSM_BUS_SLAVE_WSS1_CFG 749
+#define	MSM_BUS_SLAVE_PCIE 750
+#define	MSM_BUS_SLAVE_USB3_CFG 751
+#define	MSM_BUS_SLAVE_CRYPTO_CFG 752
+#define	MSM_BUS_SLAVE_ESS_CFG 753
+#define	MSM_BUS_SLAVE_SRVC_SNOC 754
+
+#define	MSM_BUS_SYSTEM_FPB_SLAVE_SYSTEM  MSM_BUS_SYSTEM_SLAVE_SYSTEM_FPB
+#define MSM_BUS_CPSS_FPB_SLAVE_SYSTEM MSM_BUS_SYSTEM_SLAVE_CPSS_FPB
+
+/*
+ * ID's used in RPM messages
+ */
+#define ICBID_MASTER_APPSS_PROC 0
+#define ICBID_MASTER_MSS_PROC 1
+#define ICBID_MASTER_MNOC_BIMC 2
+#define ICBID_MASTER_SNOC_BIMC 3
+#define ICBID_MASTER_SNOC_BIMC_0 ICBID_MASTER_SNOC_BIMC
+#define ICBID_MASTER_CNOC_MNOC_MMSS_CFG 4
+#define ICBID_MASTER_CNOC_MNOC_CFG 5
+#define ICBID_MASTER_GFX3D 6
+#define ICBID_MASTER_JPEG 7
+#define ICBID_MASTER_MDP 8
+#define ICBID_MASTER_MDP0 ICBID_MASTER_MDP
+#define ICBID_MASTER_MDPS ICBID_MASTER_MDP
+#define ICBID_MASTER_VIDEO 9
+#define ICBID_MASTER_VIDEO_P0 ICBID_MASTER_VIDEO
+#define ICBID_MASTER_VIDEO_P1 10
+#define ICBID_MASTER_VFE 11
+#define ICBID_MASTER_CNOC_ONOC_CFG 12
+#define ICBID_MASTER_JPEG_OCMEM 13
+#define ICBID_MASTER_MDP_OCMEM 14
+#define ICBID_MASTER_VIDEO_P0_OCMEM 15
+#define ICBID_MASTER_VIDEO_P1_OCMEM 16
+#define ICBID_MASTER_VFE_OCMEM 17
+#define ICBID_MASTER_LPASS_AHB 18
+#define ICBID_MASTER_QDSS_BAM 19
+#define ICBID_MASTER_SNOC_CFG 20
+#define ICBID_MASTER_BIMC_SNOC 21
+#define ICBID_MASTER_CNOC_SNOC 22
+#define ICBID_MASTER_CRYPTO 23
+#define ICBID_MASTER_CRYPTO_CORE0 ICBID_MASTER_CRYPTO
+#define ICBID_MASTER_CRYPTO_CORE1 24
+#define ICBID_MASTER_LPASS_PROC 25
+#define ICBID_MASTER_MSS 26
+#define ICBID_MASTER_MSS_NAV 27
+#define ICBID_MASTER_OCMEM_DMA 28
+#define ICBID_MASTER_PNOC_SNOC 29
+#define ICBID_MASTER_WCSS 30
+#define ICBID_MASTER_QDSS_ETR 31
+#define ICBID_MASTER_USB3 32
+#define ICBID_MASTER_USB3_0 ICBID_MASTER_USB3
+#define ICBID_MASTER_SDCC_1 33
+#define ICBID_MASTER_SDCC_3 34
+#define ICBID_MASTER_SDCC_2 35
+#define ICBID_MASTER_SDCC_4 36
+#define ICBID_MASTER_TSIF 37
+#define ICBID_MASTER_BAM_DMA 38
+#define ICBID_MASTER_BLSP_2 39
+#define ICBID_MASTER_USB_HSIC 40
+#define ICBID_MASTER_BLSP_1 41
+#define ICBID_MASTER_USB_HS 42
+#define ICBID_MASTER_USB_HS1 ICBID_MASTER_USB_HS
+#define ICBID_MASTER_PNOC_CFG 43
+#define ICBID_MASTER_SNOC_PNOC 44
+#define ICBID_MASTER_RPM_INST 45
+#define ICBID_MASTER_RPM_DATA 46
+#define ICBID_MASTER_RPM_SYS 47
+#define ICBID_MASTER_DEHR 48
+#define ICBID_MASTER_QDSS_DAP 49
+#define ICBID_MASTER_SPDM 50
+#define ICBID_MASTER_TIC 51
+#define ICBID_MASTER_SNOC_CNOC 52
+#define ICBID_MASTER_GFX3D_OCMEM 53
+#define ICBID_MASTER_GFX3D_GMEM ICBID_MASTER_GFX3D_OCMEM
+#define ICBID_MASTER_OVIRT_SNOC 54
+#define ICBID_MASTER_SNOC_OVIRT 55
+#define ICBID_MASTER_SNOC_GVIRT ICBID_MASTER_SNOC_OVIRT
+#define ICBID_MASTER_ONOC_OVIRT 56
+#define ICBID_MASTER_USB_HS2 57
+#define ICBID_MASTER_QPIC 58
+#define ICBID_MASTER_IPA 59
+#define ICBID_MASTER_DSI 60
+#define ICBID_MASTER_MDP1 61
+#define ICBID_MASTER_MDPE ICBID_MASTER_MDP1
+#define ICBID_MASTER_VPU_PROC 62
+#define ICBID_MASTER_VPU 63
+#define ICBID_MASTER_VPU0 ICBID_MASTER_VPU
+#define ICBID_MASTER_CRYPTO_CORE2 64
+#define ICBID_MASTER_PCIE_0 65
+#define ICBID_MASTER_PCIE_1 66
+#define ICBID_MASTER_SATA 67
+#define ICBID_MASTER_UFS 68
+#define ICBID_MASTER_USB3_1 69
+#define ICBID_MASTER_VIDEO_OCMEM 70
+#define ICBID_MASTER_VPU1 71
+#define ICBID_MASTER_VCAP 72
+#define ICBID_MASTER_EMAC 73
+#define ICBID_MASTER_BCAST 74
+#define ICBID_MASTER_MMSS_PROC 75
+#define ICBID_MASTER_SNOC_BIMC_1 76
+#define ICBID_MASTER_SNOC_PCNOC 77
+#define ICBID_MASTER_AUDIO 78
+#define ICBID_MASTER_MM_INT_0 79
+#define ICBID_MASTER_MM_INT_1 80
+#define ICBID_MASTER_MM_INT_2 81
+#define ICBID_MASTER_MM_INT_BIMC 82
+#define ICBID_MASTER_MSS_INT 83
+#define ICBID_MASTER_PCNOC_CFG 84
+#define ICBID_MASTER_PCNOC_INT_0 85
+#define ICBID_MASTER_PCNOC_INT_1 86
+#define ICBID_MASTER_PCNOC_M_0 87
+#define ICBID_MASTER_PCNOC_M_1 88
+#define ICBID_MASTER_PCNOC_S_0 89
+#define ICBID_MASTER_PCNOC_S_1 90
+#define ICBID_MASTER_PCNOC_S_2 91
+#define ICBID_MASTER_PCNOC_S_3 92
+#define ICBID_MASTER_PCNOC_S_4 93
+#define ICBID_MASTER_PCNOC_S_6 94
+#define ICBID_MASTER_PCNOC_S_7 95
+#define ICBID_MASTER_PCNOC_S_8 96
+#define ICBID_MASTER_PCNOC_S_9 97
+#define ICBID_MASTER_QDSS_INT 98
+#define ICBID_MASTER_SNOC_INT_0 99
+#define ICBID_MASTER_SNOC_INT_1 100
+#define ICBID_MASTER_SNOC_INT_BIMC 101
+#define ICBID_MASTER_TCU_0 102
+#define ICBID_MASTER_TCU_1 103
+#define ICBID_MASTER_BIMC_INT_0 104
+#define ICBID_MASTER_BIMC_INT_1 105
+#define ICBID_MASTER_CAMERA 106
+#define ICBID_MASTER_RICA 107
+#define ICBID_MASTER_PCNOC_S_5	129
+#define ICBID_MASTER_PCNOC_INT_2	124
+#define ICBID_MASTER_PCNOC_INT_3	125
+#define ICBID_MASTER_PCNOC_INT_4	126
+#define ICBID_MASTER_PCNOC_INT_5	127
+#define ICBID_MASTER_PCNOC_INT_6	128
+#define ICBID_MASTER_PCIE_2 119
+#define ICBID_MASTER_MASTER_CNOC_A1NOC 116
+#define ICBID_MASTER_A0NOC_SNOC 110
+#define ICBID_MASTER_A1NOC_SNOC 111
+#define ICBID_MASTER_A2NOC_SNOC 112
+#define ICBID_MASTER_PNOC_A1NOC 117
+#define ICBID_MASTER_ROTATOR 120
+#define ICBID_MASTER_SNOC_VMEM 114
+#define ICBID_MASTER_VENUS_VMEM 121
+#define ICBID_MASTER_HMSS 118
+#define ICBID_MASTER_BIMC_SNOC_1 109
+#define ICBID_MASTER_CNOC_A1NOC 116
+#define ICBID_MASTER_CPP 115
+#define ICBID_MASTER_BLSP_BAM 130
+#define ICBID_MASTER_USB2_BAM 131
+#define ICBID_MASTER_ADSS_DMA0 132
+#define ICBID_MASTER_ADSS_DMA1 133
+#define ICBID_MASTER_ADSS_DMA2 134
+#define ICBID_MASTER_ADSS_DMA3 135
+#define ICBID_MASTER_QPIC_BAM 136
+#define ICBID_MASTER_SDCC_BAM 137
+#define ICBID_MASTER_DDRC_SNOC 138
+#define ICBID_MASTER_WSS_0 139
+#define ICBID_MASTER_WSS_1 140
+#define ICBID_MASTER_ESS 141
+#define ICBID_MASTER_PCIE 142
+#define ICBID_MASTER_QDSS_BAMNDP 143
+#define ICBID_MASTER_QDSS_SNOC_CFG 144
+
+#define ICBID_SLAVE_EBI1 0
+#define ICBID_SLAVE_APPSS_L2 1
+#define ICBID_SLAVE_BIMC_SNOC 2
+#define ICBID_SLAVE_CAMERA_CFG 3
+#define ICBID_SLAVE_DISPLAY_CFG 4
+#define ICBID_SLAVE_OCMEM_CFG 5
+#define ICBID_SLAVE_CPR_CFG 6
+#define ICBID_SLAVE_CPR_XPU_CFG 7
+#define ICBID_SLAVE_MISC_CFG 8
+#define ICBID_SLAVE_MISC_XPU_CFG 9
+#define ICBID_SLAVE_VENUS_CFG 10
+#define ICBID_SLAVE_GFX3D_CFG 11
+#define ICBID_SLAVE_MMSS_CLK_CFG 12
+#define ICBID_SLAVE_MMSS_CLK_XPU_CFG 13
+#define ICBID_SLAVE_MNOC_MPU_CFG 14
+#define ICBID_SLAVE_ONOC_MPU_CFG 15
+#define ICBID_SLAVE_MNOC_BIMC 16
+#define ICBID_SLAVE_SERVICE_MNOC 17
+#define ICBID_SLAVE_OCMEM 18
+#define ICBID_SLAVE_GMEM ICBID_SLAVE_OCMEM
+#define ICBID_SLAVE_SERVICE_ONOC 19
+#define ICBID_SLAVE_APPSS 20
+#define ICBID_SLAVE_LPASS 21
+#define ICBID_SLAVE_USB3 22
+#define ICBID_SLAVE_USB3_0 ICBID_SLAVE_USB3
+#define ICBID_SLAVE_WCSS 23
+#define ICBID_SLAVE_SNOC_BIMC 24
+#define ICBID_SLAVE_SNOC_BIMC_0 ICBID_SLAVE_SNOC_BIMC
+#define ICBID_SLAVE_SNOC_CNOC 25
+#define ICBID_SLAVE_IMEM 26
+#define ICBID_SLAVE_OCIMEM ICBID_SLAVE_IMEM
+#define ICBID_SLAVE_SNOC_OVIRT 27
+#define ICBID_SLAVE_SNOC_GVIRT ICBID_SLAVE_SNOC_OVIRT
+#define ICBID_SLAVE_SNOC_PNOC 28
+#define ICBID_SLAVE_SNOC_PCNOC ICBID_SLAVE_SNOC_PNOC
+#define ICBID_SLAVE_SERVICE_SNOC 29
+#define ICBID_SLAVE_QDSS_STM 30
+#define ICBID_SLAVE_SDCC_1 31
+#define ICBID_SLAVE_SDCC_3 32
+#define ICBID_SLAVE_SDCC_2 33
+#define ICBID_SLAVE_SDCC_4 34
+#define ICBID_SLAVE_TSIF 35
+#define ICBID_SLAVE_BAM_DMA 36
+#define ICBID_SLAVE_BLSP_2 37
+#define ICBID_SLAVE_USB_HSIC 38
+#define ICBID_SLAVE_BLSP_1 39
+#define ICBID_SLAVE_USB_HS 40
+#define ICBID_SLAVE_USB_HS1 ICBID_SLAVE_USB_HS
+#define ICBID_SLAVE_PDM 41
+#define ICBID_SLAVE_PERIPH_APU_CFG 42
+#define ICBID_SLAVE_PNOC_MPU_CFG 43
+#define ICBID_SLAVE_PRNG 44
+#define ICBID_SLAVE_PNOC_SNOC 45
+#define ICBID_SLAVE_PCNOC_SNOC ICBID_SLAVE_PNOC_SNOC
+#define ICBID_SLAVE_SERVICE_PNOC 46
+#define ICBID_SLAVE_CLK_CTL 47
+#define ICBID_SLAVE_CNOC_MSS 48
+#define ICBID_SLAVE_PCNOC_MSS ICBID_SLAVE_CNOC_MSS
+#define ICBID_SLAVE_SECURITY 49
+#define ICBID_SLAVE_TCSR 50
+#define ICBID_SLAVE_TLMM 51
+#define ICBID_SLAVE_CRYPTO_0_CFG 52
+#define ICBID_SLAVE_CRYPTO_1_CFG 53
+#define ICBID_SLAVE_IMEM_CFG 54
+#define ICBID_SLAVE_MESSAGE_RAM 55
+#define ICBID_SLAVE_BIMC_CFG 56
+#define ICBID_SLAVE_BOOT_ROM 57
+#define ICBID_SLAVE_CNOC_MNOC_MMSS_CFG 58
+#define ICBID_SLAVE_PMIC_ARB 59
+#define ICBID_SLAVE_SPDM_WRAPPER 60
+#define ICBID_SLAVE_DEHR_CFG 61
+#define ICBID_SLAVE_MPM 62
+#define ICBID_SLAVE_QDSS_CFG 63
+#define ICBID_SLAVE_RBCPR_CFG 64
+#define ICBID_SLAVE_RBCPR_CX_CFG ICBID_SLAVE_RBCPR_CFG
+#define ICBID_SLAVE_RBCPR_QDSS_APU_CFG 65
+#define ICBID_SLAVE_CNOC_MNOC_CFG 66
+#define ICBID_SLAVE_SNOC_MPU_CFG 67
+#define ICBID_SLAVE_CNOC_ONOC_CFG 68
+#define ICBID_SLAVE_PNOC_CFG 69
+#define ICBID_SLAVE_SNOC_CFG 70
+#define ICBID_SLAVE_EBI1_DLL_CFG 71
+#define ICBID_SLAVE_PHY_APU_CFG 72
+#define ICBID_SLAVE_EBI1_PHY_CFG 73
+#define ICBID_SLAVE_RPM 74
+#define ICBID_SLAVE_CNOC_SNOC 75
+#define ICBID_SLAVE_SERVICE_CNOC 76
+#define ICBID_SLAVE_OVIRT_SNOC 77
+#define ICBID_SLAVE_OVIRT_OCMEM 78
+#define ICBID_SLAVE_USB_HS2 79
+#define ICBID_SLAVE_QPIC 80
+#define ICBID_SLAVE_IPS_CFG 81
+#define ICBID_SLAVE_DSI_CFG 82
+#define ICBID_SLAVE_USB3_1 83
+#define ICBID_SLAVE_PCIE_0 84
+#define ICBID_SLAVE_PCIE_1 85
+#define ICBID_SLAVE_PSS_SMMU_CFG 86
+#define ICBID_SLAVE_CRYPTO_2_CFG 87
+#define ICBID_SLAVE_PCIE_0_CFG 88
+#define ICBID_SLAVE_PCIE_1_CFG 89
+#define ICBID_SLAVE_SATA_CFG 90
+#define ICBID_SLAVE_SPSS_GENI_IR 91
+#define ICBID_SLAVE_UFS_CFG 92
+#define ICBID_SLAVE_AVSYNC_CFG 93
+#define ICBID_SLAVE_VPU_CFG 94
+#define ICBID_SLAVE_USB_PHY_CFG 95
+#define ICBID_SLAVE_RBCPR_MX_CFG 96
+#define ICBID_SLAVE_PCIE_PARF 97
+#define ICBID_SLAVE_VCAP_CFG 98
+#define ICBID_SLAVE_EMAC_CFG 99
+#define ICBID_SLAVE_BCAST_CFG 100
+#define ICBID_SLAVE_KLM_CFG 101
+#define ICBID_SLAVE_DISPLAY_PWM 102
+#define ICBID_SLAVE_GENI 103
+#define ICBID_SLAVE_SNOC_BIMC_1 104
+#define ICBID_SLAVE_AUDIO 105
+#define ICBID_SLAVE_CATS_0 106
+#define ICBID_SLAVE_CATS_1 107
+#define ICBID_SLAVE_MM_INT_0 108
+#define ICBID_SLAVE_MM_INT_1 109
+#define ICBID_SLAVE_MM_INT_2 110
+#define ICBID_SLAVE_MM_INT_BIMC 111
+#define ICBID_SLAVE_MMU_MODEM_XPU_CFG 112
+#define ICBID_SLAVE_MSS_INT 113
+#define ICBID_SLAVE_PCNOC_INT_0 114
+#define ICBID_SLAVE_PCNOC_INT_1 115
+#define ICBID_SLAVE_PCNOC_M_0 116
+#define ICBID_SLAVE_PCNOC_M_1 117
+#define ICBID_SLAVE_PCNOC_S_0 118
+#define ICBID_SLAVE_PCNOC_S_1 119
+#define ICBID_SLAVE_PCNOC_S_2 120
+#define ICBID_SLAVE_PCNOC_S_3 121
+#define ICBID_SLAVE_PCNOC_S_4 122
+#define ICBID_SLAVE_PCNOC_S_6 123
+#define ICBID_SLAVE_PCNOC_S_7 124
+#define ICBID_SLAVE_PCNOC_S_8 125
+#define ICBID_SLAVE_PCNOC_S_9 126
+#define ICBID_SLAVE_PRNG_XPU_CFG 127
+#define ICBID_SLAVE_QDSS_INT 128
+#define ICBID_SLAVE_RPM_XPU_CFG 129
+#define ICBID_SLAVE_SNOC_INT_0 130
+#define ICBID_SLAVE_SNOC_INT_1 131
+#define ICBID_SLAVE_SNOC_INT_BIMC 132
+#define ICBID_SLAVE_TCU 133
+#define ICBID_SLAVE_BIMC_INT_0 134
+#define ICBID_SLAVE_BIMC_INT_1 135
+#define ICBID_SLAVE_RICA_CFG 136
+#define ICBID_SLAVE_PCNOC_S_5	189
+#define ICBID_SLAVE_PCNOC_S_7 124
+#define ICBID_SLAVE_PCNOC_INT_2 184
+#define ICBID_SLAVE_PCNOC_INT_3 185
+#define ICBID_SLAVE_PCNOC_INT_4 186
+#define ICBID_SLAVE_PCNOC_INT_5 187
+#define ICBID_SLAVE_PCNOC_INT_6 188
+#define ICBID_SLAVE_USB3_PHY_CFG 182
+#define ICBID_SLAVE_IPA_CFG 183
+
+#define ICBID_SLAVE_A0NOC_SNOC 141
+#define ICBID_SLAVE_A1NOC_SNOC 142
+#define ICBID_SLAVE_A2NOC_SNOC 143
+#define ICBID_SLAVE_BIMC_SNOC_1 138
+#define ICBID_SLAVE_PIMEM 167
+#define ICBID_SLAVE_PIMEM_CFG 168
+#define ICBID_SLAVE_DCC_CFG 155
+#define ICBID_SLAVE_QDSS_RBCPR_APU_CFG 168
+#define ICBID_SLAVE_A0NOC_CFG 144
+#define ICBID_SLAVE_PCIE_2_CFG 165
+#define ICBID_SLAVE_PCIE20_AHB2PHY 163
+#define ICBID_SLAVE_PCIE_2 164
+#define ICBID_SLAVE_A1NOC_CFG 147
+#define ICBID_SLAVE_A1NOC_MPU_CFG 148
+#define ICBID_SLAVE_A1NOC_SMMU_CFG 149
+#define ICBID_SLAVE_A2NOC_CFG 150
+#define ICBID_SLAVE_A2NOC_MPU_CFG 151
+#define ICBID_SLAVE_A2NOC_SMMU_CFG 152
+#define ICBID_SLAVE_AHB2PHY 153
+#define ICBID_SLAVE_HMSS_L3 161
+#define ICBID_SLAVE_LPASS_SMMU_CFG 161
+#define ICBID_SLAVE_MMAGIC_CFG 162
+#define ICBID_SLAVE_SSC_CFG 177
+#define ICBID_SLAVE_VENUS_THROTTLE_CFG 178
+#define ICBID_SLAVE_DISPLAY_THROTTLE_CFG 156
+#define ICBID_SLAVE_CAMERA_THROTTLE_CFG 154
+#define ICBID_SLAVE_DSA_CFG 157
+#define ICBID_SLAVE_DSA_MPU_CFG 158
+#define ICBID_SLAVE_SMMU_CPP_CFG 171
+#define ICBID_SLAVE_SMMU_JPEG_CFG 172
+#define ICBID_SLAVE_SMMU_MDP_CFG 173
+#define ICBID_SLAVE_SMMU_ROTATOR_CFG 174
+#define ICBID_SLAVE_SMMU_VENUS_CFG 175
+#define ICBID_SLAVE_SMMU_VFE_CFG 176
+#define ICBID_SLAVE_A0NOC_MPU_CFG 145
+#define ICBID_SLAVE_A0NOC_SMMU_CFG 146
+#define ICBID_SLAVE_VMEM_CFG 180
+#define ICBID_SLAVE_VMEM 179
+#define ICBID_SLAVE_PNOC_A1NOC 139
+#define ICBID_SLAVE_SNOC_VMEM 140
+#define ICBID_SLAVE_RBCPR_MX 170
+#define ICBID_SLAVE_RBCPR_CX 169
+#define ICBID_SLAVE_PRNG_APU_CFG 190
+#define ICBID_SLAVE_PERIPH_MPU_CFG 191
+#define ICBID_SLAVE_GCNT 192
+#define ICBID_SLAVE_ADSS_CFG 193
+#define ICBID_SLAVE_ADSS_APU 194
+#define ICBID_SLAVE_ADSS_VMIDMT_CFG 195
+#define ICBID_SLAVE_QHSS_APU_CFG 196
+#define ICBID_SLAVE_MDIO 197
+#define ICBID_SLAVE_FEPHY_CFG 198
+#define ICBID_SLAVE_SRIF 199
+#define ICBID_SLAVE_DDRC_CFG 200
+#define ICBID_SLAVE_DDRC_APU_CFG 201
+#define ICBID_SLAVE_DDRC_MPU0_CFG 202
+#define ICBID_SLAVE_DDRC_MPU1_CFG 203
+#define ICBID_SLAVE_DDRC_MPU2_CFG 210
+#define ICBID_SLAVE_ESS_VMIDMT_CFG 211
+#define ICBID_SLAVE_ESS_APU_CFG 212
+#define ICBID_SLAVE_USB2_CFG 213
+#define ICBID_SLAVE_BLSP_CFG 214
+#define ICBID_SLAVE_QPIC_CFG 215
+#define ICBID_SLAVE_SDCC_CFG 216
+#define ICBID_SLAVE_WSS0_VMIDMT_CFG 217
+#define ICBID_SLAVE_WSS0_APU_CFG 218
+#define ICBID_SLAVE_WSS1_VMIDMT_CFG 219
+#define ICBID_SLAVE_WSS1_APU_CFG 220
+#define ICBID_SLAVE_SRVC_PCNOC 221
+#define ICBID_SLAVE_SNOC_DDRC 222
+#define ICBID_SLAVE_A7SS 223
+#define ICBID_SLAVE_WSS0_CFG 224
+#define ICBID_SLAVE_WSS1_CFG 225
+#define ICBID_SLAVE_PCIE 226
+#define ICBID_SLAVE_USB3_CFG 227
+#define ICBID_SLAVE_CRYPTO_CFG 228
+#define ICBID_SLAVE_ESS_CFG 229
+#define ICBID_SLAVE_SRVC_SNOC 230
+#endif
--- /dev/null
+++ b/include/dt-bindings/msm/msm-bus-rule-ops.h
@@ -0,0 +1,32 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MSM_BUS_RULE_OPS_H
+#define __MSM_BUS_RULE_OPS_H
+
+#define FLD_IB	0
+#define FLD_AB	1
+#define FLD_CLK	2
+
+#define OP_LE	0
+#define OP_LT	1
+#define OP_GE	2
+#define OP_GT	3
+#define OP_NOOP	4
+
+#define RULE_STATE_NOT_APPLIED	0
+#define RULE_STATE_APPLIED	1
+
+#define THROTTLE_ON	0
+#define THROTTLE_OFF	1
+
+#endif
--- /dev/null
+++ b/drivers/bus/msm_bus/Kconfig
@@ -0,0 +1,19 @@
+config BUS_TOPOLOGY_ADHOC
+	bool "ad-hoc bus scaling topology"
+	depends on ARCH_QCOM
+	default n
+	help
+	  This option enables a driver that can handle adhoc bus topologies.
+	  Adhoc bus topology driver allows one to many connections and maintains
+	  directionality of connections by explicitly listing device connections
+	  thus avoiding illegal routes.
+
+config MSM_BUS_SCALING
+	bool "Bus scaling driver"
+	depends on BUS_TOPOLOGY_ADHOC
+	default n
+	help
+	  This option enables bus scaling on MSM devices.  Bus scaling
+	  allows devices to request the clocks be set to rates sufficient
+	  for the active devices needs without keeping the clocks at max
+	  frequency when a slower speed is sufficient.
--- /dev/null
+++ b/drivers/bus/msm_bus/Makefile
@@ -0,0 +1,12 @@
+#
+# Makefile for msm-bus driver specific files
+#
+obj-y += msm_bus_bimc.o msm_bus_noc.o msm_bus_core.o msm_bus_client_api.o \
+	 msm_bus_id.o
+obj-$(CONFIG_OF) += msm_bus_of.o
+
+obj-y += msm_bus_fabric_adhoc.o msm_bus_arb_adhoc.o msm_bus_rules.o
+obj-$(CONFIG_OF) += msm_bus_of_adhoc.o
+obj-$(CONFIG_CORESIGHT) +=  msm_buspm_coresight_adhoc.o
+
+obj-$(CONFIG_DEBUG_FS) += msm_bus_dbg.o
--- /dev/null
+++ b/drivers/bus/msm_bus/msm-bus-board.h
@@ -0,0 +1,198 @@
+/* Copyright (c) 2010-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARCH_MSM_BUS_BOARD_H
+#define __ASM_ARCH_MSM_BUS_BOARD_H
+
+#include <linux/types.h>
+#include <linux/input.h>
+
+enum context {
+	DUAL_CTX,
+	ACTIVE_CTX,
+	NUM_CTX
+};
+
+struct msm_bus_fabric_registration {
+	unsigned int id;
+	const char *name;
+	struct msm_bus_node_info *info;
+	unsigned int len;
+	int ahb;
+	const char *fabclk[NUM_CTX];
+	const char *iface_clk;
+	unsigned int offset;
+	unsigned int haltid;
+	unsigned int rpm_enabled;
+	unsigned int nmasters;
+	unsigned int nslaves;
+	unsigned int ntieredslaves;
+	bool il_flag;
+	const struct msm_bus_board_algorithm *board_algo;
+	int hw_sel;
+	void *hw_data;
+	uint32_t qos_freq;
+	uint32_t qos_baseoffset;
+	u64 nr_lim_thresh;
+	uint32_t eff_fact;
+	uint32_t qos_delta;
+	bool virt;
+};
+
+struct msm_bus_device_node_registration {
+	struct msm_bus_node_device_type *info;
+	unsigned int num_devices;
+	bool virt;
+};
+
+enum msm_bus_bw_tier_type {
+	MSM_BUS_BW_TIER1 = 1,
+	MSM_BUS_BW_TIER2,
+	MSM_BUS_BW_COUNT,
+	MSM_BUS_BW_SIZE = 0x7FFFFFFF,
+};
+
+struct msm_bus_halt_vector {
+	uint32_t haltval;
+	uint32_t haltmask;
+};
+
+extern struct msm_bus_fabric_registration msm_bus_apps_fabric_pdata;
+extern struct msm_bus_fabric_registration msm_bus_sys_fabric_pdata;
+extern struct msm_bus_fabric_registration msm_bus_mm_fabric_pdata;
+extern struct msm_bus_fabric_registration msm_bus_sys_fpb_pdata;
+extern struct msm_bus_fabric_registration msm_bus_cpss_fpb_pdata;
+extern struct msm_bus_fabric_registration msm_bus_def_fab_pdata;
+
+extern struct msm_bus_fabric_registration msm_bus_8960_apps_fabric_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8960_sys_fabric_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8960_mm_fabric_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8960_sg_mm_fabric_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8960_sys_fpb_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8960_cpss_fpb_pdata;
+
+extern struct msm_bus_fabric_registration msm_bus_8064_apps_fabric_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8064_sys_fabric_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8064_mm_fabric_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8064_sys_fpb_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8064_cpss_fpb_pdata;
+
+extern struct msm_bus_fabric_registration msm_bus_9615_sys_fabric_pdata;
+extern struct msm_bus_fabric_registration msm_bus_9615_def_fab_pdata;
+
+extern struct msm_bus_fabric_registration msm_bus_8930_apps_fabric_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8930_sys_fabric_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8930_mm_fabric_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8930_sys_fpb_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8930_cpss_fpb_pdata;
+
+extern struct msm_bus_fabric_registration msm_bus_8974_sys_noc_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8974_mmss_noc_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8974_bimc_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8974_ocmem_noc_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8974_periph_noc_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8974_config_noc_pdata;
+extern struct msm_bus_fabric_registration msm_bus_8974_ocmem_vnoc_pdata;
+
+extern struct msm_bus_fabric_registration msm_bus_9625_sys_noc_pdata;
+extern struct msm_bus_fabric_registration msm_bus_9625_bimc_pdata;
+extern struct msm_bus_fabric_registration msm_bus_9625_periph_noc_pdata;
+extern struct msm_bus_fabric_registration msm_bus_9625_config_noc_pdata;
+
+extern int msm_bus_device_match_adhoc(struct device *dev, void *id);
+
+void msm_bus_rpm_set_mt_mask(void);
+int msm_bus_board_rpm_get_il_ids(uint16_t *id);
+int msm_bus_board_get_iid(int id);
+
+#define NFAB_MSM8226 6
+#define NFAB_MSM8610 5
+
+/*
+ * These macros specify the convention followed for allocating
+ * ids to fabrics, masters and slaves for 8x60.
+ *
+ * A node can be identified as a master/slave/fabric by using
+ * these ids.
+ */
+#define FABRIC_ID_KEY 1024
+#define SLAVE_ID_KEY ((FABRIC_ID_KEY) >> 1)
+#define MAX_FAB_KEY 7168  /* OR(All fabric ids) */
+#define INT_NODE_START 10000
+
+#define GET_FABID(id) ((id) & MAX_FAB_KEY)
+
+#define NODE_ID(id) ((id) & (FABRIC_ID_KEY - 1))
+#define IS_SLAVE(id) ((NODE_ID(id)) >= SLAVE_ID_KEY ? 1 : 0)
+#define CHECK_ID(iid, id) (((iid & id) != id) ? -ENXIO : iid)
+
+/*
+ * The following macros are used to format the data for port halt
+ * and unhalt requests.
+ */
+#define MSM_BUS_CLK_HALT 0x1
+#define MSM_BUS_CLK_HALT_MASK 0x1
+#define MSM_BUS_CLK_HALT_FIELDSIZE 0x1
+#define MSM_BUS_CLK_UNHALT 0x0
+
+#define MSM_BUS_MASTER_SHIFT(master, fieldsize) \
+	((master) * (fieldsize))
+
+#define MSM_BUS_SET_BITFIELD(word, fieldmask, fieldvalue) \
+	{	\
+		(word) &= ~(fieldmask);	\
+		(word) |= (fieldvalue);	\
+	}
+
+
+#define MSM_BUS_MASTER_HALT(u32haltmask, u32haltval, master) \
+	MSM_BUS_SET_BITFIELD(u32haltmask, \
+		MSM_BUS_CLK_HALT_MASK<<MSM_BUS_MASTER_SHIFT((master),\
+		MSM_BUS_CLK_HALT_FIELDSIZE), \
+		MSM_BUS_CLK_HALT_MASK<<MSM_BUS_MASTER_SHIFT((master),\
+		MSM_BUS_CLK_HALT_FIELDSIZE))\
+	MSM_BUS_SET_BITFIELD(u32haltval, \
+		MSM_BUS_CLK_HALT_MASK<<MSM_BUS_MASTER_SHIFT((master),\
+		MSM_BUS_CLK_HALT_FIELDSIZE), \
+		MSM_BUS_CLK_HALT<<MSM_BUS_MASTER_SHIFT((master),\
+		MSM_BUS_CLK_HALT_FIELDSIZE))\
+
+#define MSM_BUS_MASTER_UNHALT(u32haltmask, u32haltval, master) \
+	MSM_BUS_SET_BITFIELD(u32haltmask, \
+		MSM_BUS_CLK_HALT_MASK<<MSM_BUS_MASTER_SHIFT((master),\
+		MSM_BUS_CLK_HALT_FIELDSIZE), \
+		MSM_BUS_CLK_HALT_MASK<<MSM_BUS_MASTER_SHIFT((master),\
+		MSM_BUS_CLK_HALT_FIELDSIZE))\
+	MSM_BUS_SET_BITFIELD(u32haltval, \
+		MSM_BUS_CLK_HALT_MASK<<MSM_BUS_MASTER_SHIFT((master),\
+		MSM_BUS_CLK_HALT_FIELDSIZE), \
+		MSM_BUS_CLK_UNHALT<<MSM_BUS_MASTER_SHIFT((master),\
+		MSM_BUS_CLK_HALT_FIELDSIZE))\
+
+#define RPM_BUS_SLAVE_REQ	0x766c7362
+#define RPM_BUS_MASTER_REQ	0x73616d62
+
+enum msm_bus_rpm_slave_field_type {
+	RPM_SLAVE_FIELD_BW = 0x00007762,
+};
+
+enum msm_bus_rpm_mas_field_type {
+	RPM_MASTER_FIELD_BW =		0x00007762,
+	RPM_MASTER_FIELD_BW_T0 =	0x30747762,
+	RPM_MASTER_FIELD_BW_T1 =	0x31747762,
+	RPM_MASTER_FIELD_BW_T2 =	0x32747762,
+};
+
+#include <dt-bindings/msm/msm-bus-ids.h>
+
+
+#endif /*__ASM_ARCH_MSM_BUS_BOARD_H */
--- /dev/null
+++ b/drivers/bus/msm_bus/msm-bus.h
@@ -0,0 +1,139 @@
+/* Copyright (c) 2010-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _ARCH_ARM_MACH_MSM_BUS_H
+#define _ARCH_ARM_MACH_MSM_BUS_H
+
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+
+/*
+ * Macros for clients to convert their data to ib and ab
+ * Ws : Time window over which to transfer the data in SECONDS
+ * Bs : Size of the data block in bytes
+ * Per : Recurrence period
+ * Tb : Throughput bandwidth to prevent stalling
+ * R  : Ratio of actual bandwidth used to Tb
+ * Ib : Instantaneous bandwidth
+ * Ab : Arbitrated bandwidth
+ *
+ * IB_RECURRBLOCK and AB_RECURRBLOCK:
+ * These are used if the requirement is to transfer a
+ * recurring block of data over a known time window.
+ *
+ * IB_THROUGHPUTBW and AB_THROUGHPUTBW:
+ * These are used for CPU style masters. Here the requirement
+ * is to have minimum throughput bandwidth available to avoid
+ * stalling.
+ */
+#define IB_RECURRBLOCK(Ws, Bs) ((Ws) == 0 ? 0 : ((Bs)/(Ws)))
+#define AB_RECURRBLOCK(Ws, Per) ((Ws) == 0 ? 0 : ((Bs)/(Per)))
+#define IB_THROUGHPUTBW(Tb) (Tb)
+#define AB_THROUGHPUTBW(Tb, R) ((Tb) * (R))
+
+struct msm_bus_vectors {
+	int src; /* Master */
+	int dst; /* Slave */
+	uint64_t ab; /* Arbitrated bandwidth */
+	uint64_t ib; /* Instantaneous bandwidth */
+};
+
+struct msm_bus_paths {
+	int num_paths;
+	struct msm_bus_vectors *vectors;
+};
+
+struct msm_bus_scale_pdata {
+	struct msm_bus_paths *usecase;
+	int num_usecases;
+	const char *name;
+	/*
+	 * If the active_only flag is set to 1, the BW request is applied
+	 * only when at least one CPU is active (powered on). If the flag
+	 * is set to 0, then the BW request is always applied irrespective
+	 * of the CPU state.
+	 */
+	unsigned int active_only;
+};
+
+/* Scaling APIs */
+
+/*
+ * This function returns a handle to the client. This should be used to
+ * call msm_bus_scale_client_update_request.
+ * The function returns 0 if bus driver is unable to register a client
+ */
+
+#if (defined(CONFIG_MSM_BUS_SCALING) || defined(CONFIG_BUS_TOPOLOGY_ADHOC))
+int __init msm_bus_fabric_init_driver(void);
+uint32_t msm_bus_scale_register_client(struct msm_bus_scale_pdata *pdata);
+int msm_bus_scale_client_update_request(uint32_t cl, unsigned int index);
+void msm_bus_scale_unregister_client(uint32_t cl);
+/* AXI Port configuration APIs */
+int msm_bus_axi_porthalt(int master_port);
+int msm_bus_axi_portunhalt(int master_port);
+
+#else
+static inline int __init msm_bus_fabric_init_driver(void) { return 0; }
+
+static inline uint32_t
+msm_bus_scale_register_client(struct msm_bus_scale_pdata *pdata)
+{
+	return 1;
+}
+
+static inline int
+msm_bus_scale_client_update_request(uint32_t cl, unsigned int index)
+{
+	return 0;
+}
+
+static inline void
+msm_bus_scale_unregister_client(uint32_t cl)
+{
+}
+
+static inline int msm_bus_axi_porthalt(int master_port)
+{
+	return 0;
+}
+
+static inline int msm_bus_axi_portunhalt(int master_port)
+{
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_OF) && defined(CONFIG_MSM_BUS_SCALING)
+struct msm_bus_scale_pdata *msm_bus_pdata_from_node(
+		struct platform_device *pdev, struct device_node *of_node);
+struct msm_bus_scale_pdata *msm_bus_cl_get_pdata(struct platform_device *pdev);
+void msm_bus_cl_clear_pdata(struct msm_bus_scale_pdata *pdata);
+#else
+static inline struct msm_bus_scale_pdata
+*msm_bus_cl_get_pdata(struct platform_device *pdev)
+{
+	return NULL;
+}
+
+static inline struct msm_bus_scale_pdata *msm_bus_pdata_from_node(
+		struct platform_device *pdev, struct device_node *of_node)
+{
+	return NULL;
+}
+
+static inline void msm_bus_cl_clear_pdata(struct msm_bus_scale_pdata *pdata)
+{
+}
+#endif
+#endif /*_ARCH_ARM_MACH_MSM_BUS_H*/
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_adhoc.h
@@ -0,0 +1,141 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _ARCH_ARM_MACH_MSM_BUS_ADHOC_H
+#define _ARCH_ARM_MACH_MSM_BUS_ADHOC_H
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include "msm-bus-board.h"
+#include "msm-bus.h"
+#include "msm_bus_rules.h"
+#include "msm_bus_core.h"
+
+struct msm_bus_node_device_type;
+struct link_node {
+	uint64_t lnode_ib[NUM_CTX];
+	uint64_t lnode_ab[NUM_CTX];
+	int next;
+	struct device *next_dev;
+	struct list_head link;
+	uint32_t in_use;
+};
+
+/* New types introduced for adhoc topology */
+struct msm_bus_noc_ops {
+	int (*qos_init)(struct msm_bus_node_device_type *dev,
+			void __iomem *qos_base, uint32_t qos_off,
+			uint32_t qos_delta, uint32_t qos_freq);
+	int (*set_bw)(struct msm_bus_node_device_type *dev,
+			void __iomem *qos_base, uint32_t qos_off,
+			uint32_t qos_delta, uint32_t qos_freq);
+	int (*limit_mport)(struct msm_bus_node_device_type *dev,
+			void __iomem *qos_base, uint32_t qos_off,
+			uint32_t qos_delta, uint32_t qos_freq, bool enable_lim,
+			uint64_t lim_bw);
+	bool (*update_bw_reg)(int mode);
+};
+
+struct nodebw {
+	uint64_t ab[NUM_CTX];
+	bool dirty;
+};
+
+struct msm_bus_fab_device_type {
+	void __iomem *qos_base;
+	phys_addr_t pqos_base;
+	size_t qos_range;
+	uint32_t base_offset;
+	uint32_t qos_freq;
+	uint32_t qos_off;
+	uint32_t util_fact;
+	uint32_t vrail_comp;
+	struct msm_bus_noc_ops noc_ops;
+	enum msm_bus_hw_sel bus_type;
+	bool bypass_qos_prg;
+};
+
+struct qos_params_type {
+	int mode;
+	unsigned int prio_lvl;
+	unsigned int prio_rd;
+	unsigned int prio_wr;
+	unsigned int prio1;
+	unsigned int prio0;
+	unsigned int gp;
+	unsigned int thmp;
+	unsigned int ws;
+	int cur_mode;
+	u64 bw_buffer;
+};
+
+struct msm_bus_node_info_type {
+	const char *name;
+	unsigned int id;
+	int mas_rpm_id;
+	int slv_rpm_id;
+	int num_ports;
+	int num_qports;
+	int *qport;
+	struct qos_params_type qos_params;
+	unsigned int num_connections;
+	unsigned int num_blist;
+	bool is_fab_dev;
+	bool virt_dev;
+	bool is_traversed;
+	unsigned int *connections;
+	unsigned int *black_listed_connections;
+	struct device **dev_connections;
+	struct device **black_connections;
+	unsigned int bus_device_id;
+	struct device *bus_device;
+	unsigned int buswidth;
+	struct rule_update_path_info rule;
+	uint64_t lim_bw;
+	uint32_t util_fact;
+	uint32_t vrail_comp;
+};
+
+struct msm_bus_node_device_type {
+	struct msm_bus_node_info_type *node_info;
+	struct msm_bus_fab_device_type *fabdev;
+	int num_lnodes;
+	struct link_node *lnode_list;
+	uint64_t cur_clk_hz[NUM_CTX];
+	struct nodebw node_ab;
+	struct list_head link;
+	unsigned int ap_owned;
+	struct nodeclk clk[NUM_CTX];
+	struct nodeclk qos_clk;
+};
+
+int msm_bus_enable_limiter(struct msm_bus_node_device_type *nodedev,
+				bool throttle_en, uint64_t lim_bw);
+int msm_bus_update_clks(struct msm_bus_node_device_type *nodedev,
+	int ctx, int **dirty_nodes, int *num_dirty);
+int msm_bus_commit_data(int *dirty_nodes, int ctx, int num_dirty);
+int msm_bus_update_bw(struct msm_bus_node_device_type *nodedev, int ctx,
+	int64_t add_bw, int **dirty_nodes, int *num_dirty);
+void *msm_bus_realloc_devmem(struct device *dev, void *p, size_t old_size,
+					size_t new_size, gfp_t flags);
+
+extern struct msm_bus_device_node_registration
+	*msm_bus_of_to_pdata(struct platform_device *pdev);
+extern void msm_bus_arb_setops_adhoc(struct msm_bus_arb_ops *arb_ops);
+extern int msm_bus_bimc_set_ops(struct msm_bus_node_device_type *bus_dev);
+extern int msm_bus_noc_set_ops(struct msm_bus_node_device_type *bus_dev);
+extern int msm_bus_of_get_static_rules(struct platform_device *pdev,
+					struct bus_rule_type **static_rule);
+extern int msm_rules_update_path(struct list_head *input_list,
+				struct list_head *output_list);
+extern void print_all_rules(void);
+#endif /* _ARCH_ARM_MACH_MSM_BUS_ADHOC_H */
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_arb_adhoc.c
@@ -0,0 +1,998 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is Mree software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/clk.h>
+#include "msm-bus.h"
+#include "msm_bus_core.h"
+#include "msm_bus_adhoc.h"
+
+#define NUM_CL_HANDLES	50
+#define NUM_LNODES	3
+
+struct bus_search_type {
+	struct list_head link;
+	struct list_head node_list;
+};
+
+struct handle_type {
+	int num_entries;
+	struct msm_bus_client **cl_list;
+};
+
+static struct handle_type handle_list;
+struct list_head input_list;
+struct list_head apply_list;
+
+DEFINE_MUTEX(msm_bus_adhoc_lock);
+
+static bool chk_bl_list(struct list_head *black_list, unsigned int id)
+{
+	struct msm_bus_node_device_type *bus_node = NULL;
+
+	list_for_each_entry(bus_node, black_list, link) {
+		if (bus_node->node_info->id == id)
+			return true;
+	}
+	return false;
+}
+
+static void copy_remaining_nodes(struct list_head *edge_list, struct list_head
+	*traverse_list, struct list_head *route_list)
+{
+	struct bus_search_type *search_node;
+
+	if (list_empty(edge_list) && list_empty(traverse_list))
+		return;
+
+	search_node = kzalloc(sizeof(struct bus_search_type), GFP_KERNEL);
+	INIT_LIST_HEAD(&search_node->node_list);
+	list_splice_init(edge_list, traverse_list);
+	list_splice_init(traverse_list, &search_node->node_list);
+	list_add_tail(&search_node->link, route_list);
+}
+
+/*
+ * Duplicate instantiaion from msm_bus_arb.c. Todo there needs to be a
+ * "util" file for these common func/macros.
+ *
+ * */
+uint64_t msm_bus_div64(unsigned int w, uint64_t bw)
+{
+	uint64_t *b = &bw;
+
+	if ((bw > 0) && (bw < w))
+		return 1;
+
+	switch (w) {
+	case 0:
+		WARN(1, "AXI: Divide by 0 attempted\n");
+	case 1: return bw;
+	case 2: return (bw >> 1);
+	case 4: return (bw >> 2);
+	case 8: return (bw >> 3);
+	case 16: return (bw >> 4);
+	case 32: return (bw >> 5);
+	}
+
+	do_div(*b, w);
+	return *b;
+}
+
+int msm_bus_device_match_adhoc(struct device *dev, void *id)
+{
+	int ret = 0;
+	struct msm_bus_node_device_type *bnode = dev->platform_data;
+
+	if (bnode)
+		ret = (bnode->node_info->id == *(unsigned int *)id);
+	else
+		ret = 0;
+
+	return ret;
+}
+
+static int gen_lnode(struct device *dev,
+			int next_hop, int prev_idx)
+{
+	struct link_node *lnode;
+	struct msm_bus_node_device_type *cur_dev = NULL;
+	int lnode_idx = -1;
+
+	if (!dev)
+		goto exit_gen_lnode;
+
+	cur_dev = dev->platform_data;
+	if (!cur_dev) {
+		MSM_BUS_ERR("%s: Null device ptr", __func__);
+		goto exit_gen_lnode;
+	}
+
+	if (!cur_dev->num_lnodes) {
+		cur_dev->lnode_list = devm_kzalloc(dev,
+				sizeof(struct link_node) * NUM_LNODES,
+								GFP_KERNEL);
+		if (!cur_dev->lnode_list)
+			goto exit_gen_lnode;
+
+		lnode = cur_dev->lnode_list;
+		cur_dev->num_lnodes = NUM_LNODES;
+		lnode_idx = 0;
+	} else {
+		int i;
+		for (i = 0; i < cur_dev->num_lnodes; i++) {
+			if (!cur_dev->lnode_list[i].in_use)
+				break;
+		}
+
+		if (i < cur_dev->num_lnodes) {
+			lnode = &cur_dev->lnode_list[i];
+			lnode_idx = i;
+		} else {
+			struct link_node *realloc_list;
+			size_t cur_size = sizeof(struct link_node) *
+					cur_dev->num_lnodes;
+
+			cur_dev->num_lnodes += NUM_LNODES;
+			realloc_list = msm_bus_realloc_devmem(
+					dev,
+					cur_dev->lnode_list,
+					cur_size,
+					sizeof(struct link_node) *
+					cur_dev->num_lnodes, GFP_KERNEL);
+
+			if (!realloc_list)
+				goto exit_gen_lnode;
+
+			cur_dev->lnode_list = realloc_list;
+			lnode = &cur_dev->lnode_list[i];
+			lnode_idx = i;
+		}
+	}
+
+	lnode->in_use = 1;
+	if (next_hop == cur_dev->node_info->id) {
+		lnode->next = -1;
+		lnode->next_dev = NULL;
+	} else {
+		lnode->next = prev_idx;
+		lnode->next_dev = bus_find_device(&msm_bus_type, NULL,
+					(void *) &next_hop,
+					msm_bus_device_match_adhoc);
+	}
+
+	memset(lnode->lnode_ib, 0, sizeof(uint64_t) * NUM_CTX);
+	memset(lnode->lnode_ab, 0, sizeof(uint64_t) * NUM_CTX);
+
+exit_gen_lnode:
+	return lnode_idx;
+}
+
+static int remove_lnode(struct msm_bus_node_device_type *cur_dev,
+				int lnode_idx)
+{
+	int ret = 0;
+
+	if (!cur_dev) {
+		MSM_BUS_ERR("%s: Null device ptr", __func__);
+		ret = -ENODEV;
+		goto exit_remove_lnode;
+	}
+
+	if (lnode_idx != -1) {
+		if (!cur_dev->num_lnodes ||
+				(lnode_idx > (cur_dev->num_lnodes - 1))) {
+			MSM_BUS_ERR("%s: Invalid Idx %d, num_lnodes %d",
+				__func__, lnode_idx, cur_dev->num_lnodes);
+			ret = -ENODEV;
+			goto exit_remove_lnode;
+		}
+
+		cur_dev->lnode_list[lnode_idx].next = -1;
+		cur_dev->lnode_list[lnode_idx].next_dev = NULL;
+		cur_dev->lnode_list[lnode_idx].in_use = 0;
+	}
+
+exit_remove_lnode:
+	return ret;
+}
+
+static int prune_path(struct list_head *route_list, int dest, int src,
+				struct list_head *black_list, int found)
+{
+	struct bus_search_type *search_node, *temp_search_node;
+	struct msm_bus_node_device_type *bus_node;
+	struct list_head *bl_list;
+	struct list_head *temp_bl_list;
+	int search_dev_id = dest;
+	struct device *dest_dev = bus_find_device(&msm_bus_type, NULL,
+					(void *) &dest,
+					msm_bus_device_match_adhoc);
+	int lnode_hop = -1;
+
+	if (!found)
+		goto reset_links;
+
+	if (!dest_dev) {
+		MSM_BUS_ERR("%s: Can't find dest dev %d", __func__, dest);
+		goto exit_prune_path;
+	}
+
+	lnode_hop = gen_lnode(dest_dev, search_dev_id, lnode_hop);
+
+	list_for_each_entry_reverse(search_node, route_list, link) {
+		list_for_each_entry(bus_node, &search_node->node_list, link) {
+			unsigned int i;
+			for (i = 0; i < bus_node->node_info->num_connections;
+									i++) {
+				if (bus_node->node_info->connections[i] ==
+								search_dev_id) {
+					dest_dev = bus_find_device(
+						&msm_bus_type,
+						NULL,
+						(void *)
+						&bus_node->node_info->
+						id,
+						msm_bus_device_match_adhoc);
+
+					if (!dest_dev) {
+						lnode_hop = -1;
+						goto reset_links;
+					}
+
+					lnode_hop = gen_lnode(dest_dev,
+							search_dev_id,
+							lnode_hop);
+					search_dev_id =
+						bus_node->node_info->id;
+					break;
+				}
+			}
+		}
+	}
+reset_links:
+	list_for_each_entry_safe(search_node, temp_search_node, route_list,
+									link) {
+			list_for_each_entry(bus_node, &search_node->node_list,
+									link)
+				bus_node->node_info->is_traversed = false;
+
+			list_del(&search_node->link);
+			kfree(search_node);
+	}
+
+	list_for_each_safe(bl_list, temp_bl_list, black_list)
+		list_del(bl_list);
+
+exit_prune_path:
+	return lnode_hop;
+}
+
+static void setup_bl_list(struct msm_bus_node_device_type *node,
+				struct list_head *black_list)
+{
+	unsigned int i;
+
+	for (i = 0; i < node->node_info->num_blist; i++) {
+		struct msm_bus_node_device_type *bdev;
+		bdev = node->node_info->black_connections[i]->platform_data;
+		list_add_tail(&bdev->link, black_list);
+	}
+}
+
+static int getpath(int src, int dest)
+{
+	struct list_head traverse_list;
+	struct list_head edge_list;
+	struct list_head route_list;
+	struct list_head black_list;
+	struct device *src_dev = bus_find_device(&msm_bus_type, NULL,
+					(void *) &src,
+					msm_bus_device_match_adhoc);
+	struct msm_bus_node_device_type *src_node;
+	struct bus_search_type *search_node;
+	int found = 0;
+	int depth_index = 0;
+	int first_hop = -1;
+
+	INIT_LIST_HEAD(&traverse_list);
+	INIT_LIST_HEAD(&edge_list);
+	INIT_LIST_HEAD(&route_list);
+	INIT_LIST_HEAD(&black_list);
+
+	if (!src_dev) {
+		MSM_BUS_ERR("%s: Cannot locate src dev %d", __func__, src);
+		goto exit_getpath;
+	}
+
+	src_node = src_dev->platform_data;
+	if (!src_node) {
+		MSM_BUS_ERR("%s:Fatal, Source dev %d not found", __func__, src);
+		goto exit_getpath;
+	}
+	list_add_tail(&src_node->link, &traverse_list);
+
+	while ((!found && !list_empty(&traverse_list))) {
+		struct msm_bus_node_device_type *bus_node = NULL;
+		/* Locate dest_id in the traverse list */
+		list_for_each_entry(bus_node, &traverse_list, link) {
+			if (bus_node->node_info->id == dest) {
+				found = 1;
+				break;
+			}
+		}
+
+		if (!found) {
+			unsigned int i;
+			/* Setup the new edge list */
+			list_for_each_entry(bus_node, &traverse_list, link) {
+				/* Setup list of black-listed nodes */
+				setup_bl_list(bus_node, &black_list);
+
+				for (i = 0; i < bus_node->node_info->
+						num_connections; i++) {
+					bool skip;
+					struct msm_bus_node_device_type
+							*node_conn;
+					node_conn = bus_node->node_info->
+						dev_connections[i]->
+						platform_data;
+					if (node_conn->node_info->
+							is_traversed) {
+						MSM_BUS_ERR("Circ Path %d\n",
+						node_conn->node_info->id);
+						goto reset_traversed;
+					}
+					skip = chk_bl_list(&black_list,
+							bus_node->node_info->
+							connections[i]);
+					if (!skip) {
+						list_add_tail(&node_conn->link,
+							&edge_list);
+						node_conn->node_info->
+							is_traversed = true;
+					}
+				}
+			}
+
+			/* Keep tabs of the previous search list */
+			search_node = kzalloc(sizeof(struct bus_search_type),
+					 GFP_KERNEL);
+			INIT_LIST_HEAD(&search_node->node_list);
+			list_splice_init(&traverse_list,
+					 &search_node->node_list);
+			/* Add the previous search list to a route list */
+			list_add_tail(&search_node->link, &route_list);
+			/* Advancing the list depth */
+			depth_index++;
+			list_splice_init(&edge_list, &traverse_list);
+		}
+	}
+reset_traversed:
+	copy_remaining_nodes(&edge_list, &traverse_list, &route_list);
+	first_hop = prune_path(&route_list, dest, src, &black_list, found);
+
+exit_getpath:
+	return first_hop;
+}
+
+static uint64_t arbitrate_bus_req(struct msm_bus_node_device_type *bus_dev,
+								int ctx)
+{
+	int i;
+	uint64_t max_ib = 0;
+	uint64_t sum_ab = 0;
+	uint64_t bw_max_hz;
+	struct msm_bus_node_device_type *fab_dev = NULL;
+	uint32_t util_fact = 0;
+	uint32_t vrail_comp = 0;
+
+	/* Find max ib */
+	for (i = 0; i < bus_dev->num_lnodes; i++) {
+		max_ib = max(max_ib, bus_dev->lnode_list[i].lnode_ib[ctx]);
+		sum_ab += bus_dev->lnode_list[i].lnode_ab[ctx];
+	}
+	/*
+	 *  Account for Util factor and vrail comp. The new aggregation
+	 *  formula is:
+	 *  Freq_hz = max((sum(ab) * util_fact)/num_chan, max(ib)/vrail_comp)
+	 *				/ bus-width
+	 *  util_fact and vrail comp are obtained from fabric/Node's dts
+	 *  properties.
+	 *  They default to 100 if absent.
+	 */
+	fab_dev = bus_dev->node_info->bus_device->platform_data;
+	/* Don't do this for virtual fabrics */
+	if (fab_dev && fab_dev->fabdev) {
+		util_fact = bus_dev->node_info->util_fact ?
+			bus_dev->node_info->util_fact :
+			fab_dev->fabdev->util_fact;
+		vrail_comp = bus_dev->node_info->vrail_comp ?
+			bus_dev->node_info->vrail_comp :
+			fab_dev->fabdev->vrail_comp;
+		sum_ab *= util_fact;
+		sum_ab = msm_bus_div64(100, sum_ab);
+		max_ib *= 100;
+		max_ib = msm_bus_div64(vrail_comp, max_ib);
+	}
+
+	/* Account for multiple channels if any */
+	if (bus_dev->node_info->num_qports > 1)
+		sum_ab = msm_bus_div64(bus_dev->node_info->num_qports,
+					sum_ab);
+
+	if (!bus_dev->node_info->buswidth) {
+		MSM_BUS_WARN("No bus width found for %d. Using default\n",
+					bus_dev->node_info->id);
+		bus_dev->node_info->buswidth = 8;
+	}
+
+	bw_max_hz = max(max_ib, sum_ab);
+	bw_max_hz = msm_bus_div64(bus_dev->node_info->buswidth,
+					bw_max_hz);
+
+	return bw_max_hz;
+}
+
+static void del_inp_list(struct list_head *list)
+{
+	struct rule_update_path_info *rule_node;
+	struct rule_update_path_info *rule_node_tmp;
+
+	list_for_each_entry_safe(rule_node, rule_node_tmp, list, link)
+		list_del(&rule_node->link);
+}
+
+static void del_op_list(struct list_head *list)
+{
+	struct rule_apply_rcm_info *rule;
+	struct rule_apply_rcm_info *rule_tmp;
+
+	list_for_each_entry_safe(rule, rule_tmp, list, link)
+		list_del(&rule->link);
+}
+
+static int msm_bus_apply_rules(struct list_head *list, bool after_clk_commit)
+{
+	struct rule_apply_rcm_info *rule;
+	struct device *dev = NULL;
+	struct msm_bus_node_device_type *dev_info = NULL;
+	int ret = 0;
+	bool throttle_en = false;
+
+	list_for_each_entry(rule, list, link) {
+		if (!rule)
+			break;
+
+		if (rule && (rule->after_clk_commit != after_clk_commit))
+			continue;
+
+		dev = bus_find_device(&msm_bus_type, NULL,
+				(void *) &rule->id,
+				msm_bus_device_match_adhoc);
+
+		if (!dev) {
+			MSM_BUS_ERR("Can't find dev node for %d", rule->id);
+			continue;
+		}
+		dev_info = dev->platform_data;
+
+		throttle_en = ((rule->throttle == THROTTLE_ON) ? true : false);
+		ret = msm_bus_enable_limiter(dev_info, throttle_en,
+							rule->lim_bw);
+		if (ret)
+			MSM_BUS_ERR("Failed to set limiter for %d", rule->id);
+	}
+
+	return ret;
+}
+
+static uint64_t get_node_aggab(struct msm_bus_node_device_type *bus_dev)
+{
+	int i;
+	int ctx;
+	uint64_t max_agg_ab = 0;
+	uint64_t agg_ab = 0;
+
+	for (ctx = 0; ctx < NUM_CTX; ctx++) {
+		for (i = 0; i < bus_dev->num_lnodes; i++)
+			agg_ab += bus_dev->lnode_list[i].lnode_ab[ctx];
+
+		if (bus_dev->node_info->num_qports > 1)
+			agg_ab = msm_bus_div64(bus_dev->node_info->num_qports,
+							agg_ab);
+
+		max_agg_ab = max(max_agg_ab, agg_ab);
+	}
+
+	return max_agg_ab;
+}
+
+static uint64_t get_node_ib(struct msm_bus_node_device_type *bus_dev)
+{
+	int i;
+	int ctx;
+	uint64_t max_ib = 0;
+
+	for (ctx = 0; ctx < NUM_CTX; ctx++) {
+		for (i = 0; i < bus_dev->num_lnodes; i++)
+			max_ib = max(max_ib,
+				bus_dev->lnode_list[i].lnode_ib[ctx]);
+	}
+	return max_ib;
+}
+
+static int update_path(int src, int dest, uint64_t req_ib, uint64_t req_bw,
+			uint64_t cur_ib, uint64_t cur_bw, int src_idx, int ctx)
+{
+	struct device *src_dev = NULL;
+	struct device *next_dev = NULL;
+	struct link_node *lnode = NULL;
+	struct msm_bus_node_device_type *dev_info = NULL;
+	int curr_idx;
+	int ret = 0;
+	int *dirty_nodes = NULL;
+	int num_dirty = 0;
+	struct rule_update_path_info *rule_node;
+	bool rules_registered = msm_rule_are_rules_registered();
+
+	src_dev = bus_find_device(&msm_bus_type, NULL,
+				(void *) &src,
+				msm_bus_device_match_adhoc);
+
+	if (!src_dev) {
+		MSM_BUS_ERR("%s: Can't find source device %d", __func__, src);
+		ret = -ENODEV;
+		goto exit_update_path;
+	}
+
+	next_dev = src_dev;
+
+	if (src_idx < 0) {
+		MSM_BUS_ERR("%s: Invalid lnode idx %d", __func__, src_idx);
+		ret = -ENXIO;
+		goto exit_update_path;
+	}
+	curr_idx = src_idx;
+
+	INIT_LIST_HEAD(&input_list);
+	INIT_LIST_HEAD(&apply_list);
+
+	while (next_dev) {
+		dev_info = next_dev->platform_data;
+
+		if (curr_idx >= dev_info->num_lnodes) {
+			MSM_BUS_ERR("%s: Invalid lnode Idx %d num lnodes %d",
+			 __func__, curr_idx, dev_info->num_lnodes);
+			ret = -ENXIO;
+			goto exit_update_path;
+		}
+
+		lnode = &dev_info->lnode_list[curr_idx];
+		lnode->lnode_ib[ctx] = req_ib;
+		lnode->lnode_ab[ctx] = req_bw;
+
+		dev_info->cur_clk_hz[ctx] = arbitrate_bus_req(dev_info, ctx);
+
+		/* Start updating the clocks at the first hop.
+		 * Its ok to figure out the aggregated
+		 * request at this node.
+		 */
+		if (src_dev != next_dev) {
+			ret = msm_bus_update_clks(dev_info, ctx, &dirty_nodes,
+								&num_dirty);
+			if (ret) {
+				MSM_BUS_ERR("%s: Failed to update clks dev %d",
+					__func__, dev_info->node_info->id);
+				goto exit_update_path;
+			}
+		}
+
+		ret = msm_bus_update_bw(dev_info, ctx, req_bw, &dirty_nodes,
+								&num_dirty);
+		if (ret) {
+			MSM_BUS_ERR("%s: Failed to update bw dev %d",
+				__func__, dev_info->node_info->id);
+			goto exit_update_path;
+		}
+
+		if (rules_registered) {
+			rule_node = &dev_info->node_info->rule;
+			rule_node->id = dev_info->node_info->id;
+			rule_node->ib = get_node_ib(dev_info);
+			rule_node->ab = get_node_aggab(dev_info);
+			rule_node->clk = max(dev_info->cur_clk_hz[ACTIVE_CTX],
+						dev_info->cur_clk_hz[DUAL_CTX]);
+			list_add_tail(&rule_node->link, &input_list);
+		}
+
+		next_dev = lnode->next_dev;
+		curr_idx = lnode->next;
+	}
+
+	if (rules_registered) {
+		msm_rules_update_path(&input_list, &apply_list);
+		msm_bus_apply_rules(&apply_list, false);
+	}
+
+	msm_bus_commit_data(dirty_nodes, ctx, num_dirty);
+
+	if (rules_registered) {
+		msm_bus_apply_rules(&apply_list, true);
+		del_inp_list(&input_list);
+		del_op_list(&apply_list);
+	}
+exit_update_path:
+	return ret;
+}
+
+static int remove_path(int src, int dst, uint64_t cur_ib, uint64_t cur_ab,
+				int src_idx, int active_only)
+{
+	struct device *src_dev = NULL;
+	struct device *next_dev = NULL;
+	struct link_node *lnode = NULL;
+	struct msm_bus_node_device_type *dev_info = NULL;
+	int ret = 0;
+	int cur_idx = src_idx;
+	int next_idx;
+
+	/* Update the current path to zero out all request from
+	 * this cient on all paths
+	 */
+
+	ret = update_path(src, dst, 0, 0, cur_ib, cur_ab, src_idx,
+							active_only);
+	if (ret) {
+		MSM_BUS_ERR("%s: Error zeroing out path ctx %d",
+					__func__, ACTIVE_CTX);
+		goto exit_remove_path;
+	}
+
+	src_dev = bus_find_device(&msm_bus_type, NULL,
+				(void *) &src,
+				msm_bus_device_match_adhoc);
+	if (!src_dev) {
+		MSM_BUS_ERR("%s: Can't find source device %d", __func__, src);
+		ret = -ENODEV;
+		goto exit_remove_path;
+	}
+
+	next_dev = src_dev;
+
+	while (next_dev) {
+		dev_info = next_dev->platform_data;
+		lnode = &dev_info->lnode_list[cur_idx];
+		next_idx = lnode->next;
+		next_dev = lnode->next_dev;
+		remove_lnode(dev_info, cur_idx);
+		cur_idx = next_idx;
+	}
+
+exit_remove_path:
+	return ret;
+}
+
+static void getpath_debug(int src, int curr, int active_only)
+{
+	struct device *dev_node;
+	struct device *dev_it;
+	unsigned int hop = 1;
+	int idx;
+	struct msm_bus_node_device_type *devinfo;
+	int i;
+
+	dev_node = bus_find_device(&msm_bus_type, NULL,
+				(void *) &src,
+				msm_bus_device_match_adhoc);
+
+	if (!dev_node) {
+		MSM_BUS_ERR("SRC NOT FOUND %d", src);
+		return;
+	}
+
+	idx = curr;
+	devinfo = dev_node->platform_data;
+	dev_it = dev_node;
+
+	MSM_BUS_ERR("Route list Src %d", src);
+	while (dev_it) {
+		struct msm_bus_node_device_type *busdev =
+			devinfo->node_info->bus_device->platform_data;
+
+		MSM_BUS_ERR("Hop[%d] at Device %d ctx %d", hop,
+					devinfo->node_info->id, active_only);
+
+		for (i = 0; i < NUM_CTX; i++) {
+			MSM_BUS_ERR("dev info sel ib %llu",
+						devinfo->cur_clk_hz[i]);
+			MSM_BUS_ERR("dev info sel ab %llu",
+						devinfo->node_ab.ab[i]);
+		}
+
+		dev_it = devinfo->lnode_list[idx].next_dev;
+		idx = devinfo->lnode_list[idx].next;
+		if (dev_it)
+			devinfo = dev_it->platform_data;
+
+		MSM_BUS_ERR("Bus Device %d", busdev->node_info->id);
+		MSM_BUS_ERR("Bus Clock %llu", busdev->clk[active_only].rate);
+
+		if (idx < 0)
+			break;
+		hop++;
+	}
+}
+
+static void unregister_client_adhoc(uint32_t cl)
+{
+	int i;
+	struct msm_bus_scale_pdata *pdata;
+	int lnode, src, curr, dest;
+	uint64_t  cur_clk, cur_bw;
+	struct msm_bus_client *client;
+
+	mutex_lock(&msm_bus_adhoc_lock);
+	if (!cl) {
+		MSM_BUS_ERR("%s: Null cl handle passed unregister\n",
+				__func__);
+		goto exit_unregister_client;
+	}
+	client = handle_list.cl_list[cl];
+	pdata = client->pdata;
+	if (!pdata) {
+		MSM_BUS_ERR("%s: Null pdata passed to unregister\n",
+				__func__);
+		goto exit_unregister_client;
+	}
+
+	curr = client->curr;
+	if (curr >= pdata->num_usecases) {
+		MSM_BUS_ERR("Invalid index Defaulting curr to 0");
+		curr = 0;
+	}
+
+	MSM_BUS_DBG("%s: Unregistering client %p", __func__, client);
+
+	for (i = 0; i < pdata->usecase->num_paths; i++) {
+		src = client->pdata->usecase[curr].vectors[i].src;
+		dest = client->pdata->usecase[curr].vectors[i].dst;
+
+		lnode = client->src_pnode[i];
+		cur_clk = client->pdata->usecase[curr].vectors[i].ib;
+		cur_bw = client->pdata->usecase[curr].vectors[i].ab;
+		remove_path(src, dest, cur_clk, cur_bw, lnode,
+						pdata->active_only);
+	}
+	msm_bus_dbg_client_data(client->pdata, MSM_BUS_DBG_UNREGISTER, cl);
+	kfree(client->src_pnode);
+	kfree(client);
+	handle_list.cl_list[cl] = NULL;
+exit_unregister_client:
+	mutex_unlock(&msm_bus_adhoc_lock);
+	return;
+}
+
+static int alloc_handle_lst(int size)
+{
+	int ret = 0;
+	struct msm_bus_client **t_cl_list;
+
+	if (!handle_list.num_entries) {
+		t_cl_list = kzalloc(sizeof(struct msm_bus_client *)
+			* NUM_CL_HANDLES, GFP_KERNEL);
+		if (ZERO_OR_NULL_PTR(t_cl_list)) {
+			ret = -ENOMEM;
+			MSM_BUS_ERR("%s: Failed to allocate handles list",
+								__func__);
+			goto exit_alloc_handle_lst;
+		}
+		handle_list.cl_list = t_cl_list;
+		handle_list.num_entries += NUM_CL_HANDLES;
+	} else {
+		t_cl_list = krealloc(handle_list.cl_list,
+				sizeof(struct msm_bus_client *) *
+				handle_list.num_entries + NUM_CL_HANDLES,
+				GFP_KERNEL);
+		if (ZERO_OR_NULL_PTR(t_cl_list)) {
+			ret = -ENOMEM;
+			MSM_BUS_ERR("%s: Failed to allocate handles list",
+								__func__);
+			goto exit_alloc_handle_lst;
+		}
+
+		memset(&handle_list.cl_list[handle_list.num_entries], 0,
+			NUM_CL_HANDLES * sizeof(struct msm_bus_client *));
+		handle_list.num_entries += NUM_CL_HANDLES;
+		handle_list.cl_list = t_cl_list;
+	}
+exit_alloc_handle_lst:
+	return ret;
+}
+
+static uint32_t gen_handle(struct msm_bus_client *client)
+{
+	uint32_t handle = 0;
+	int i;
+	int ret = 0;
+
+	for (i = 0; i < handle_list.num_entries; i++) {
+		if (i && !handle_list.cl_list[i]) {
+			handle = i;
+			break;
+		}
+	}
+
+	if (!handle) {
+		ret = alloc_handle_lst(NUM_CL_HANDLES);
+
+		if (ret) {
+			MSM_BUS_ERR("%s: Failed to allocate handle list",
+							__func__);
+			goto exit_gen_handle;
+		}
+		handle = i + 1;
+	}
+	handle_list.cl_list[handle] = client;
+exit_gen_handle:
+	return handle;
+}
+
+static uint32_t register_client_adhoc(struct msm_bus_scale_pdata *pdata)
+{
+	int src, dest;
+	int i;
+	struct msm_bus_client *client = NULL;
+	int *lnode;
+	uint32_t handle = 0;
+
+	mutex_lock(&msm_bus_adhoc_lock);
+	client = kzalloc(sizeof(struct msm_bus_client), GFP_KERNEL);
+	if (!client) {
+		MSM_BUS_ERR("%s: Error allocating client data", __func__);
+		goto exit_register_client;
+	}
+	client->pdata = pdata;
+
+	lnode = kzalloc(pdata->usecase->num_paths * sizeof(int), GFP_KERNEL);
+	if (ZERO_OR_NULL_PTR(lnode)) {
+		MSM_BUS_ERR("%s: Error allocating pathnode ptr!", __func__);
+		goto exit_register_client;
+	}
+	client->src_pnode = lnode;
+
+	for (i = 0; i < pdata->usecase->num_paths; i++) {
+		src = pdata->usecase->vectors[i].src;
+		dest = pdata->usecase->vectors[i].dst;
+
+		if ((src < 0) || (dest < 0)) {
+			MSM_BUS_ERR("%s:Invalid src/dst.src %d dest %d",
+				__func__, src, dest);
+			goto exit_register_client;
+		}
+
+		lnode[i] = getpath(src, dest);
+		if (lnode[i] < 0) {
+			MSM_BUS_ERR("%s:Failed to find path.src %d dest %d",
+				__func__, src, dest);
+			goto exit_register_client;
+		}
+	}
+
+	handle = gen_handle(client);
+	msm_bus_dbg_client_data(client->pdata, MSM_BUS_DBG_REGISTER,
+					handle);
+	MSM_BUS_DBG("%s:Client handle %d %s", __func__, handle,
+						client->pdata->name);
+exit_register_client:
+	mutex_unlock(&msm_bus_adhoc_lock);
+	return handle;
+}
+
+static int update_request_adhoc(uint32_t cl, unsigned int index)
+{
+	int i, ret = 0;
+	struct msm_bus_scale_pdata *pdata;
+	int lnode, src, curr, dest;
+	uint64_t req_clk, req_bw, curr_clk, curr_bw;
+	struct msm_bus_client *client;
+	const char *test_cl = "Null";
+	bool log_transaction = false;
+
+	mutex_lock(&msm_bus_adhoc_lock);
+
+	if (!cl) {
+		MSM_BUS_ERR("%s: Invalid client handle %d", __func__, cl);
+		ret = -ENXIO;
+		goto exit_update_request;
+	}
+
+	client = handle_list.cl_list[cl];
+	pdata = client->pdata;
+	if (!pdata) {
+		MSM_BUS_ERR("%s: Client data Null.[client didn't register]",
+				__func__);
+		ret = -ENXIO;
+		goto exit_update_request;
+	}
+
+	if (index >= pdata->num_usecases) {
+		MSM_BUS_ERR("Client %u passed invalid index: %d\n",
+			cl, index);
+		ret = -ENXIO;
+		goto exit_update_request;
+	}
+
+	if (client->curr == index) {
+		MSM_BUS_DBG("%s: Not updating client request idx %d unchanged",
+				__func__, index);
+		goto exit_update_request;
+	}
+
+	curr = client->curr;
+	client->curr = index;
+
+	if (!strcmp(test_cl, pdata->name))
+		log_transaction = true;
+
+	MSM_BUS_DBG("%s: cl: %u index: %d curr: %d num_paths: %d\n", __func__,
+		cl, index, client->curr, client->pdata->usecase->num_paths);
+
+	for (i = 0; i < pdata->usecase->num_paths; i++) {
+		src = client->pdata->usecase[index].vectors[i].src;
+		dest = client->pdata->usecase[index].vectors[i].dst;
+
+		lnode = client->src_pnode[i];
+		req_clk = client->pdata->usecase[index].vectors[i].ib;
+		req_bw = client->pdata->usecase[index].vectors[i].ab;
+		if (curr < 0) {
+			curr_clk = 0;
+			curr_bw = 0;
+		} else {
+			curr_clk = client->pdata->usecase[curr].vectors[i].ib;
+			curr_bw = client->pdata->usecase[curr].vectors[i].ab;
+			MSM_BUS_DBG("%s:ab: %llu ib: %llu\n", __func__,
+					curr_bw, curr_clk);
+		}
+
+		ret = update_path(src, dest, req_clk, req_bw,
+				curr_clk, curr_bw, lnode, pdata->active_only);
+
+		if (ret) {
+			MSM_BUS_ERR("%s: Update path failed! %d ctx %d\n",
+					__func__, ret, ACTIVE_CTX);
+			goto exit_update_request;
+		}
+
+		if (log_transaction)
+			getpath_debug(src, lnode, pdata->active_only);
+	}
+	msm_bus_dbg_client_data(client->pdata, index , cl);
+exit_update_request:
+	mutex_unlock(&msm_bus_adhoc_lock);
+	return ret;
+}
+
+/**
+ *  msm_bus_arb_setops_adhoc() : Setup the bus arbitration ops
+ *  @ arb_ops: pointer to the arb ops.
+ */
+void msm_bus_arb_setops_adhoc(struct msm_bus_arb_ops *arb_ops)
+{
+	arb_ops->register_client = register_client_adhoc;
+	arb_ops->update_request = update_request_adhoc;
+	arb_ops->unregister_client = unregister_client_adhoc;
+}
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_bimc.c
@@ -0,0 +1,2112 @@
+/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "AXI: BIMC: %s(): " fmt, __func__
+
+#include <linux/slab.h>
+#include <linux/io.h>
+#include "msm-bus-board.h"
+#include "msm_bus_core.h"
+#include "msm_bus_bimc.h"
+#include "msm_bus_adhoc.h"
+#include <trace/events/trace_msm_bus.h>
+
+enum msm_bus_bimc_slave_block {
+	SLAVE_BLOCK_RESERVED = 0,
+	SLAVE_BLOCK_SLAVE_WAY,
+	SLAVE_BLOCK_XPU,
+	SLAVE_BLOCK_ARBITER,
+	SLAVE_BLOCK_SCMO,
+};
+
+enum bke_sw {
+	BKE_OFF = 0,
+	BKE_ON = 1,
+};
+
+/* M_Generic */
+
+#define M_REG_BASE(b)		((b) + 0x00008000)
+
+#define M_COMPONENT_INFO_ADDR(b, n) \
+		(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000000)
+enum bimc_m_component_info {
+	M_COMPONENT_INFO_RMSK		= 0xffffff,
+	M_COMPONENT_INFO_INSTANCE_BMSK	= 0xff0000,
+	M_COMPONENT_INFO_INSTANCE_SHFT	= 0x10,
+	M_COMPONENT_INFO_SUB_TYPE_BMSK	= 0xff00,
+	M_COMPONENT_INFO_SUB_TYPE_SHFT	= 0x8,
+	M_COMPONENT_INFO_TYPE_BMSK	= 0xff,
+	M_COMPONENT_INFO_TYPE_SHFT	= 0x0,
+};
+
+#define M_CONFIG_INFO_0_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000020)
+enum bimc_m_config_info_0 {
+	M_CONFIG_INFO_0_RMSK			= 0xff00ffff,
+	M_CONFIG_INFO_0_SYNC_MODE_BMSK		= 0xff000000,
+	M_CONFIG_INFO_0_SYNC_MODE_SHFT		= 0x18,
+	M_CONFIG_INFO_0_CONNECTION_TYPE_BMSK	= 0xff00,
+	M_CONFIG_INFO_0_CONNECTION_TYPE_SHFT	= 0x8,
+	M_CONFIG_INFO_0_FUNC_BMSK		= 0xff,
+	M_CONFIG_INFO_0_FUNC_SHFT		= 0x0,
+};
+
+#define M_CONFIG_INFO_1_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000030)
+enum bimc_m_config_info_1 {
+	M_CONFIG_INFO_1_RMSK			= 0xffffffff,
+	M_CONFIG_INFO_1_SWAY_CONNECTIVITY_BMSK	= 0xffffffff,
+	M_CONFIG_INFO_1_SWAY_CONNECTIVITY_SHFT	= 0x0,
+};
+
+#define M_CONFIG_INFO_2_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000040)
+enum bimc_m_config_info_2 {
+	M_CONFIG_INFO_2_RMSK			= 0xffffffff,
+	M_CONFIG_INFO_2_M_DATA_WIDTH_BMSK	= 0xffff0000,
+	M_CONFIG_INFO_2_M_DATA_WIDTH_SHFT	= 0x10,
+	M_CONFIG_INFO_2_M_TID_WIDTH_BMSK	= 0xff00,
+	M_CONFIG_INFO_2_M_TID_WIDTH_SHFT	= 0x8,
+	M_CONFIG_INFO_2_M_MID_WIDTH_BMSK	= 0xff,
+	M_CONFIG_INFO_2_M_MID_WIDTH_SHFT	= 0x0,
+};
+
+#define M_CONFIG_INFO_3_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000050)
+enum bimc_m_config_info_3 {
+	M_CONFIG_INFO_3_RMSK			= 0xffffffff,
+	M_CONFIG_INFO_3_RCH_DEPTH_BMSK		= 0xff000000,
+	M_CONFIG_INFO_3_RCH_DEPTH_SHFT		= 0x18,
+	M_CONFIG_INFO_3_BCH_DEPTH_BMSK		= 0xff0000,
+	M_CONFIG_INFO_3_BCH_DEPTH_SHFT		= 0x10,
+	M_CONFIG_INFO_3_WCH_DEPTH_BMSK		= 0xff00,
+	M_CONFIG_INFO_3_WCH_DEPTH_SHFT		= 0x8,
+	M_CONFIG_INFO_3_ACH_DEPTH_BMSK		= 0xff,
+	M_CONFIG_INFO_3_ACH_DEPTH_SHFT		= 0x0,
+};
+
+#define M_CONFIG_INFO_4_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000060)
+enum bimc_m_config_info_4 {
+	M_CONFIG_INFO_4_RMSK			= 0xffff,
+	M_CONFIG_INFO_4_REORDER_BUF_DEPTH_BMSK	= 0xff00,
+	M_CONFIG_INFO_4_REORDER_BUF_DEPTH_SHFT	= 0x8,
+	M_CONFIG_INFO_4_REORDER_TABLE_DEPTH_BMSK	= 0xff,
+	M_CONFIG_INFO_4_REORDER_TABLE_DEPTH_SHFT	= 0x0,
+};
+
+#define M_CONFIG_INFO_5_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000070)
+enum bimc_m_config_info_5 {
+	M_CONFIG_INFO_5_RMSK			= 0x111,
+	M_CONFIG_INFO_5_MP2ARB_PIPELINE_EN_BMSK	= 0x100,
+	M_CONFIG_INFO_5_MP2ARB_PIPELINE_EN_SHFT	= 0x8,
+	M_CONFIG_INFO_5_MPBUF_PIPELINE_EN_BMSK	= 0x10,
+	M_CONFIG_INFO_5_MPBUF_PIPELINE_EN_SHFT	= 0x4,
+	M_CONFIG_INFO_5_M2MP_PIPELINE_EN_BMSK	= 0x1,
+	M_CONFIG_INFO_5_M2MP_PIPELINE_EN_SHFT	= 0x0,
+};
+
+#define M_INT_STATUS_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000100)
+enum bimc_m_int_status {
+	M_INT_STATUS_RMSK			= 0x3,
+};
+
+#define M_INT_CLR_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000108)
+enum bimc_m_int_clr {
+	M_INT_CLR_RMSK			= 0x3,
+};
+
+#define M_INT_EN_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x0000010c)
+enum bimc_m_int_en {
+	M_INT_EN_RMSK			= 0x3,
+};
+
+#define M_CLK_CTRL_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000200)
+enum bimc_m_clk_ctrl {
+	M_CLK_CTRL_RMSK				= 0x3,
+	M_CLK_CTRL_MAS_CLK_GATING_EN_BMSK	= 0x2,
+	M_CLK_CTRL_MAS_CLK_GATING_EN_SHFT	= 0x1,
+	M_CLK_CTRL_CORE_CLK_GATING_EN_BMSK	= 0x1,
+	M_CLK_CTRL_CORE_CLK_GATING_EN_SHFT	= 0x0,
+};
+
+#define M_MODE_ADDR(b, n) \
+		(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000210)
+enum bimc_m_mode {
+	M_MODE_RMSK				= 0xf0000011,
+	M_MODE_WR_GATHER_BEATS_BMSK		= 0xf0000000,
+	M_MODE_WR_GATHER_BEATS_SHFT		= 0x1c,
+	M_MODE_NARROW_WR_BMSK			= 0x10,
+	M_MODE_NARROW_WR_SHFT			= 0x4,
+	M_MODE_ORDERING_MODEL_BMSK		= 0x1,
+	M_MODE_ORDERING_MODEL_SHFT		= 0x0,
+};
+
+#define M_PRIOLVL_OVERRIDE_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000230)
+enum bimc_m_priolvl_override {
+	M_PRIOLVL_OVERRIDE_RMSK			= 0x301,
+	M_PRIOLVL_OVERRIDE_BMSK			= 0x300,
+	M_PRIOLVL_OVERRIDE_SHFT			= 0x8,
+	M_PRIOLVL_OVERRIDE_OVERRIDE_PRIOLVL_BMSK	= 0x1,
+	M_PRIOLVL_OVERRIDE_OVERRIDE_PRIOLVL_SHFT	= 0x0,
+};
+
+#define M_RD_CMD_OVERRIDE_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000240)
+enum bimc_m_read_command_override {
+	M_RD_CMD_OVERRIDE_RMSK			= 0x3071f7f,
+	M_RD_CMD_OVERRIDE_AREQPRIO_BMSK		= 0x3000000,
+	M_RD_CMD_OVERRIDE_AREQPRIO_SHFT		= 0x18,
+	M_RD_CMD_OVERRIDE_AMEMTYPE_BMSK		= 0x70000,
+	M_RD_CMD_OVERRIDE_AMEMTYPE_SHFT		= 0x10,
+	M_RD_CMD_OVERRIDE_ATRANSIENT_BMSK		= 0x1000,
+	M_RD_CMD_OVERRIDE_ATRANSIENT_SHFT		= 0xc,
+	M_RD_CMD_OVERRIDE_ASHARED_BMSK		= 0x800,
+	M_RD_CMD_OVERRIDE_ASHARED_SHFT		= 0xb,
+	M_RD_CMD_OVERRIDE_AREDIRECT_BMSK		= 0x400,
+	M_RD_CMD_OVERRIDE_AREDIRECT_SHFT		= 0xa,
+	M_RD_CMD_OVERRIDE_AOOO_BMSK			= 0x200,
+	M_RD_CMD_OVERRIDE_AOOO_SHFT			= 0x9,
+	M_RD_CMD_OVERRIDE_AINNERSHARED_BMSK		= 0x100,
+	M_RD_CMD_OVERRIDE_AINNERSHARED_SHFT		= 0x8,
+	M_RD_CMD_OVERRIDE_OVERRIDE_AREQPRIO_BMSK	= 0x40,
+	M_RD_CMD_OVERRIDE_OVERRIDE_AREQPRIO_SHFT	= 0x6,
+	M_RD_CMD_OVERRIDE_OVERRIDE_ATRANSIENT_BMSK	= 0x20,
+	M_RD_CMD_OVERRIDE_OVERRIDE_ATRANSIENT_SHFT	= 0x5,
+	M_RD_CMD_OVERRIDE_OVERRIDE_AMEMTYPE_BMSK	= 0x10,
+	M_RD_CMD_OVERRIDE_OVERRIDE_AMEMTYPE_SHFT	= 0x4,
+	M_RD_CMD_OVERRIDE_OVERRIDE_ASHARED_BMSK	= 0x8,
+	M_RD_CMD_OVERRIDE_OVERRIDE_ASHARED_SHFT	= 0x3,
+	M_RD_CMD_OVERRIDE_OVERRIDE_AREDIRECT_BMSK	= 0x4,
+	M_RD_CMD_OVERRIDE_OVERRIDE_AREDIRECT_SHFT	= 0x2,
+	M_RD_CMD_OVERRIDE_OVERRIDE_AOOO_BMSK		= 0x2,
+	M_RD_CMD_OVERRIDE_OVERRIDE_AOOO_SHFT		= 0x1,
+	M_RD_CMD_OVERRIDE_OVERRIDE_AINNERSHARED_BMSK	= 0x1,
+	M_RD_CMD_OVERRIDE_OVERRIDE_AINNERSHARED_SHFT	= 0x0,
+};
+
+#define M_WR_CMD_OVERRIDE_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000250)
+enum bimc_m_write_command_override {
+	M_WR_CMD_OVERRIDE_RMSK			= 0x3071f7f,
+	M_WR_CMD_OVERRIDE_AREQPRIO_BMSK		= 0x3000000,
+	M_WR_CMD_OVERRIDE_AREQPRIO_SHFT		= 0x18,
+	M_WR_CMD_OVERRIDE_AMEMTYPE_BMSK		= 0x70000,
+	M_WR_CMD_OVERRIDE_AMEMTYPE_SHFT		= 0x10,
+	M_WR_CMD_OVERRIDE_ATRANSIENT_BMSK	= 0x1000,
+	M_WR_CMD_OVERRIDE_ATRANSIENT_SHFT	= 0xc,
+	M_WR_CMD_OVERRIDE_ASHARED_BMSK		= 0x800,
+	M_WR_CMD_OVERRIDE_ASHARED_SHFT		= 0xb,
+	M_WR_CMD_OVERRIDE_AREDIRECT_BMSK		= 0x400,
+	M_WR_CMD_OVERRIDE_AREDIRECT_SHFT		= 0xa,
+	M_WR_CMD_OVERRIDE_AOOO_BMSK			= 0x200,
+	M_WR_CMD_OVERRIDE_AOOO_SHFT			= 0x9,
+	M_WR_CMD_OVERRIDE_AINNERSHARED_BMSK		= 0x100,
+	M_WR_CMD_OVERRIDE_AINNERSHARED_SHFT		= 0x8,
+	M_WR_CMD_OVERRIDE_OVERRIDE_AREQPRIO_BMSK	= 0x40,
+	M_WR_CMD_OVERRIDE_OVERRIDE_AREQPRIO_SHFT	= 0x6,
+	M_WR_CMD_OVERRIDE_OVERRIDE_ATRANSIENT_BMSK	= 0x20,
+	M_WR_CMD_OVERRIDE_OVERRIDE_ATRANSIENT_SHFT	= 0x5,
+	M_WR_CMD_OVERRIDE_OVERRIDE_AMEMTYPE_BMSK	= 0x10,
+	M_WR_CMD_OVERRIDE_OVERRIDE_AMEMTYPE_SHFT	= 0x4,
+	M_WR_CMD_OVERRIDE_OVERRIDE_ASHARED_BMSK	= 0x8,
+	M_WR_CMD_OVERRIDE_OVERRIDE_ASHARED_SHFT	= 0x3,
+	M_WR_CMD_OVERRIDE_OVERRIDE_AREDIRECT_BMSK	= 0x4,
+	M_WR_CMD_OVERRIDE_OVERRIDE_AREDIRECT_SHFT	= 0x2,
+	M_WR_CMD_OVERRIDE_OVERRIDE_AOOO_BMSK	= 0x2,
+	M_WR_CMD_OVERRIDE_OVERRIDE_AOOO_SHFT	= 0x1,
+	M_WR_CMD_OVERRIDE_OVERRIDE_AINNERSHARED_BMSK	= 0x1,
+	M_WR_CMD_OVERRIDE_OVERRIDE_AINNERSHARED_SHFT	= 0x0,
+};
+
+#define M_BKE_EN_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000300)
+enum bimc_m_bke_en {
+	M_BKE_EN_RMSK			= 0x1,
+	M_BKE_EN_EN_BMSK		= 0x1,
+	M_BKE_EN_EN_SHFT		= 0x0,
+};
+
+/* Grant Period registers */
+#define M_BKE_GP_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000304)
+enum bimc_m_bke_grant_period {
+	M_BKE_GP_RMSK		= 0x3ff,
+	M_BKE_GP_GP_BMSK	= 0x3ff,
+	M_BKE_GP_GP_SHFT	= 0x0,
+};
+
+/* Grant count register.
+ * The Grant count register represents a signed 16 bit
+ * value, range 0-0x7fff
+ */
+#define M_BKE_GC_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000308)
+enum bimc_m_bke_grant_count {
+	M_BKE_GC_RMSK			= 0xffff,
+	M_BKE_GC_GC_BMSK		= 0xffff,
+	M_BKE_GC_GC_SHFT		= 0x0,
+};
+
+/* Threshold High Registers */
+#define M_BKE_THH_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000320)
+enum bimc_m_bke_thresh_high {
+	M_BKE_THH_RMSK		= 0xffff,
+	M_BKE_THH_THRESH_BMSK	= 0xffff,
+	M_BKE_THH_THRESH_SHFT	= 0x0,
+};
+
+/* Threshold Medium Registers */
+#define M_BKE_THM_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000324)
+enum bimc_m_bke_thresh_medium {
+	M_BKE_THM_RMSK		= 0xffff,
+	M_BKE_THM_THRESH_BMSK	= 0xffff,
+	M_BKE_THM_THRESH_SHFT	= 0x0,
+};
+
+/* Threshold Low Registers */
+#define M_BKE_THL_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000328)
+enum bimc_m_bke_thresh_low {
+	M_BKE_THL_RMSK			= 0xffff,
+	M_BKE_THL_THRESH_BMSK		= 0xffff,
+	M_BKE_THL_THRESH_SHFT		= 0x0,
+};
+
+#define M_BKE_HEALTH_0_CONFIG_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000340)
+enum bimc_m_bke_health_0 {
+	M_BKE_HEALTH_0_CONFIG_RMSK			= 0x80000303,
+	M_BKE_HEALTH_0_CONFIG_LIMIT_CMDS_BMSK		= 0x80000000,
+	M_BKE_HEALTH_0_CONFIG_LIMIT_CMDS_SHFT		= 0x1f,
+	M_BKE_HEALTH_0_CONFIG_AREQPRIO_BMSK		= 0x300,
+	M_BKE_HEALTH_0_CONFIG_AREQPRIO_SHFT		= 0x8,
+	M_BKE_HEALTH_0_CONFIG_PRIOLVL_BMSK		= 0x3,
+	M_BKE_HEALTH_0_CONFIG_PRIOLVL_SHFT		= 0x0,
+};
+
+#define M_BKE_HEALTH_1_CONFIG_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000344)
+enum bimc_m_bke_health_1 {
+	M_BKE_HEALTH_1_CONFIG_RMSK			= 0x80000303,
+	M_BKE_HEALTH_1_CONFIG_LIMIT_CMDS_BMSK		= 0x80000000,
+	M_BKE_HEALTH_1_CONFIG_LIMIT_CMDS_SHFT		= 0x1f,
+	M_BKE_HEALTH_1_CONFIG_AREQPRIO_BMSK		= 0x300,
+	M_BKE_HEALTH_1_CONFIG_AREQPRIO_SHFT		= 0x8,
+	M_BKE_HEALTH_1_CONFIG_PRIOLVL_BMSK		= 0x3,
+	M_BKE_HEALTH_1_CONFIG_PRIOLVL_SHFT		= 0x0,
+};
+
+#define M_BKE_HEALTH_2_CONFIG_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000348)
+enum bimc_m_bke_health_2 {
+	M_BKE_HEALTH_2_CONFIG_RMSK			= 0x80000303,
+	M_BKE_HEALTH_2_CONFIG_LIMIT_CMDS_BMSK		= 0x80000000,
+	M_BKE_HEALTH_2_CONFIG_LIMIT_CMDS_SHFT		= 0x1f,
+	M_BKE_HEALTH_2_CONFIG_AREQPRIO_BMSK		= 0x300,
+	M_BKE_HEALTH_2_CONFIG_AREQPRIO_SHFT		= 0x8,
+	M_BKE_HEALTH_2_CONFIG_PRIOLVL_BMSK		= 0x3,
+	M_BKE_HEALTH_2_CONFIG_PRIOLVL_SHFT		= 0x0,
+};
+
+#define M_BKE_HEALTH_3_CONFIG_ADDR(b, n) \
+	(M_REG_BASE(b) + (0x4000 * (n)) + 0x0000034c)
+enum bimc_m_bke_health_3 {
+	M_BKE_HEALTH_3_CONFIG_RMSK			= 0x303,
+	M_BKE_HEALTH_3_CONFIG_AREQPRIO_BMSK	= 0x300,
+	M_BKE_HEALTH_3_CONFIG_AREQPRIO_SHFT	= 0x8,
+	M_BKE_HEALTH_3_CONFIG_PRIOLVL_BMSK		= 0x3,
+	M_BKE_HEALTH_3_CONFIG_PRIOLVL_SHFT		= 0x0,
+};
+
+#define M_BUF_STATUS_ADDR(b, n) \
+		(M_REG_BASE(b) + (0x4000 * (n)) + 0x00000400)
+enum bimc_m_buf_status {
+	M_BUF_STATUS_RMSK			= 0xf03f030,
+	M_BUF_STATUS_RCH_DATA_WR_FULL_BMSK	= 0x8000000,
+	M_BUF_STATUS_RCH_DATA_WR_FULL_SHFT	= 0x1b,
+	M_BUF_STATUS_RCH_DATA_WR_EMPTY_BMSK	= 0x4000000,
+	M_BUF_STATUS_RCH_DATA_WR_EMPTY_SHFT	= 0x1a,
+	M_BUF_STATUS_RCH_CTRL_WR_FULL_BMSK	= 0x2000000,
+	M_BUF_STATUS_RCH_CTRL_WR_FULL_SHFT	= 0x19,
+	M_BUF_STATUS_RCH_CTRL_WR_EMPTY_BMSK	= 0x1000000,
+	M_BUF_STATUS_RCH_CTRL_WR_EMPTY_SHFT	= 0x18,
+	M_BUF_STATUS_BCH_WR_FULL_BMSK		= 0x20000,
+	M_BUF_STATUS_BCH_WR_FULL_SHFT		= 0x11,
+	M_BUF_STATUS_BCH_WR_EMPTY_BMSK		= 0x10000,
+	M_BUF_STATUS_BCH_WR_EMPTY_SHFT		= 0x10,
+	M_BUF_STATUS_WCH_DATA_RD_FULL_BMSK	= 0x8000,
+	M_BUF_STATUS_WCH_DATA_RD_FULL_SHFT	= 0xf,
+	M_BUF_STATUS_WCH_DATA_RD_EMPTY_BMSK	= 0x4000,
+	M_BUF_STATUS_WCH_DATA_RD_EMPTY_SHFT	= 0xe,
+	M_BUF_STATUS_WCH_CTRL_RD_FULL_BMSK	= 0x2000,
+	M_BUF_STATUS_WCH_CTRL_RD_FULL_SHFT	= 0xd,
+	M_BUF_STATUS_WCH_CTRL_RD_EMPTY_BMSK	= 0x1000,
+	M_BUF_STATUS_WCH_CTRL_RD_EMPTY_SHFT	= 0xc,
+	M_BUF_STATUS_ACH_RD_FULL_BMSK		= 0x20,
+	M_BUF_STATUS_ACH_RD_FULL_SHFT		= 0x5,
+	M_BUF_STATUS_ACH_RD_EMPTY_BMSK		= 0x10,
+	M_BUF_STATUS_ACH_RD_EMPTY_SHFT		= 0x4,
+};
+/*BIMC Generic */
+
+#define S_REG_BASE(b)	((b) + 0x00048000)
+
+#define S_COMPONENT_INFO_ADDR(b, n) \
+	(S_REG_BASE(b) + (0x8000 * (n)) + 0x00000000)
+enum bimc_s_component_info {
+	S_COMPONENT_INFO_RMSK			= 0xffffff,
+	S_COMPONENT_INFO_INSTANCE_BMSK		= 0xff0000,
+	S_COMPONENT_INFO_INSTANCE_SHFT		= 0x10,
+	S_COMPONENT_INFO_SUB_TYPE_BMSK		= 0xff00,
+	S_COMPONENT_INFO_SUB_TYPE_SHFT		= 0x8,
+	S_COMPONENT_INFO_TYPE_BMSK		= 0xff,
+	S_COMPONENT_INFO_TYPE_SHFT		= 0x0,
+};
+
+#define S_HW_INFO_ADDR(b, n) \
+	(S_REG_BASE(b) + (0x80000 * (n)) + 0x00000010)
+enum bimc_s_hw_info {
+	S_HW_INFO_RMSK				= 0xffffffff,
+	S_HW_INFO_MAJOR_BMSK			= 0xff000000,
+	S_HW_INFO_MAJOR_SHFT			= 0x18,
+	S_HW_INFO_BRANCH_BMSK			= 0xff0000,
+	S_HW_INFO_BRANCH_SHFT			= 0x10,
+	S_HW_INFO_MINOR_BMSK			= 0xff00,
+	S_HW_INFO_MINOR_SHFT			= 0x8,
+	S_HW_INFO_ECO_BMSK			= 0xff,
+	S_HW_INFO_ECO_SHFT			= 0x0,
+};
+
+
+/* S_SCMO_GENERIC */
+
+#define S_SCMO_REG_BASE(b)	((b) + 0x00048000)
+
+#define S_SCMO_CONFIG_INFO_0_ADDR(b, n) \
+		(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000020)
+enum bimc_s_scmo_config_info_0 {
+	S_SCMO_CONFIG_INFO_0_RMSK		= 0xffffffff,
+	S_SCMO_CONFIG_INFO_0_DATA_WIDTH_BMSK	= 0xffff0000,
+	S_SCMO_CONFIG_INFO_0_DATA_WIDTH_SHFT	= 0x10,
+	S_SCMO_CONFIG_INFO_0_TID_WIDTH_BMSK	= 0xff00,
+	S_SCMO_CONFIG_INFO_0_TID_WIDTH_SHFT	= 0x8,
+	S_SCMO_CONFIG_INFO_0_MID_WIDTH_BMSK	= 0xff,
+	S_SCMO_CONFIG_INFO_0_MID_WIDTH_SHFT	= 0x0,
+};
+
+#define S_SCMO_CONFIG_INFO_1_ADDR(b, n) \
+		(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000030)
+enum bimc_s_scmo_config_info_1 {
+	S_SCMO_CONFIG_INFO_1_RMSK			= 0xffffffff,
+	S_SCMO_CONFIG_INFO_1_MPORT_CONNECTIVITY_BMSK	= 0xffffffff,
+	S_SCMO_CONFIG_INFO_1_MPORT_CONNECTIVITY_SHFT	= 0x0,
+};
+
+#define S_SCMO_CONFIG_INFO_2_ADDR(b, n) \
+		(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000040)
+enum bimc_s_scmo_config_info_2 {
+	S_SCMO_CONFIG_INFO_2_RMSK			= 0xff00ff,
+	S_SCMO_CONFIG_INFO_2_NUM_GLOBAL_MONS_BMSK	= 0xff0000,
+	S_SCMO_CONFIG_INFO_2_NUM_GLOBAL_MONS_SHFT	= 0x10,
+	S_SCMO_CONFIG_INFO_2_VMID_WIDTH_BMSK	= 0xff,
+	S_SCMO_CONFIG_INFO_2_VMID_WIDTH_SHFT	= 0x0,
+};
+
+#define S_SCMO_CONFIG_INFO_3_ADDR(b, n) \
+		(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000050)
+enum bimc_s_scmo_config_info_3 {
+	S_SCMO_CONFIG_INFO_3_RMSK			= 0xffffffff,
+	S_SCMO_CONFIG_INFO_3_RCH0_CTRL_DEPTH_BMSK	= 0xff000000,
+	S_SCMO_CONFIG_INFO_3_RCH0_CTRL_DEPTH_SHFT	= 0x18,
+	S_SCMO_CONFIG_INFO_3_RCH0_DEPTH_BMSK		= 0xff0000,
+	S_SCMO_CONFIG_INFO_3_RCH0_DEPTH_SHFT		= 0x10,
+	S_SCMO_CONFIG_INFO_3_BCH_DEPTH_BMSK		= 0xff00,
+	S_SCMO_CONFIG_INFO_3_BCH_DEPTH_SHFT		= 0x8,
+	S_SCMO_CONFIG_INFO_3_WCH_DEPTH_BMSK		= 0xff,
+	S_SCMO_CONFIG_INFO_3_WCH_DEPTH_SHFT		= 0x0,
+};
+
+#define S_SCMO_CONFIG_INFO_4_ADDR(b, n) \
+		(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000060)
+enum bimc_s_scmo_config_info_4 {
+	S_SCMO_CONFIG_INFO_4_RMSK			= 0xffff,
+	S_SCMO_CONFIG_INFO_4_RCH1_CTRL_DEPTH_BMSK	= 0xff00,
+	S_SCMO_CONFIG_INFO_4_RCH1_CTRL_DEPTH_SHFT	= 0x8,
+	S_SCMO_CONFIG_INFO_4_RCH1_DEPTH_BMSK		= 0xff,
+	S_SCMO_CONFIG_INFO_4_RCH1_DEPTH_SHFT		= 0x0,
+};
+
+#define S_SCMO_CONFIG_INFO_5_ADDR(b, n) \
+		(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000070)
+enum bimc_s_scmo_config_info_5 {
+	S_SCMO_CONFIG_INFO_5_RMSK			= 0xffff,
+	S_SCMO_CONFIG_INFO_5_DPE_CQ_DEPTH_BMSK		= 0xff00,
+	S_SCMO_CONFIG_INFO_5_DPE_CQ_DEPTH_SHFT		= 0x8,
+	S_SCMO_CONFIG_INFO_5_DDR_BUS_WIDTH_BMSK		= 0xff,
+	S_SCMO_CONFIG_INFO_5_DDR_BUS_WIDTH_SHFT		= 0x0,
+};
+
+#define S_SCMO_CONFIG_INFO_6_ADDR(b, n) \
+		(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000080)
+enum bimc_s_scmo_config_info_6 {
+	S_SCMO_CONFIG_INFO_6_RMSK			= 0x1111,
+	S_SCMO_CONFIG_INFO_6_WBUFC_PIPE_BMSK		= 0x1000,
+	S_SCMO_CONFIG_INFO_6_WBUFC_PIPE_SHFT		= 0xc,
+	S_SCMO_CONFIG_INFO_6_RDOPT_PIPE_BMSK		= 0x100,
+	S_SCMO_CONFIG_INFO_6_RDOPT_PIPE_SHFT		= 0x8,
+	S_SCMO_CONFIG_INFO_6_ACHAN_INTF_PIPE_BMSK	= 0x10,
+	S_SCMO_CONFIG_INFO_6_ACHAN_INTF_PIPE_SHFT	= 0x4,
+	S_SCMO_CONFIG_INFO_6_ADDR_DECODE_HT_BMSK	= 0x1,
+	S_SCMO_CONFIG_INFO_6_ADDR_DECODE_HT_SHFT	= 0x0,
+};
+
+#define S_SCMO_INT_STATUS_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000100)
+enum bimc_s_scmo_int_status {
+	S_SCMO_INT_STATUS_RMSK			= 0x1,
+	S_SCMO_INT_STATUS_ERR_OCCURED_BMSK	= 0x1,
+	S_SCMO_INT_STATUS_ERR_OCCURED_SHFT	= 0x0,
+};
+
+#define S_SCMO_INT_CLR_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000108)
+enum bimc_s_scmo_int_clr {
+	S_SCMO_INT_CLR_RMSK		= 0x1,
+	S_SCMO_INT_CLR_IRQ_CLR_BMSK	= 0x1,
+	S_SCMO_INT_CLR_IRQ_CLR_SHFT	= 0x0,
+};
+
+#define S_SCMO_INT_EN_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x0000010c)
+enum bimc_s_scmo_int_en {
+	S_SCMO_INT_EN_RMSK		= 0x1,
+	S_SCMO_INT_EN_IRQ_EN_BMSK	= 0x1,
+	S_SCMO_INT_EN_IRQ_EN_SHFT	= 0x0,
+};
+
+#define S_SCMO_ESYN_ADDR_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000120)
+enum bimc_s_scmo_esyn_addr {
+	S_SCMO_ESYN_ADDR_RMSK				= 0xffffffff,
+	S_SCMO_ESYN_ADDR_ESYN_ADDR_ERR_ADDR_BMSK	= 0xffffffff,
+	S_SCMO_ESYN_ADDR_ESYN_ADDR_ERR_ADDR_SHFT	= 0x0,
+};
+
+#define S_SCMO_ESYN_APACKET_0_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000128)
+enum bimc_s_scmo_esyn_apacket_0 {
+	S_SCMO_ESYN_APACKET_0_RMSK			= 0xff1fffff,
+	S_SCMO_ESYN_APACKET_0_ERR_ATID_BMSK		= 0xff000000,
+	S_SCMO_ESYN_APACKET_0_ERR_ATID_SHFT		= 0x18,
+	S_SCMO_ESYN_APACKET_0_ERR_AVMID_BMSK		= 0x1f0000,
+	S_SCMO_ESYN_APACKET_0_ERR_AVMID_SHFT		= 0x10,
+	S_SCMO_ESYN_APACKET_0_ERR_AMID_BMSK		= 0xffff,
+	S_SCMO_ESYN_APACKET_0_ERR_AMID_SHFT		= 0x0,
+};
+
+#define S_SCMO_ESYN_APACKET_1_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x0000012c)
+enum bimc_s_scmo_esyn_apacket_1 {
+	S_SCMO_ESYN_APACKET_1_RMSK			= 0x10ff117,
+	S_SCMO_ESYN_APACKET_1_ERR_CODE_BMSK		= 0x1000000,
+	S_SCMO_ESYN_APACKET_1_ERR_CODE_SHFT		= 0x18,
+	S_SCMO_ESYN_APACKET_1_ERR_ALEN_BMSK		= 0xf0000,
+	S_SCMO_ESYN_APACKET_1_ERR_ALEN_SHFT		= 0x10,
+	S_SCMO_ESYN_APACKET_1_ERR_ASIZE_BMSK		= 0xe000,
+	S_SCMO_ESYN_APACKET_1_ERR_ASIZE_SHFT		= 0xd,
+	S_SCMO_ESYN_APACKET_1_ERR_ABURST_BMSK		= 0x1000,
+	S_SCMO_ESYN_APACKET_1_ERR_ABURST_SHFT		= 0xc,
+	S_SCMO_ESYN_APACKET_1_ERR_AEXCLUSIVE_BMSK	= 0x100,
+	S_SCMO_ESYN_APACKET_1_ERR_AEXCLUSIVE_SHFT	= 0x8,
+	S_SCMO_ESYN_APACKET_1_ERR_APRONTS_BMSK		= 0x10,
+	S_SCMO_ESYN_APACKET_1_ERR_APRONTS_SHFT		= 0x4,
+	S_SCMO_ESYN_APACKET_1_ERR_AOOORD_BMSK		= 0x4,
+	S_SCMO_ESYN_APACKET_1_ERR_AOOORD_SHFT		= 0x2,
+	S_SCMO_ESYN_APACKET_1_ERR_AOOOWR_BMSK		= 0x2,
+	S_SCMO_ESYN_APACKET_1_ERR_AOOOWR_SHFT		= 0x1,
+	S_SCMO_ESYN_APACKET_1_ERR_AWRITE_BMSK		= 0x1,
+	S_SCMO_ESYN_APACKET_1_ERR_AWRITE_SHFT		= 0x0,
+};
+
+#define S_SCMO_CLK_CTRL_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000200)
+enum bimc_s_scmo_clk_ctrl {
+	S_SCMO_CLK_CTRL_RMSK				= 0xffff1111,
+	S_SCMO_CLK_CTRL_PEN_CMD_CG_EN_BMSK		= 0x10000,
+	S_SCMO_CLK_CTRL_PEN_CMD_CG_EN_SHFT		= 0x10,
+	S_SCMO_CLK_CTRL_RCH_CG_EN_BMSK			= 0x1000,
+	S_SCMO_CLK_CTRL_RCH_CG_EN_SHFT			= 0xc,
+	S_SCMO_CLK_CTRL_FLUSH_CG_EN_BMSK		= 0x100,
+	S_SCMO_CLK_CTRL_FLUSH_CG_EN_SHFT		= 0x8,
+	S_SCMO_CLK_CTRL_WCH_CG_EN_BMSK			= 0x10,
+	S_SCMO_CLK_CTRL_WCH_CG_EN_SHFT			= 0x4,
+	S_SCMO_CLK_CTRL_ACH_CG_EN_BMSK			= 0x1,
+	S_SCMO_CLK_CTRL_ACH_CG_EN_SHFT			= 0x0,
+};
+
+#define S_SCMO_SLV_INTERLEAVE_CFG_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000400)
+enum bimc_s_scmo_slv_interleave_cfg {
+	S_SCMO_SLV_INTERLEAVE_CFG_RMSK			= 0xff,
+	S_SCMO_SLV_INTERLEAVE_CFG_INTERLEAVE_CS1_BMSK	= 0x10,
+	S_SCMO_SLV_INTERLEAVE_CFG_INTERLEAVE_CS1_SHFT	= 0x4,
+	S_SCMO_SLV_INTERLEAVE_CFG_INTERLEAVE_CS0_BMSK	= 0x1,
+	S_SCMO_SLV_INTERLEAVE_CFG_INTERLEAVE_CS0_SHFT	= 0x0,
+};
+
+#define S_SCMO_ADDR_BASE_CSn_ADDR(b, n, o)	\
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000410 + 0x4 * (o))
+enum bimc_s_scmo_addr_base_csn {
+	S_SCMO_ADDR_BASE_CSn_RMSK			= 0xffff,
+	S_SCMO_ADDR_BASE_CSn_MAXn			= 1,
+	S_SCMO_ADDR_BASE_CSn_ADDR_BASE_BMSK		= 0xfc,
+	S_SCMO_ADDR_BASE_CSn_ADDR_BASE_SHFT		= 0x2,
+};
+
+#define S_SCMO_ADDR_MAP_CSn_ADDR(b, n, o) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000420 + 0x4 * (o))
+enum bimc_s_scmo_addr_map_csn {
+	S_SCMO_ADDR_MAP_CSn_RMSK		= 0xffff,
+	S_SCMO_ADDR_MAP_CSn_MAXn		= 1,
+	S_SCMO_ADDR_MAP_CSn_RANK_EN_BMSK	= 0x8000,
+	S_SCMO_ADDR_MAP_CSn_RANK_EN_SHFT	= 0xf,
+	S_SCMO_ADDR_MAP_CSn_ADDR_MODE_BMSK	= 0x1000,
+	S_SCMO_ADDR_MAP_CSn_ADDR_MODE_SHFT	= 0xc,
+	S_SCMO_ADDR_MAP_CSn_BANK_SIZE_BMSK	= 0x100,
+	S_SCMO_ADDR_MAP_CSn_BANK_SIZE_SHFT	= 0x8,
+	S_SCMO_ADDR_MAP_CSn_ROW_SIZE_BMSK	= 0x30,
+	S_SCMO_ADDR_MAP_CSn_ROW_SIZE_SHFT	= 0x4,
+	S_SCMO_ADDR_MAP_CSn_COL_SIZE_BMSK	= 0x3,
+	S_SCMO_ADDR_MAP_CSn_COL_SIZE_SHFT	= 0x0,
+};
+
+#define S_SCMO_ADDR_MASK_CSn_ADDR(b, n, o) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000430 + 0x4 * (0))
+enum bimc_s_scmo_addr_mask_csn {
+	S_SCMO_ADDR_MASK_CSn_RMSK		= 0xffff,
+	S_SCMO_ADDR_MASK_CSn_MAXn		= 1,
+	S_SCMO_ADDR_MASK_CSn_ADDR_MASK_BMSK	= 0xfc,
+	S_SCMO_ADDR_MASK_CSn_ADDR_MASK_SHFT	= 0x2,
+};
+
+#define S_SCMO_SLV_STATUS_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000450)
+enum bimc_s_scmo_slv_status {
+	S_SCMO_SLV_STATUS_RMSK				= 0xff3,
+	S_SCMO_SLV_STATUS_GLOBAL_MONS_IN_USE_BMSK	= 0xff0,
+	S_SCMO_SLV_STATUS_GLOBAL_MONS_IN_USE_SHFT	= 0x4,
+	S_SCMO_SLV_STATUS_SLAVE_IDLE_BMSK		= 0x3,
+	S_SCMO_SLV_STATUS_SLAVE_IDLE_SHFT		= 0x0,
+};
+
+#define S_SCMO_CMD_BUF_CFG_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000500)
+enum bimc_s_scmo_cmd_buf_cfg {
+	S_SCMO_CMD_BUF_CFG_RMSK				= 0xf1f,
+	S_SCMO_CMD_BUF_CFG_CMD_ORDERING_BMSK		= 0x300,
+	S_SCMO_CMD_BUF_CFG_CMD_ORDERING_SHFT		= 0x8,
+	S_SCMO_CMD_BUF_CFG_HP_CMD_AREQPRIO_MAP_BMSK	= 0x10,
+	S_SCMO_CMD_BUF_CFG_HP_CMD_AREQPRIO_MAP_SHFT	= 0x4,
+	S_SCMO_CMD_BUF_CFG_HP_CMD_Q_DEPTH_BMSK		= 0x7,
+	S_SCMO_CMD_BUF_CFG_HP_CMD_Q_DEPTH_SHFT		= 0x0,
+};
+
+#define S_SCM_CMD_BUF_STATUS_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000520)
+enum bimc_s_scm_cmd_buf_status {
+	S_SCMO_CMD_BUF_STATUS_RMSK				= 0x77,
+	S_SCMO_CMD_BUF_STATUS_HP_CMD_BUF_ENTRIES_IN_USE_BMSK	= 0x70,
+	S_SCMO_CMD_BUF_STATUS_HP_CMD_BUF_ENTRIES_IN_USE_SHFT	= 0x4,
+	S_SCMO_CMD_BUF_STATUS_LP_CMD_BUF_ENTRIES_IN_USE_BMSK	= 0x7,
+	S_SCMO_CMD_BUF_STATUS_LP_CMD_BUF_ENTRIES_IN_USE_SHFT	= 0x0,
+};
+
+#define S_SCMO_RCH_SEL_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000540)
+enum bimc_s_scmo_rch_sel {
+	S_SCMO_RCH_SEL_RMSK			= 0xffffffff,
+	S_SCMO_CMD_BUF_STATUS_RCH_PORTS_BMSK	= 0xffffffff,
+	S_SCMO_CMD_BUF_STATUS_RCH_PORTS_SHFT	= 0x0,
+};
+
+#define S_SCMO_RCH_BKPR_CFG_ADDR(b, n) \
+		(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000544)
+enum bimc_s_scmo_rch_bkpr_cfg {
+	S_SCMO_RCH_BKPR_CFG_RMSK			= 0xffffffff,
+	S_SCMO_RCH_BKPR_CFG_RCH1_FIFO_BKPR_HI_TH_BMSK	= 0x3f000000,
+	S_SCMO_RCH_BKPR_CFG_RCH1_FIFO_BKPR_HI_TH_SHFT	= 0x18,
+	S_SCMO_RCH_BKPR_CFG_RCH1_FIFO_BKPR_LO_TH_BMSK	= 0x3f0000,
+	S_SCMO_RCH_BKPR_CFG_RCH1_FIFO_BKPR_LO_TH_SHFT	= 0x10,
+	S_SCMO_RCH_BKPR_CFG_RCH0_FIFO_BKPR_HI_TH_BMSK	= 0x3f00,
+	S_SCMO_RCH_BKPR_CFG_RCH0_FIFO_BKPR_HI_TH_SHFT	= 0x8,
+	S_SCMO_RCH_BKPR_CFG_RCH0_FIFO_BKPR_LO_TH_BMSK	= 0x3f,
+	S_SCMO_RCH_BKPR_CFG_RCH0_FIFO_BKPR_LO_TH_SHFT	= 0x0,
+};
+
+#define S_SCMO_RCH_STATUS_ADDR(b, n) \
+		(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000560)
+enum bimc_s_scmo_rch_status {
+	S_SCMO_RCH_STATUS_RMSK				= 0x33333,
+	S_SCMO_RCH_STATUS_PRQ_FIFO_FULL_BMSK		= 0x20000,
+	S_SCMO_RCH_STATUS_PRQ_FIFO_FULL_SHFT		= 0x11,
+	S_SCMO_RCH_STATUS_PRQ_FIFO_EMPTY_BMSK		= 0x10000,
+	S_SCMO_RCH_STATUS_PRQ_FIFO_EMPTY_SHFT		= 0x10,
+	S_SCMO_RCH_STATUS_RCH1_QUAL_FIFO_FULL_BMSK	= 0x2000,
+	S_SCMO_RCH_STATUS_RCH1_QUAL_FIFO_FULL_SHFT	= 0xd,
+	S_SCMO_RCH_STATUS_RCH1_QUAL_FIFO_EMPTY_BMSK	= 0x1000,
+	S_SCMO_RCH_STATUS_RCH1_QUAL_FIFO_EMPTY_SHFT	= 0xc,
+	S_SCMO_RCH_STATUS_RCH1_DATA_FIFO_FULL_BMSK	= 0x200,
+	S_SCMO_RCH_STATUS_RCH1_DATA_FIFO_FULL_SHFT	= 0x9,
+	S_SCMO_RCH_STATUS_RCH1_DATA_FIFO_EMPTY_BMSK	= 0x100,
+	S_SCMO_RCH_STATUS_RCH1_DATA_FIFO_EMPTY_SHFT	= 0x8,
+	S_SCMO_RCH_STATUS_RCH0_QUAL_FIFO_FULL_BMSK	= 0x20,
+	S_SCMO_RCH_STATUS_RCH0_QUAL_FIFO_FULL_SHFT	= 0x5,
+	S_SCMO_RCH_STATUS_RCH0_QUAL_FIFO_EMPTY_BMSK	= 0x10,
+	S_SCMO_RCH_STATUS_RCH0_QUAL_FIFO_EMPTY_SHFT	= 0x4,
+	S_SCMO_RCH_STATUS_RCH0_DATA_FIFO_FULL_BMSK	= 0x2,
+	S_SCMO_RCH_STATUS_RCH0_DATA_FIFO_FULL_SHFT	= 0x1,
+	S_SCMO_RCH_STATUS_RCH0_DATA_FIFO_EMPTY_BMSK	= 0x1,
+	S_SCMO_RCH_STATUS_RCH0_DATA_FIFO_EMPTY_SHFT	= 0x0,
+};
+
+#define S_SCMO_WCH_BUF_CFG_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000580)
+enum bimc_s_scmo_wch_buf_cfg {
+	S_SCMO_WCH_BUF_CFG_RMSK				= 0xff,
+	S_SCMO_WCH_BUF_CFG_WRITE_BLOCK_READ_BMSK	= 0x10,
+	S_SCMO_WCH_BUF_CFG_WRITE_BLOCK_READ_SHFT	= 0x4,
+	S_SCMO_WCH_BUF_CFG_COALESCE_EN_BMSK		= 0x1,
+	S_SCMO_WCH_BUF_CFG_COALESCE_EN_SHFT		= 0x0,
+};
+
+#define S_SCMO_WCH_STATUS_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x000005a0)
+enum bimc_s_scmo_wch_status {
+	S_SCMO_WCH_STATUS_RMSK				= 0x333,
+	S_SCMO_WCH_STATUS_BRESP_FIFO_FULL_BMSK		= 0x200,
+	S_SCMO_WCH_STATUS_BRESP_FIFO_FULL_SHFT		= 0x9,
+	S_SCMO_WCH_STATUS_BRESP_FIFO_EMPTY_BMSK		= 0x100,
+	S_SCMO_WCH_STATUS_BRESP_FIFO_EMPTY_SHFT		= 0x8,
+	S_SCMO_WCH_STATUS_WDATA_FIFO_FULL_BMSK		= 0x20,
+	S_SCMO_WCH_STATUS_WDATA_FIFO_FULL_SHFT		= 0x5,
+	S_SCMO_WCH_STATUS_WDATA_FIFO_EMPTY_BMSK		= 0x10,
+	S_SCMO_WCH_STATUS_WDATA_FIFO_EMPTY_SHFT		= 0x4,
+	S_SCMO_WCH_STATUS_WBUF_FULL_BMSK		= 0x2,
+	S_SCMO_WCH_STATUS_WBUF_FULL_SHFT		= 0x1,
+	S_SCMO_WCH_STATUS_WBUF_EMPTY_BMSK		= 0x1,
+	S_SCMO_WCH_STATUS_WBUF_EMPTY_SHFT		= 0x0,
+};
+
+#define S_SCMO_FLUSH_CFG_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x000005c0)
+enum bimc_s_scmo_flush_cfg {
+	S_SCMO_FLUSH_CFG_RMSK				= 0xffffffff,
+	S_SCMO_FLUSH_CFG_FLUSH_IN_ORDER_BMSK		= 0x10000000,
+	S_SCMO_FLUSH_CFG_FLUSH_IN_ORDER_SHFT		= 0x1c,
+	S_SCMO_FLUSH_CFG_FLUSH_IDLE_DELAY_BMSK		= 0x3ff0000,
+	S_SCMO_FLUSH_CFG_FLUSH_IDLE_DELAY_SHFT		= 0x10,
+	S_SCMO_FLUSH_CFG_FLUSH_UPPER_LIMIT_BMSK		= 0xf00,
+	S_SCMO_FLUSH_CFG_FLUSH_UPPER_LIMIT_SHFT		= 0x8,
+	S_SCMO_FLUSH_CFG_FLUSH_LOWER_LIMIT_BMSK		= 0xf,
+	S_SCMO_FLUSH_CFG_FLUSH_LOWER_LIMIT_SHFT		= 0x0,
+};
+
+#define S_SCMO_FLUSH_CMD_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x000005c4)
+enum bimc_s_scmo_flush_cmd {
+	S_SCMO_FLUSH_CMD_RMSK				= 0xf,
+	S_SCMO_FLUSH_CMD_FLUSH_ALL_BUF_BMSK		= 0x3,
+	S_SCMO_FLUSH_CMD_FLUSH_ALL_BUF_SHFT		= 0x0,
+};
+
+#define S_SCMO_CMD_OPT_CFG0_ADDR(b, n) \
+	(S_SCM0_REG_BASE(b) + (0x8000 * (n)) + 0x00000700)
+enum bimc_s_scmo_cmd_opt_cfg0 {
+	S_SCMO_CMD_OPT_CFG0_RMSK		= 0xffffff,
+	S_SCMO_CMD_OPT_CFG0_IGNORE_BANK_UNAVL_BMSK	= 0x100000,
+	S_SCMO_CMD_OPT_CFG0_IGNORE_BANK_UNAVL_SHFT	= 0x14,
+	S_SCMO_CMD_OPT_CFG0_MASK_CMDOUT_PRI_BMSK	= 0x10000,
+	S_SCMO_CMD_OPT_CFG0_MASK_CMDOUT_PRI_SHFT	= 0x10,
+	S_SCMO_CMD_OPT_CFG0_DPE_CMD_REORDERING_BMSK	= 0x1000,
+	S_SCMO_CMD_OPT_CFG0_DPE_CMD_REORDERING_SHFT	= 0xc,
+	S_SCMO_CMD_OPT_CFG0_WR_OPT_EN_BMSK		= 0x100,
+	S_SCMO_CMD_OPT_CFG0_WR_OPT_EN_SHFT		= 0x8,
+	S_SCMO_CMD_OPT_CFG0_RD_OPT_EN_BMSK		= 0x10,
+	S_SCMO_CMD_OPT_CFG0_RD_OPT_EN_SHFT		= 0x4,
+	S_SCMO_CMD_OPT_CFG0_PAGE_MGMT_POLICY_BMSK	= 0x1,
+	S_SCMO_CMD_OPT_CFG0_PAGE_MGMT_POLICY_SHFT	= 0x0,
+};
+
+#define S_SCMO_CMD_OPT_CFG1_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000704)
+enum bimc_s_scmo_cmd_opt_cfg1 {
+	S_SCMO_CMD_OPT_CFG1_RMSK			= 0xffffffff,
+	S_SCMO_CMD_OPT_CFG1_HSTP_CMD_TIMEOUT_BMSK	= 0x1f000000,
+	S_SCMO_CMD_OPT_CFG1_HSTP_CMD_TIMEOUT_SHFT	= 0x18,
+	S_SCMO_CMD_OPT_CFG1_HP_CMD_TIMEOUT_BMSK		= 0x1f0000,
+	S_SCMO_CMD_OPT_CFG1_HP_CMD_TIMEOUT_SHFT		= 0x10,
+	S_SCMO_CMD_OPT_CFG1_MP_CMD_TIMEOUT_BMSK		= 0x1f00,
+	S_SCMO_CMD_OPT_CFG1_MP_CMD_TIMEOUT_SHFT		= 0x8,
+	S_SCMO_CMD_OPT_CFG1_LP_CMD_TIMEOUT_BMSK		= 0x1f,
+	S_SCMO_CMD_OPT_CFG1_LP_CMD_TIMEOUT_SHFT		= 0x0,
+};
+
+#define S_SCMO_CMD_OPT_CFG2_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x00000708)
+enum bimc_s_scmo_cmd_opt_cfg2 {
+	S_SCMO_CMD_OPT_CFG2_RMSK			= 0xff,
+	S_SCMO_CMD_OPT_CFG2_RWOPT_CMD_TIMEOUT_BMSK	= 0xf,
+	S_SCMO_CMD_OPT_CFG2_RWOPT_CMD_TIMEOUT_SHFT	= 0x0,
+};
+
+#define S_SCMO_CMD_OPT_CFG3_ADDR(b, n) \
+	(S_SCMO_REG_BASE(b) + (0x8000 * (n)) + 0x0000070c)
+enum bimc_s_scmo_cmd_opt_cfg3 {
+	S_SCMO_CMD_OPT_CFG3_RMSK			= 0xff,
+	S_SCMO_CMD_OPT_CFG3_FLUSH_CMD_TIMEOUT_BMSK	= 0xf,
+	S_SCMO_CMD_OPT_CFG3_FLUSH_CMD_TIMEOUT_SHFT	= 0x0,
+};
+
+/* S_SWAY_GENERIC */
+#define S_SWAY_REG_BASE(b)	((b) + 0x00048000)
+
+#define S_SWAY_CONFIG_INFO_0_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000020)
+enum bimc_s_sway_config_info_0 {
+	S_SWAY_CONFIG_INFO_0_RMSK		= 0xff0000ff,
+	S_SWAY_CONFIG_INFO_0_SYNC_MODE_BMSK	= 0xff000000,
+	S_SWAY_CONFIG_INFO_0_SYNC_MODE_SHFT	= 0x18,
+	S_SWAY_CONFIG_INFO_0_FUNC_BMSK		= 0xff,
+	S_SWAY_CONFIG_INFO_0_FUNC_SHFT		= 0x0,
+};
+
+#define S_SWAY_CONFIG_INFO_1_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000030)
+enum bimc_s_sway_config_info_1 {
+	S_SWAY_CONFIG_INFO_1_RMSK			= 0xffffffff,
+	S_SWAY_CONFIG_INFO_1_MPORT_CONNECTIVITY_BMSK	= 0xffffffff,
+	S_SWAY_CONFIG_INFO_1_MPORT_CONNECTIVITY_SHFT	= 0x0,
+};
+
+#define S_SWAY_CONFIG_INFO_2_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000040)
+enum bimc_s_sway_config_info_2 {
+	S_SWAY_CONFIG_INFO_2_RMSK			= 0xffff0000,
+	S_SWAY_CONFIG_INFO_2_MPORT_CONNECTIVITY_BMSK	= 0xffff0000,
+	S_SWAY_CONFIG_INFO_2_MPORT_CONNECTIVITY_SHFT	= 0x10,
+};
+
+#define S_SWAY_CONFIG_INFO_3_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000050)
+enum bimc_s_sway_config_info_3 {
+	S_SWAY_CONFIG_INFO_3_RMSK			= 0xffffffff,
+	S_SWAY_CONFIG_INFO_3_RCH0_DEPTH_BMSK		= 0xff000000,
+	S_SWAY_CONFIG_INFO_3_RCH0_DEPTH_SHFT		= 0x18,
+	S_SWAY_CONFIG_INFO_3_BCH_DEPTH_BMSK		= 0xff0000,
+	S_SWAY_CONFIG_INFO_3_BCH_DEPTH_SHFT		= 0x10,
+	S_SWAY_CONFIG_INFO_3_WCH_DEPTH_BMSK		= 0xff,
+	S_SWAY_CONFIG_INFO_3_WCH_DEPTH_SHFT		= 0x0,
+};
+
+#define S_SWAY_CONFIG_INFO_4_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000060)
+enum bimc_s_sway_config_info_4 {
+	S_SWAY_CONFIG_INFO_4_RMSK			= 0x800000ff,
+	S_SWAY_CONFIG_INFO_4_DUAL_RCH_EN_BMSK		= 0x80000000,
+	S_SWAY_CONFIG_INFO_4_DUAL_RCH_EN_SHFT		= 0x1f,
+	S_SWAY_CONFIG_INFO_4_RCH1_DEPTH_BMSK		= 0xff,
+	S_SWAY_CONFIG_INFO_4_RCH1_DEPTH_SHFT		= 0x0,
+};
+
+#define S_SWAY_CONFIG_INFO_5_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000070)
+enum bimc_s_sway_config_info_5 {
+	S_SWAY_CONFIG_INFO_5_RMSK			= 0x800000ff,
+	S_SWAY_CONFIG_INFO_5_QCH_EN_BMSK		= 0x80000000,
+	S_SWAY_CONFIG_INFO_5_QCH_EN_SHFT		= 0x1f,
+	S_SWAY_CONFIG_INFO_5_QCH_DEPTH_BMSK		= 0xff,
+	S_SWAY_CONFIG_INFO_5_QCH_DEPTH_SHFT		= 0x0,
+};
+
+#define S_SWAY_CONFIG_INFO_6_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000080)
+enum bimc_s_sway_config_info_6 {
+	S_SWAY_CONFIG_INFO_6_RMSK			= 0x1,
+	S_SWAY_CONFIG_INFO_6_S2SW_PIPELINE_EN_BMSK	= 0x1,
+	S_SWAY_CONFIG_INFO_6_S2SW_PIPELINE_EN_SHFT	= 0x0,
+};
+
+#define S_SWAY_INT_STATUS_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000100)
+enum bimc_s_sway_int_status {
+	S_SWAY_INT_STATUS_RMSK		= 0x3,
+	S_SWAY_INT_STATUS_RFU_BMSK	= 0x3,
+	S_SWAY_INT_STATUS_RFU_SHFT	= 0x0,
+};
+
+#define S_SWAY_INT_CLR_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000108)
+enum bimc_s_sway_int_clr {
+	S_SWAY_INT_CLR_RMSK		= 0x3,
+	S_SWAY_INT_CLR_RFU_BMSK		= 0x3,
+	S_SWAY_INT_CLR_RFU_SHFT		= 0x0,
+};
+
+
+#define S_SWAY_INT_EN_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x0000010c)
+enum bimc_s_sway_int_en {
+	S_SWAY_INT_EN_RMSK		= 0x3,
+	S_SWAY_INT_EN_RFU_BMSK		= 0x3,
+	S_SWAY_INT_EN_RFU_SHFT		= 0x0,
+};
+
+#define S_SWAY_CLK_CTRL_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000200)
+enum bimc_s_sway_clk_ctrl {
+	S_SWAY_CLK_CTRL_RMSK				= 0x3,
+	S_SWAY_CLK_CTRL_SLAVE_CLK_GATING_EN_BMSK	= 0x2,
+	S_SWAY_CLK_CTRL_SLAVE_CLK_GATING_EN_SHFT	= 0x1,
+	S_SWAY_CLK_CTRL_CORE_CLK_GATING_EN_BMSK		= 0x1,
+	S_SWAY_CLK_CTRL_CORE_CLK_GATING_EN_SHFT		= 0x0,
+};
+
+#define S_SWAY_RCH_SEL_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000210)
+enum bimc_s_sway_rch_sel {
+	S_SWAY_RCH_SEL_RMSK		= 0x7f,
+	S_SWAY_RCH_SEL_UNUSED_BMSK	= 0x7f,
+	S_SWAY_RCH_SEL_UNUSED_SHFT	= 0x0,
+};
+
+
+#define S_SWAY_MAX_OUTSTANDING_REQS_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000220)
+enum bimc_s_sway_max_outstanding_reqs {
+	S_SWAY_MAX_OUTSTANDING_REQS_RMSK	= 0xffff,
+	S_SWAY_MAX_OUTSTANDING_REQS_WRITE_BMSK	= 0xff00,
+	S_SWAY_MAX_OUTSTANDING_REQS_WRITE_SHFT	= 0x8,
+	S_SWAY_MAX_OUTSTANDING_REQS_READ_BMSK	= 0xff,
+	S_SWAY_MAX_OUTSTANDING_REQS_READ_SHFT	= 0x0,
+};
+
+
+#define S_SWAY_BUF_STATUS_0_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000400)
+enum bimc_s_sway_buf_status_0 {
+	S_SWAY_BUF_STATUS_0_RMSK			= 0xf0300f03,
+	S_SWAY_BUF_STATUS_0_RCH0_DATA_RD_FULL_BMSK	= 0x80000000,
+	S_SWAY_BUF_STATUS_0_RCH0_DATA_RD_FULL_SHFT	= 0x1f,
+	S_SWAY_BUF_STATUS_0_RCH0_DATA_RD_EMPTY_BMSK	= 0x40000000,
+	S_SWAY_BUF_STATUS_0_RCH0_DATA_RD_EMPTY_SHFT	= 0x1e,
+	S_SWAY_BUF_STATUS_0_RCH0_CTRL_RD_FULL_BMSK	= 0x20000000,
+	S_SWAY_BUF_STATUS_0_RCH0_CTRL_RD_FULL_SHFT	= 0x1d,
+	S_SWAY_BUF_STATUS_0_RCH0_CTRL_RD_EMPTY_BMSK	= 0x10000000,
+	S_SWAY_BUF_STATUS_0_RCH0_CTRL_RD_EMPTY_SHFT	= 0x1c,
+	S_SWAY_BUF_STATUS_0_BCH_RD_FULL_BMSK		= 0x200000,
+	S_SWAY_BUF_STATUS_0_BCH_RD_FULL_SHFT		= 0x15,
+	S_SWAY_BUF_STATUS_0_BCH_RD_EMPTY_BMSK		= 0x100000,
+	S_SWAY_BUF_STATUS_0_BCH_RD_EMPTY_SHFT		= 0x14,
+	S_SWAY_BUF_STATUS_0_WCH_DATA_WR_FULL_BMSK	= 0x800,
+	S_SWAY_BUF_STATUS_0_WCH_DATA_WR_FULL_SHFT	= 0xb,
+	S_SWAY_BUF_STATUS_0_WCH_DATA_WR_EMPTY_BMSK	= 0x400,
+	S_SWAY_BUF_STATUS_0_WCH_DATA_WR_EMPTY_SHFT	= 0xa,
+	S_SWAY_BUF_STATUS_0_WCH_CTRL_WR_FULL_BMSK	= 0x200,
+	S_SWAY_BUF_STATUS_0_WCH_CTRL_WR_FULL_SHFT	= 0x9,
+	S_SWAY_BUF_STATUS_0_WCH_CTRL_WR_EMPTY_BMSK	= 0x100,
+	S_SWAY_BUF_STATUS_0_WCH_CTRL_WR_EMPTY_SHFT	= 0x8,
+	S_SWAY_BUF_STATUS_0_ACH_WR_FULL_BMSK		= 0x2,
+	S_SWAY_BUF_STATUS_0_ACH_WR_FULL_SHFT		= 0x1,
+	S_SWAY_BUF_STATUS_0_ACH_WR_EMPTY_BMSK		= 0x1,
+	S_SWAY_BUF_STATUS_0_ACH_WR_EMPTY_SHFT		= 0x0,
+};
+
+#define S_SWAY_BUF_STATUS_1_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000410)
+enum bimc_s_sway_buf_status_1 {
+	S_SWAY_BUF_STATUS_1_RMSK			= 0xf0,
+	S_SWAY_BUF_STATUS_1_RCH1_DATA_RD_FULL_BMSK	= 0x80,
+	S_SWAY_BUF_STATUS_1_RCH1_DATA_RD_FULL_SHFT	= 0x7,
+	S_SWAY_BUF_STATUS_1_RCH1_DATA_RD_EMPTY_BMSK	= 0x40,
+	S_SWAY_BUF_STATUS_1_RCH1_DATA_RD_EMPTY_SHFT	= 0x6,
+	S_SWAY_BUF_STATUS_1_RCH1_CTRL_RD_FULL_BMSK	= 0x20,
+	S_SWAY_BUF_STATUS_1_RCH1_CTRL_RD_FULL_SHFT	= 0x5,
+	S_SWAY_BUF_STATUS_1_RCH1_CTRL_RD_EMPTY_BMSK	= 0x10,
+	S_SWAY_BUF_STATUS_1_RCH1_CTRL_RD_EMPTY_SHFT	= 0x4,
+};
+
+#define S_SWAY_BUF_STATUS_2_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000420)
+enum bimc_s_sway_buf_status_2 {
+	S_SWAY_BUF_STATUS_2_RMSK		= 0x30,
+	S_SWAY_BUF_STATUS_2_QCH_RD_FULL_BMSK	= 0x20,
+	S_SWAY_BUF_STATUS_2_QCH_RD_FULL_SHFT	= 0x5,
+	S_SWAY_BUF_STATUS_2_QCH_RD_EMPTY_BMSK	= 0x10,
+	S_SWAY_BUF_STATUS_2_QCH_RD_EMPTY_SHFT	= 0x4,
+};
+
+/* S_ARB_GENERIC */
+
+#define S_ARB_REG_BASE(b)	((b) + 0x00049000)
+
+#define S_ARB_COMPONENT_INFO_ADDR(b, n) \
+	(S_SWAY_REG_BASE(b) + (0x8000 * (n)) + 0x00000000)
+enum bimc_s_arb_component_info {
+	S_ARB_COMPONENT_INFO_RMSK		= 0xffffff,
+	S_ARB_COMPONENT_INFO_INSTANCE_BMSK	= 0xff0000,
+	S_ARB_COMPONENT_INFO_INSTANCE_SHFT	= 0x10,
+	S_ARB_COMPONENT_INFO_SUB_TYPE_BMSK	= 0xff00,
+	S_ARB_COMPONENT_INFO_SUB_TYPE_SHFT	= 0x8,
+	S_ARB_COMPONENT_INFO_TYPE_BMSK		= 0xff,
+	S_ARB_COMPONENT_INFO_TYPE_SHFT		= 0x0,
+};
+
+#define S_ARB_CONFIG_INFO_0_ADDR(b, n) \
+		(S_ARB_REG_BASE(b) + (0x8000 * (n)) + 0x00000020)
+enum bimc_s_arb_config_info_0 {
+	S_ARB_CONFIG_INFO_0_RMSK			= 0x800000ff,
+	S_ARB_CONFIG_INFO_0_ARB2SW_PIPELINE_EN_BMSK	= 0x80000000,
+	S_ARB_CONFIG_INFO_0_ARB2SW_PIPELINE_EN_SHFT	= 0x1f,
+	S_ARB_CONFIG_INFO_0_FUNC_BMSK			= 0xff,
+	S_ARB_CONFIG_INFO_0_FUNC_SHFT			= 0x0,
+};
+
+#define S_ARB_CONFIG_INFO_1_ADDR(b, n) \
+		(S_ARB_REG_BASE(b) + (0x8000 * (n)) + 0x00000030)
+enum bimc_s_arb_config_info_1 {
+	S_ARB_CONFIG_INFO_1_RMSK			= 0xffffffff,
+	S_ARB_CONFIG_INFO_1_MPORT_CONNECTIVITY_BMSK	= 0xffffffff,
+	S_ARB_CONFIG_INFO_1_MPORT_CONNECTIVITY_SHFT	= 0x0,
+};
+
+#define S_ARB_CLK_CTRL_ADDR(b) \
+	(S_ARB_REG_BASE(b) + (0x8000 * (n)) + 0x00000200)
+enum bimc_s_arb_clk_ctrl {
+	S_ARB_CLK_CTRL_RMSK				= 0x1,
+	S_ARB_CLK_CTRL_SLAVE_CLK_GATING_EN_BMSK		= 0x2,
+	S_ARB_CLK_CTRL_SLAVE_CLK_GATING_EN_SHFT		= 0x1,
+	S_ARB_CLK_CTRL_CORE_CLK_GATING_EN_BMSK		= 0x1,
+	S_ARB_CLK_CTRL_CORE_CLK_GATING_EN_SHFT		= 0x0,
+	S_ARB_CLK_CTRL_CLK_GATING_EN_BMSK		= 0x1,
+	S_ARB_CLK_CTRL_CLK_GATING_EN_SHFT		= 0x0,
+};
+
+#define S_ARB_MODE_ADDR(b, n) \
+	(S_ARB_REG_BASE(b) + (0x8000 * (n)) + 0x00000210)
+enum bimc_s_arb_mode {
+	S_ARB_MODE_RMSK				= 0xf0000001,
+	S_ARB_MODE_WR_GRANTS_AHEAD_BMSK		= 0xf0000000,
+	S_ARB_MODE_WR_GRANTS_AHEAD_SHFT		= 0x1c,
+	S_ARB_MODE_PRIO_RR_EN_BMSK		= 0x1,
+	S_ARB_MODE_PRIO_RR_EN_SHFT		= 0x0,
+};
+
+#define BKE_HEALTH_MASK \
+	(M_BKE_HEALTH_0_CONFIG_LIMIT_CMDS_BMSK |\
+	M_BKE_HEALTH_0_CONFIG_AREQPRIO_BMSK |\
+	M_BKE_HEALTH_0_CONFIG_PRIOLVL_BMSK)
+
+#define BKE_HEALTH_VAL(limit, areq, plvl) \
+	((((limit) << M_BKE_HEALTH_0_CONFIG_LIMIT_CMDS_SHFT) & \
+	M_BKE_HEALTH_0_CONFIG_LIMIT_CMDS_BMSK) | \
+	(((areq) << M_BKE_HEALTH_0_CONFIG_AREQPRIO_SHFT) & \
+	M_BKE_HEALTH_0_CONFIG_AREQPRIO_BMSK) | \
+	(((plvl) << M_BKE_HEALTH_0_CONFIG_PRIOLVL_SHFT) & \
+	M_BKE_HEALTH_0_CONFIG_PRIOLVL_BMSK))
+
+#define MAX_GRANT_PERIOD \
+	(M_BKE_GP_GP_BMSK >> \
+	M_BKE_GP_GP_SHFT)
+
+#define MAX_GC \
+	(M_BKE_GC_GC_BMSK >> \
+	(M_BKE_GC_GC_SHFT + 1))
+
+static int bimc_div(int64_t *a, uint32_t b)
+{
+	if ((*a > 0) && (*a < b)) {
+		*a = 0;
+		return 1;
+	} else {
+		return do_div(*a, b);
+	}
+}
+
+#define ENABLE(val) ((val) == 1 ? 1 : 0)
+void msm_bus_bimc_set_mas_clk_gate(struct msm_bus_bimc_info *binfo,
+	uint32_t mas_index, struct msm_bus_bimc_clk_gate *bgate)
+{
+	uint32_t val, mask, reg_val;
+	void __iomem *addr;
+
+	reg_val = readl_relaxed(M_CLK_CTRL_ADDR(binfo->base,
+			mas_index)) & M_CLK_CTRL_RMSK;
+	addr = M_CLK_CTRL_ADDR(binfo->base, mas_index);
+	mask = (M_CLK_CTRL_MAS_CLK_GATING_EN_BMSK |
+		M_CLK_CTRL_CORE_CLK_GATING_EN_BMSK);
+	val = (bgate->core_clk_gate_en <<
+		M_CLK_CTRL_MAS_CLK_GATING_EN_SHFT) |
+		bgate->port_clk_gate_en;
+	writel_relaxed(((reg_val & (~mask)) | (val & mask)), addr);
+	/* Ensure clock gating enable mask is set before exiting */
+	wmb();
+}
+
+void msm_bus_bimc_arb_en(struct msm_bus_bimc_info *binfo,
+	uint32_t slv_index, bool en)
+{
+	uint32_t reg_val, reg_mask_val, enable, val;
+
+	reg_mask_val = (readl_relaxed(S_ARB_CONFIG_INFO_0_ADDR(binfo->
+		base, slv_index)) & S_ARB_CONFIG_INFO_0_FUNC_BMSK)
+		>> S_ARB_CONFIG_INFO_0_FUNC_SHFT;
+	enable = ENABLE(en);
+	val = enable << S_ARB_MODE_PRIO_RR_EN_SHFT;
+	if (reg_mask_val == BIMC_ARB_MODE_PRIORITY_RR) {
+		reg_val = readl_relaxed(S_ARB_CONFIG_INFO_0_ADDR(binfo->
+			base, slv_index)) & S_ARB_MODE_RMSK;
+		writel_relaxed(((reg_val & (~(S_ARB_MODE_PRIO_RR_EN_BMSK))) |
+			(val & S_ARB_MODE_PRIO_RR_EN_BMSK)),
+			S_ARB_MODE_ADDR(binfo->base, slv_index));
+		/* Ensure arbitration mode is set before returning */
+		wmb();
+	}
+}
+
+static void set_qos_mode(void __iomem *baddr, uint32_t index, uint32_t val0,
+	uint32_t val1, uint32_t val2)
+{
+	uint32_t reg_val, val;
+
+	reg_val = readl_relaxed(M_PRIOLVL_OVERRIDE_ADDR(baddr,
+		index)) & M_PRIOLVL_OVERRIDE_RMSK;
+	val = val0 << M_PRIOLVL_OVERRIDE_OVERRIDE_PRIOLVL_SHFT;
+	writel_relaxed(((reg_val & ~(M_PRIOLVL_OVERRIDE_OVERRIDE_PRIOLVL_BMSK))
+		| (val & M_PRIOLVL_OVERRIDE_OVERRIDE_PRIOLVL_BMSK)),
+		M_PRIOLVL_OVERRIDE_ADDR(baddr, index));
+	reg_val = readl_relaxed(M_RD_CMD_OVERRIDE_ADDR(baddr, index)) &
+		M_RD_CMD_OVERRIDE_RMSK;
+	val = val1 << M_RD_CMD_OVERRIDE_OVERRIDE_AREQPRIO_SHFT;
+	writel_relaxed(((reg_val & ~(M_RD_CMD_OVERRIDE_OVERRIDE_AREQPRIO_BMSK
+		)) | (val & M_RD_CMD_OVERRIDE_OVERRIDE_AREQPRIO_BMSK)),
+		M_RD_CMD_OVERRIDE_ADDR(baddr, index));
+	reg_val = readl_relaxed(M_WR_CMD_OVERRIDE_ADDR(baddr, index)) &
+		M_WR_CMD_OVERRIDE_RMSK;
+	val = val2 << M_WR_CMD_OVERRIDE_OVERRIDE_AREQPRIO_SHFT;
+	writel_relaxed(((reg_val & ~(M_WR_CMD_OVERRIDE_OVERRIDE_AREQPRIO_BMSK
+		)) | (val & M_WR_CMD_OVERRIDE_OVERRIDE_AREQPRIO_BMSK)),
+		M_WR_CMD_OVERRIDE_ADDR(baddr, index));
+	/* Ensure the priority register writes go through */
+	wmb();
+}
+
+static void msm_bus_bimc_set_qos_mode(void __iomem *base,
+	uint32_t mas_index, uint8_t qmode_sel)
+{
+	uint32_t reg_val, val;
+
+	switch (qmode_sel) {
+	case BIMC_QOS_MODE_FIXED:
+		reg_val = readl_relaxed(M_BKE_EN_ADDR(base,
+			mas_index));
+		writel_relaxed((reg_val & (~M_BKE_EN_EN_BMSK)),
+			M_BKE_EN_ADDR(base, mas_index));
+		/* Ensure that the book-keeping register writes
+		 * go through before setting QoS mode.
+		 * QoS mode registers might write beyond 1K
+		 * boundary in future
+		 */
+		wmb();
+		set_qos_mode(base, mas_index, 1, 1, 1);
+		break;
+
+	case BIMC_QOS_MODE_BYPASS:
+		reg_val = readl_relaxed(M_BKE_EN_ADDR(base,
+			mas_index));
+		writel_relaxed((reg_val & (~M_BKE_EN_EN_BMSK)),
+			M_BKE_EN_ADDR(base, mas_index));
+		/* Ensure that the book-keeping register writes
+		 * go through before setting QoS mode.
+		 * QoS mode registers might write beyond 1K
+		 * boundary in future
+		 */
+		wmb();
+		set_qos_mode(base, mas_index, 0, 0, 0);
+		break;
+
+	case BIMC_QOS_MODE_REGULATOR:
+	case BIMC_QOS_MODE_LIMITER:
+		set_qos_mode(base, mas_index, 0, 0, 0);
+		reg_val = readl_relaxed(M_BKE_EN_ADDR(base,
+			mas_index));
+		val = 1 << M_BKE_EN_EN_SHFT;
+		/* Ensure that the book-keeping register writes
+		 * go through before setting QoS mode.
+		 * QoS mode registers might write beyond 1K
+		 * boundary in future
+		 */
+		wmb();
+		writel_relaxed(((reg_val & (~M_BKE_EN_EN_BMSK)) | (val &
+			M_BKE_EN_EN_BMSK)), M_BKE_EN_ADDR(base,
+			mas_index));
+		break;
+	default:
+		break;
+	}
+}
+
+static void set_qos_prio_rl(void __iomem *addr, uint32_t rmsk,
+	uint8_t index, struct msm_bus_bimc_qos_mode *qmode)
+{
+	uint32_t reg_val, val0, val;
+
+	/* Note, addr is already passed with right mas_index */
+	reg_val = readl_relaxed(addr) & rmsk;
+	val0 = BKE_HEALTH_VAL(qmode->rl.qhealth[index].limit_commands,
+		qmode->rl.qhealth[index].areq_prio,
+		qmode->rl.qhealth[index].prio_level);
+	val = ((reg_val & (~(BKE_HEALTH_MASK))) | (val0 & BKE_HEALTH_MASK));
+	writel_relaxed(val, addr);
+	/* Ensure that priority for regulator/limiter modes are
+	 * set before returning
+	 */
+	wmb();
+
+}
+
+static void msm_bus_bimc_set_qos_prio(void __iomem *base,
+	uint32_t mas_index, uint8_t qmode_sel,
+	struct msm_bus_bimc_qos_mode *qmode)
+{
+	uint32_t reg_val, val;
+
+	switch (qmode_sel) {
+	case BIMC_QOS_MODE_FIXED:
+		reg_val = readl_relaxed(M_PRIOLVL_OVERRIDE_ADDR(
+			base, mas_index)) & M_PRIOLVL_OVERRIDE_RMSK;
+		val =  qmode->fixed.prio_level <<
+			M_PRIOLVL_OVERRIDE_SHFT;
+		writel_relaxed(((reg_val &
+			~(M_PRIOLVL_OVERRIDE_BMSK)) | (val
+			& M_PRIOLVL_OVERRIDE_BMSK)),
+			M_PRIOLVL_OVERRIDE_ADDR(base, mas_index));
+
+		reg_val = readl_relaxed(M_RD_CMD_OVERRIDE_ADDR(
+			base, mas_index)) & M_RD_CMD_OVERRIDE_RMSK;
+		val =  qmode->fixed.areq_prio_rd <<
+			M_RD_CMD_OVERRIDE_AREQPRIO_SHFT;
+		writel_relaxed(((reg_val & ~(M_RD_CMD_OVERRIDE_AREQPRIO_BMSK))
+			| (val & M_RD_CMD_OVERRIDE_AREQPRIO_BMSK)),
+			M_RD_CMD_OVERRIDE_ADDR(base, mas_index));
+
+		reg_val = readl_relaxed(M_WR_CMD_OVERRIDE_ADDR(
+			base, mas_index)) & M_WR_CMD_OVERRIDE_RMSK;
+		val =  qmode->fixed.areq_prio_wr <<
+			M_WR_CMD_OVERRIDE_AREQPRIO_SHFT;
+		writel_relaxed(((reg_val & ~(M_WR_CMD_OVERRIDE_AREQPRIO_BMSK))
+			| (val & M_WR_CMD_OVERRIDE_AREQPRIO_BMSK)),
+			M_WR_CMD_OVERRIDE_ADDR(base, mas_index));
+		/* Ensure that fixed mode register writes go through
+		 * before returning
+		 */
+		wmb();
+		break;
+
+	case BIMC_QOS_MODE_REGULATOR:
+	case BIMC_QOS_MODE_LIMITER:
+		set_qos_prio_rl(M_BKE_HEALTH_3_CONFIG_ADDR(base,
+			mas_index), M_BKE_HEALTH_3_CONFIG_RMSK, 3, qmode);
+		set_qos_prio_rl(M_BKE_HEALTH_2_CONFIG_ADDR(base,
+			mas_index), M_BKE_HEALTH_2_CONFIG_RMSK, 2, qmode);
+		set_qos_prio_rl(M_BKE_HEALTH_1_CONFIG_ADDR(base,
+			mas_index), M_BKE_HEALTH_1_CONFIG_RMSK, 1, qmode);
+		set_qos_prio_rl(M_BKE_HEALTH_0_CONFIG_ADDR(base,
+			mas_index), M_BKE_HEALTH_0_CONFIG_RMSK, 0 , qmode);
+		break;
+	case BIMC_QOS_MODE_BYPASS:
+	default:
+		break;
+	}
+}
+
+static void set_qos_bw_regs(void __iomem *baddr, uint32_t mas_index,
+	int32_t th, int32_t tm, int32_t tl, uint32_t gp,
+	uint32_t gc)
+{
+	int32_t reg_val, val;
+	int32_t bke_reg_val;
+	int16_t val2;
+
+	/* Disable BKE before writing to registers as per spec */
+	bke_reg_val = readl_relaxed(M_BKE_EN_ADDR(baddr, mas_index));
+	writel_relaxed((bke_reg_val & ~(M_BKE_EN_EN_BMSK)),
+		M_BKE_EN_ADDR(baddr, mas_index));
+
+	/* Write values of registers calculated */
+	reg_val = readl_relaxed(M_BKE_GP_ADDR(baddr, mas_index))
+		& M_BKE_GP_RMSK;
+	val =  gp << M_BKE_GP_GP_SHFT;
+	writel_relaxed(((reg_val & ~(M_BKE_GP_GP_BMSK)) | (val &
+		M_BKE_GP_GP_BMSK)), M_BKE_GP_ADDR(baddr, mas_index));
+
+	reg_val = readl_relaxed(M_BKE_GC_ADDR(baddr, mas_index)) &
+		M_BKE_GC_RMSK;
+	val =  gc << M_BKE_GC_GC_SHFT;
+	writel_relaxed(((reg_val & ~(M_BKE_GC_GC_BMSK)) | (val &
+		M_BKE_GC_GC_BMSK)), M_BKE_GC_ADDR(baddr, mas_index));
+
+	reg_val = readl_relaxed(M_BKE_THH_ADDR(baddr, mas_index)) &
+		M_BKE_THH_RMSK;
+	val =  th << M_BKE_THH_THRESH_SHFT;
+	writel_relaxed(((reg_val & ~(M_BKE_THH_THRESH_BMSK)) | (val &
+		M_BKE_THH_THRESH_BMSK)), M_BKE_THH_ADDR(baddr, mas_index));
+
+	reg_val = readl_relaxed(M_BKE_THM_ADDR(baddr, mas_index)) &
+		M_BKE_THM_RMSK;
+	val2 =	tm << M_BKE_THM_THRESH_SHFT;
+	writel_relaxed(((reg_val & ~(M_BKE_THM_THRESH_BMSK)) | (val2 &
+		M_BKE_THM_THRESH_BMSK)), M_BKE_THM_ADDR(baddr, mas_index));
+
+	reg_val = readl_relaxed(M_BKE_THL_ADDR(baddr, mas_index)) &
+		M_BKE_THL_RMSK;
+	val2 =	tl << M_BKE_THL_THRESH_SHFT;
+	writel_relaxed(((reg_val & ~(M_BKE_THL_THRESH_BMSK)) |
+		(val2 & M_BKE_THL_THRESH_BMSK)), M_BKE_THL_ADDR(baddr,
+		mas_index));
+
+	/* Ensure that all bandwidth register writes have completed
+	 * before returning
+	 */
+	wmb();
+}
+
+static void msm_bus_bimc_set_qos_bw(void __iomem *base, uint32_t qos_freq,
+	uint32_t mas_index, struct msm_bus_bimc_qos_bw *qbw)
+{
+	uint32_t bke_en;
+
+	/* Validate QOS Frequency */
+	if (qos_freq == 0) {
+		MSM_BUS_DBG("Zero frequency\n");
+		return;
+	}
+
+	/* Get enable bit for BKE before programming the period */
+	bke_en = (readl_relaxed(M_BKE_EN_ADDR(base, mas_index)) &
+		M_BKE_EN_EN_BMSK) >> M_BKE_EN_EN_SHFT;
+
+	/* Only calculate if there's a requested bandwidth and window */
+	if (qbw->bw && qbw->ws) {
+		int64_t th, tm, tl;
+		uint32_t gp, gc;
+		int64_t gp_nominal, gp_required, gp_calc, data, temp;
+		int64_t win = qbw->ws * qos_freq;
+		temp = win;
+		/*
+		 * Calculate nominal grant period defined by requested
+		 * window size.
+		 * Ceil this value to max grant period.
+		 */
+		bimc_div(&temp, 1000000);
+		gp_nominal = min_t(uint64_t, MAX_GRANT_PERIOD, temp);
+		/*
+		 * Calculate max window size, defined by bw request.
+		 * Units: (KHz, MB/s)
+		 */
+		gp_calc = MAX_GC * qos_freq * 1000;
+		gp_required = gp_calc;
+		bimc_div(&gp_required, qbw->bw);
+
+		/* User min of two grant periods */
+		gp = min_t(int64_t, gp_nominal, gp_required);
+
+		/* Calculate bandwith in grants and ceil. */
+		temp = qbw->bw * gp;
+		data = qos_freq * 1000;
+		bimc_div(&temp, data);
+		gc = min_t(int64_t, MAX_GC, temp);
+
+		/* Calculate thresholds */
+		th = qbw->bw - qbw->thh;
+		tm = qbw->bw - qbw->thm;
+		tl = qbw->bw - qbw->thl;
+
+		th = th * gp;
+		bimc_div(&th, data);
+		tm = tm * gp;
+		bimc_div(&tm, data);
+		tl = tl * gp;
+		bimc_div(&tl, data);
+
+		MSM_BUS_DBG("BIMC: BW: mas_index: %d, th: %llu tm: %llu\n",
+			mas_index, th, tm);
+		MSM_BUS_DBG("BIMC: tl: %llu gp:%u gc: %u bke_en: %u\n",
+			tl, gp, gc, bke_en);
+		set_qos_bw_regs(base, mas_index, th, tm, tl, gp, gc);
+	} else
+		/* Clear bandwidth registers */
+		set_qos_bw_regs(base, mas_index, 0, 0, 0, 0, 0);
+}
+
+static int msm_bus_bimc_allocate_commit_data(struct msm_bus_fabric_registration
+	*fab_pdata, void **cdata, int ctx)
+{
+	struct msm_bus_bimc_commit **cd = (struct msm_bus_bimc_commit **)cdata;
+	struct msm_bus_bimc_info *binfo =
+		(struct msm_bus_bimc_info *)fab_pdata->hw_data;
+
+	MSM_BUS_DBG("Allocating BIMC commit data\n");
+	*cd = kzalloc(sizeof(struct msm_bus_bimc_commit), GFP_KERNEL);
+	if (!*cd) {
+		MSM_BUS_DBG("Couldn't alloc mem for cdata\n");
+		return -ENOMEM;
+	}
+
+	(*cd)->mas = binfo->cdata[ctx].mas;
+	(*cd)->slv = binfo->cdata[ctx].slv;
+
+	return 0;
+}
+
+static void *msm_bus_bimc_allocate_bimc_data(struct platform_device *pdev,
+	struct msm_bus_fabric_registration *fab_pdata)
+{
+	struct resource *bimc_mem;
+	struct resource *bimc_io;
+	struct msm_bus_bimc_info *binfo;
+	int i;
+
+	MSM_BUS_DBG("Allocating BIMC data\n");
+	binfo = kzalloc(sizeof(struct msm_bus_bimc_info), GFP_KERNEL);
+	if (!binfo) {
+		WARN(!binfo, "Couldn't alloc mem for bimc_info\n");
+		return NULL;
+	}
+
+	binfo->qos_freq = fab_pdata->qos_freq;
+
+	binfo->params.nmasters = fab_pdata->nmasters;
+	binfo->params.nslaves = fab_pdata->nslaves;
+	binfo->params.bus_id = fab_pdata->id;
+
+	for (i = 0; i < NUM_CTX; i++) {
+		binfo->cdata[i].mas = kzalloc(sizeof(struct
+			msm_bus_node_hw_info) * fab_pdata->nmasters * 2,
+			GFP_KERNEL);
+		if (!binfo->cdata[i].mas) {
+			MSM_BUS_ERR("Couldn't alloc mem for bimc master hw\n");
+			kfree(binfo);
+			return NULL;
+		}
+
+		binfo->cdata[i].slv = kzalloc(sizeof(struct
+			msm_bus_node_hw_info) * fab_pdata->nslaves * 2,
+			GFP_KERNEL);
+		if (!binfo->cdata[i].slv) {
+			MSM_BUS_DBG("Couldn't alloc mem for bimc slave hw\n");
+			kfree(binfo->cdata[i].mas);
+			kfree(binfo);
+			return NULL;
+		}
+	}
+
+	if (fab_pdata->virt) {
+		MSM_BUS_DBG("Don't get memory regions for virtual fabric\n");
+		goto skip_mem;
+	}
+
+	bimc_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!bimc_mem) {
+		MSM_BUS_ERR("Cannot get BIMC Base address\n");
+		kfree(binfo);
+		return NULL;
+	}
+
+	bimc_io = request_mem_region(bimc_mem->start,
+			resource_size(bimc_mem), pdev->name);
+	if (!bimc_io) {
+		MSM_BUS_ERR("BIMC memory unavailable\n");
+		kfree(binfo);
+		return NULL;
+	}
+
+	binfo->base = ioremap(bimc_mem->start, resource_size(bimc_mem));
+	if (!binfo->base) {
+		MSM_BUS_ERR("IOremap failed for BIMC!\n");
+		release_mem_region(bimc_mem->start, resource_size(bimc_mem));
+		kfree(binfo);
+		return NULL;
+	}
+
+skip_mem:
+	fab_pdata->hw_data = (void *)binfo;
+	return (void *)binfo;
+}
+
+static void free_commit_data(void *cdata)
+{
+	struct msm_bus_bimc_commit *cd = (struct msm_bus_bimc_commit *)cdata;
+
+	kfree(cd->mas);
+	kfree(cd->slv);
+	kfree(cd);
+}
+
+static void bke_switch(
+	void __iomem *baddr, uint32_t mas_index, bool req, int mode)
+{
+	uint32_t reg_val, val, cur_val;
+
+	val = req << M_BKE_EN_EN_SHFT;
+	reg_val = readl_relaxed(M_BKE_EN_ADDR(baddr, mas_index));
+	cur_val = reg_val & M_BKE_EN_RMSK;
+	if (val == cur_val)
+		return;
+
+	if (!req && mode == BIMC_QOS_MODE_FIXED)
+		set_qos_mode(baddr, mas_index, 1, 1, 1);
+
+	writel_relaxed(((reg_val & ~(M_BKE_EN_EN_BMSK)) | (val &
+		M_BKE_EN_EN_BMSK)), M_BKE_EN_ADDR(baddr, mas_index));
+	/* Make sure BKE on/off goes through before changing priorities */
+	wmb();
+
+	if (req)
+		set_qos_mode(baddr, mas_index, 0, 0, 0);
+}
+
+static void bimc_set_static_qos_bw(void __iomem *base, unsigned int qos_freq,
+	int mport, struct msm_bus_bimc_qos_bw *qbw)
+{
+	int32_t bw_mbps, thh = 0, thm, thl, gc;
+	int32_t gp;
+	u64 temp;
+
+	if (qos_freq == 0) {
+		MSM_BUS_DBG("No QoS Frequency.\n");
+		return;
+	}
+
+	if (!(qbw->bw && qbw->gp)) {
+		MSM_BUS_DBG("No QoS Bandwidth or Window size\n");
+		return;
+	}
+
+	/* Convert bandwidth to MBPS */
+	temp = qbw->bw;
+	bimc_div(&temp, 1000000);
+	bw_mbps = temp;
+
+	/* Grant period in clock cycles
+	 * Grant period from bandwidth structure
+	 * is in nano seconds, QoS freq is in KHz.
+	 * Divide by 1000 to get clock cycles.
+	 */
+	gp = (qos_freq * qbw->gp) / (1000 * NSEC_PER_USEC);
+
+	/* Grant count = BW in MBps * Grant period
+	 * in micro seconds
+	 */
+	gc = bw_mbps * (qbw->gp / NSEC_PER_USEC);
+	gc = min(gc, MAX_GC);
+
+	/* Medium threshold = -((Medium Threshold percentage *
+	 * Grant count) / 100)
+	 */
+	thm = -((qbw->thmp * gc) / 100);
+	qbw->thm = thm;
+
+	/* Low threshold = -(Grant count) */
+	thl = -gc;
+	qbw->thl = thl;
+
+	MSM_BUS_DBG("%s: BKE parameters: gp %d, gc %d, thm %d thl %d thh %d",
+			__func__, gp, gc, thm, thl, thh);
+
+	trace_bus_bke_params(gc, gp, thl, thm, thl);
+	set_qos_bw_regs(base, mport, thh, thm, thl, gp, gc);
+}
+
+static void msm_bus_bimc_config_master(
+	struct msm_bus_fabric_registration *fab_pdata,
+	struct msm_bus_inode_info *info,
+	uint64_t req_clk, uint64_t req_bw)
+{
+	int mode, i, ports;
+	struct msm_bus_bimc_info *binfo;
+	uint64_t bw = 0;
+
+	binfo = (struct msm_bus_bimc_info *)fab_pdata->hw_data;
+	ports = info->node_info->num_mports;
+
+	/**
+	 * Here check the details of dual configuration.
+	 * Take actions based on different modes.
+	 * Check for threshold if limiter mode, etc.
+	*/
+
+	if (req_clk <= info->node_info->th[0]) {
+		mode = info->node_info->mode;
+		bw = info->node_info->bimc_bw[0];
+	} else if ((info->node_info->num_thresh > 1) &&
+			(req_clk <= info->node_info->th[1])) {
+		mode = info->node_info->mode;
+		bw = info->node_info->bimc_bw[1];
+	} else
+		mode = info->node_info->mode_thresh;
+
+	switch (mode) {
+	case BIMC_QOS_MODE_BYPASS:
+	case BIMC_QOS_MODE_FIXED:
+		for (i = 0; i < ports; i++)
+			bke_switch(binfo->base, info->node_info->qport[i],
+				BKE_OFF, mode);
+		break;
+	case BIMC_QOS_MODE_REGULATOR:
+	case BIMC_QOS_MODE_LIMITER:
+		for (i = 0; i < ports; i++) {
+			/* If not in fixed mode, update bandwidth */
+			if ((info->node_info->cur_lim_bw != bw)
+					&& (mode != BIMC_QOS_MODE_FIXED)) {
+				struct msm_bus_bimc_qos_bw qbw;
+				qbw.ws = info->node_info->ws;
+				qbw.bw = bw;
+				qbw.gp = info->node_info->bimc_gp;
+				qbw.thmp = info->node_info->bimc_thmp;
+				bimc_set_static_qos_bw(binfo->base,
+					binfo->qos_freq,
+					info->node_info->qport[i], &qbw);
+				info->node_info->cur_lim_bw = bw;
+				MSM_BUS_DBG("%s: Qos is %d reqclk %llu bw %llu",
+						__func__, mode, req_clk, bw);
+			}
+			bke_switch(binfo->base, info->node_info->qport[i],
+				BKE_ON, mode);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static void msm_bus_bimc_update_bw(struct msm_bus_inode_info *hop,
+	struct msm_bus_inode_info *info,
+	struct msm_bus_fabric_registration *fab_pdata,
+	void *sel_cdata, int *master_tiers,
+	int64_t add_bw)
+{
+	struct msm_bus_bimc_info *binfo;
+	struct msm_bus_bimc_qos_bw qbw;
+	int i;
+	int64_t bw;
+	int ports = info->node_info->num_mports;
+	struct msm_bus_bimc_commit *sel_cd =
+		(struct msm_bus_bimc_commit *)sel_cdata;
+
+	MSM_BUS_DBG("BIMC: Update bw for ID %d, with IID: %d: %lld\n",
+		info->node_info->id, info->node_info->priv_id, add_bw);
+
+	binfo = (struct msm_bus_bimc_info *)fab_pdata->hw_data;
+
+	if (info->node_info->num_mports == 0) {
+		MSM_BUS_DBG("BIMC: Skip Master BW\n");
+		goto skip_mas_bw;
+	}
+
+	ports = info->node_info->num_mports;
+	bw = INTERLEAVED_BW(fab_pdata, add_bw, ports);
+
+	for (i = 0; i < ports; i++) {
+		sel_cd->mas[info->node_info->masterp[i]].bw += bw;
+		sel_cd->mas[info->node_info->masterp[i]].hw_id =
+			info->node_info->mas_hw_id;
+		MSM_BUS_DBG("BIMC: Update mas_bw for ID: %d -> %llu\n",
+			info->node_info->priv_id,
+			sel_cd->mas[info->node_info->masterp[i]].bw);
+		if (info->node_info->hw_sel == MSM_BUS_RPM)
+			sel_cd->mas[info->node_info->masterp[i]].dirty = 1;
+		else {
+			if (!info->node_info->qport) {
+				MSM_BUS_DBG("No qos ports to update!\n");
+				break;
+			}
+			if (!(info->node_info->mode == BIMC_QOS_MODE_REGULATOR)
+					|| (info->node_info->mode ==
+						BIMC_QOS_MODE_LIMITER)) {
+				MSM_BUS_DBG("Skip QoS reg programming\n");
+				break;
+			}
+
+			MSM_BUS_DBG("qport: %d\n", info->node_info->qport[i]);
+			qbw.bw = sel_cd->mas[info->node_info->masterp[i]].bw;
+			qbw.ws = info->node_info->ws;
+			/* Threshold low = 90% of bw */
+			qbw.thl = div_s64((90 * bw), 100);
+			/* Threshold medium = bw */
+			qbw.thm = bw;
+			/* Threshold high = 10% more than bw */
+			qbw.thh = div_s64((110 * bw), 100);
+			/* Check if info is a shared master.
+			 * If it is, mark it dirty
+			 * If it isn't, then set QOS Bandwidth.
+			 * Also if dual-conf is set, don't program bw regs.
+			 **/
+			if (!info->node_info->dual_conf &&
+			((info->node_info->mode == BIMC_QOS_MODE_LIMITER) ||
+			(info->node_info->mode == BIMC_QOS_MODE_REGULATOR)))
+				msm_bus_bimc_set_qos_bw(binfo->base,
+					binfo->qos_freq,
+					info->node_info->qport[i], &qbw);
+		}
+	}
+
+skip_mas_bw:
+	ports = hop->node_info->num_sports;
+	MSM_BUS_DBG("BIMC: ID: %d, Sports: %d\n", hop->node_info->priv_id,
+		ports);
+
+	for (i = 0; i < ports; i++) {
+		sel_cd->slv[hop->node_info->slavep[i]].bw += add_bw;
+		sel_cd->slv[hop->node_info->slavep[i]].hw_id =
+			hop->node_info->slv_hw_id;
+		MSM_BUS_DBG("BIMC: Update slave_bw: ID: %d -> %llu\n",
+			hop->node_info->priv_id,
+			sel_cd->slv[hop->node_info->slavep[i]].bw);
+		MSM_BUS_DBG("BIMC: Update slave_bw: index: %d\n",
+			hop->node_info->slavep[i]);
+		/* Check if hop is a shared slave.
+		 * If it is, mark it dirty
+		 * If it isn't, then nothing to be done as the
+		 * slaves are in bypass mode.
+		 **/
+		if (hop->node_info->hw_sel == MSM_BUS_RPM) {
+			MSM_BUS_DBG("Slave dirty: %d, slavep: %d\n",
+				hop->node_info->priv_id,
+				hop->node_info->slavep[i]);
+			sel_cd->slv[hop->node_info->slavep[i]].dirty = 1;
+		}
+	}
+}
+
+static int msm_bus_bimc_commit(struct msm_bus_fabric_registration
+	*fab_pdata, void *hw_data, void **cdata)
+{
+	MSM_BUS_DBG("\nReached BIMC Commit\n");
+	msm_bus_remote_hw_commit(fab_pdata, hw_data, cdata);
+	return 0;
+}
+
+static void msm_bus_bimc_config_limiter(
+	struct msm_bus_fabric_registration *fab_pdata,
+	struct msm_bus_inode_info *info)
+{
+	struct msm_bus_bimc_info *binfo;
+	int mode, i, ports;
+
+	binfo = (struct msm_bus_bimc_info *)fab_pdata->hw_data;
+	ports = info->node_info->num_mports;
+
+	if (!info->node_info->qport) {
+		MSM_BUS_DBG("No QoS Ports to init\n");
+		return;
+	}
+
+	if (info->cur_lim_bw)
+		mode = BIMC_QOS_MODE_LIMITER;
+	else
+		mode = info->node_info->mode;
+
+	switch (mode) {
+	case BIMC_QOS_MODE_BYPASS:
+	case BIMC_QOS_MODE_FIXED:
+		for (i = 0; i < ports; i++)
+			bke_switch(binfo->base, info->node_info->qport[i],
+				BKE_OFF, mode);
+		break;
+	case BIMC_QOS_MODE_REGULATOR:
+	case BIMC_QOS_MODE_LIMITER:
+		if (info->cur_lim_bw != info->cur_prg_bw) {
+			MSM_BUS_DBG("Enabled BKE throttling node %d to %llu\n",
+				info->node_info->id, info->cur_lim_bw);
+			trace_bus_bimc_config_limiter(info->node_info->id,
+				info->cur_lim_bw);
+			for (i = 0; i < ports; i++) {
+				/* If not in fixed mode, update bandwidth */
+				struct msm_bus_bimc_qos_bw qbw;
+
+				qbw.ws = info->node_info->ws;
+				qbw.bw = info->cur_lim_bw;
+				qbw.gp = info->node_info->bimc_gp;
+				qbw.thmp = info->node_info->bimc_thmp;
+				bimc_set_static_qos_bw(binfo->base,
+					binfo->qos_freq,
+					info->node_info->qport[i], &qbw);
+				bke_switch(binfo->base,
+					info->node_info->qport[i],
+					BKE_ON, mode);
+				info->cur_prg_bw = qbw.bw;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static void bimc_init_mas_reg(struct msm_bus_bimc_info *binfo,
+	struct msm_bus_inode_info *info,
+	struct msm_bus_bimc_qos_mode *qmode, int mode)
+{
+	int i;
+
+	switch (mode) {
+	case BIMC_QOS_MODE_FIXED:
+		qmode->fixed.prio_level = info->node_info->prio_lvl;
+		qmode->fixed.areq_prio_rd = info->node_info->prio_rd;
+		qmode->fixed.areq_prio_wr = info->node_info->prio_wr;
+		break;
+	case BIMC_QOS_MODE_LIMITER:
+		qmode->rl.qhealth[0].limit_commands = 1;
+		qmode->rl.qhealth[1].limit_commands = 0;
+		qmode->rl.qhealth[2].limit_commands = 0;
+		qmode->rl.qhealth[3].limit_commands = 0;
+		break;
+	default:
+		break;
+	}
+
+	if (!info->node_info->qport) {
+		MSM_BUS_DBG("No QoS Ports to init\n");
+		return;
+	}
+
+	for (i = 0; i < info->node_info->num_mports; i++) {
+		/* If not in bypass mode, update priority */
+		if (mode != BIMC_QOS_MODE_BYPASS) {
+			msm_bus_bimc_set_qos_prio(binfo->base,
+				info->node_info->
+				qport[i], mode, qmode);
+
+			/* If not in fixed mode, update bandwidth */
+			if (mode != BIMC_QOS_MODE_FIXED) {
+				struct msm_bus_bimc_qos_bw qbw;
+				qbw.ws = info->node_info->ws;
+				qbw.bw = info->node_info->bimc_bw[0];
+				qbw.gp = info->node_info->bimc_gp;
+				qbw.thmp = info->node_info->bimc_thmp;
+				bimc_set_static_qos_bw(binfo->base,
+					binfo->qos_freq,
+					info->node_info->qport[i], &qbw);
+			}
+		}
+
+		/* set mode */
+		msm_bus_bimc_set_qos_mode(binfo->base,
+					info->node_info->qport[i],
+					mode);
+	}
+}
+
+static void init_health_regs(struct msm_bus_bimc_info *binfo,
+				struct msm_bus_inode_info *info,
+				struct msm_bus_bimc_qos_mode *qmode,
+				int mode)
+{
+	int i;
+
+	if (mode == BIMC_QOS_MODE_LIMITER) {
+		qmode->rl.qhealth[0].limit_commands = 1;
+		qmode->rl.qhealth[1].limit_commands = 0;
+		qmode->rl.qhealth[2].limit_commands = 0;
+		qmode->rl.qhealth[3].limit_commands = 0;
+
+		if (!info->node_info->qport) {
+			MSM_BUS_DBG("No QoS Ports to init\n");
+			return;
+		}
+
+		for (i = 0; i < info->node_info->num_mports; i++) {
+			/* If not in bypass mode, update priority */
+			if (mode != BIMC_QOS_MODE_BYPASS)
+				msm_bus_bimc_set_qos_prio(binfo->base,
+				info->node_info->qport[i], mode, qmode);
+		}
+	}
+}
+
+
+static int msm_bus_bimc_mas_init(struct msm_bus_bimc_info *binfo,
+	struct msm_bus_inode_info *info)
+{
+	struct msm_bus_bimc_qos_mode *qmode;
+	qmode = kzalloc(sizeof(struct msm_bus_bimc_qos_mode),
+		GFP_KERNEL);
+	if (!qmode) {
+		MSM_BUS_WARN("Couldn't alloc prio data for node: %d\n",
+			info->node_info->id);
+		return -ENOMEM;
+	}
+
+	info->hw_data = (void *)qmode;
+
+	/**
+	 * If the master supports dual configuration,
+	 * configure registers for both modes
+	 */
+	if (info->node_info->dual_conf)
+		bimc_init_mas_reg(binfo, info, qmode,
+			info->node_info->mode_thresh);
+	else if (info->node_info->nr_lim)
+		init_health_regs(binfo, info, qmode, BIMC_QOS_MODE_LIMITER);
+
+	bimc_init_mas_reg(binfo, info, qmode, info->node_info->mode);
+	return 0;
+}
+
+static void msm_bus_bimc_node_init(void *hw_data,
+	struct msm_bus_inode_info *info)
+{
+	struct msm_bus_bimc_info *binfo =
+		(struct msm_bus_bimc_info *)hw_data;
+
+	if (!IS_SLAVE(info->node_info->priv_id) &&
+		(info->node_info->hw_sel != MSM_BUS_RPM))
+		msm_bus_bimc_mas_init(binfo, info);
+}
+
+static int msm_bus_bimc_port_halt(uint32_t haltid, uint8_t mport)
+{
+	return 0;
+}
+
+static int msm_bus_bimc_port_unhalt(uint32_t haltid, uint8_t mport)
+{
+	return 0;
+}
+
+static int msm_bus_bimc_limit_mport(struct msm_bus_node_device_type *info,
+				void __iomem *qos_base, uint32_t qos_off,
+				uint32_t qos_delta, uint32_t qos_freq,
+				bool enable_lim, u64 lim_bw)
+{
+	int mode;
+	int i;
+
+	if (ZERO_OR_NULL_PTR(info->node_info->qport)) {
+		MSM_BUS_DBG("No QoS Ports to limit\n");
+		return 0;
+	}
+
+	if (enable_lim && lim_bw) {
+		mode =  BIMC_QOS_MODE_LIMITER;
+
+		if (!info->node_info->lim_bw) {
+			struct msm_bus_bimc_qos_mode qmode;
+			qmode.rl.qhealth[0].limit_commands = 1;
+			qmode.rl.qhealth[1].limit_commands = 0;
+			qmode.rl.qhealth[2].limit_commands = 0;
+			qmode.rl.qhealth[3].limit_commands = 0;
+
+			for (i = 0; i < info->node_info->num_qports; i++) {
+				/* If not in bypass mode, update priority */
+				if (mode != BIMC_QOS_MODE_BYPASS)
+					msm_bus_bimc_set_qos_prio(qos_base,
+					info->node_info->qport[i], mode,
+					&qmode);
+			}
+		}
+
+		for (i = 0; i < info->node_info->num_qports; i++) {
+			struct msm_bus_bimc_qos_bw qbw;
+			/* If not in fixed mode, update bandwidth */
+			if ((info->node_info->lim_bw != lim_bw)) {
+				qbw.ws = info->node_info->qos_params.ws;
+				qbw.bw = lim_bw;
+				qbw.gp = info->node_info->qos_params.gp;
+				qbw.thmp = info->node_info->qos_params.thmp;
+				bimc_set_static_qos_bw(qos_base, qos_freq,
+					info->node_info->qport[i], &qbw);
+			}
+			bke_switch(qos_base, info->node_info->qport[i],
+				BKE_ON, mode);
+		}
+		info->node_info->lim_bw = lim_bw;
+	} else {
+		mode = info->node_info->qos_params.mode;
+		for (i = 0; i < info->node_info->num_qports; i++) {
+			bke_switch(qos_base, info->node_info->qport[i],
+				BKE_OFF, mode);
+		}
+	}
+	info->node_info->qos_params.cur_mode = mode;
+	return 0;
+}
+
+static bool msm_bus_bimc_update_bw_reg(int mode)
+{
+	bool ret = false;
+
+	if ((mode == BIMC_QOS_MODE_LIMITER)
+		|| (mode == BIMC_QOS_MODE_REGULATOR))
+		ret = true;
+
+	return ret;
+}
+
+static int msm_bus_bimc_qos_init(struct msm_bus_node_device_type *info,
+				void __iomem *qos_base,
+				uint32_t qos_off, uint32_t qos_delta,
+				uint32_t qos_freq)
+{
+	int i;
+	struct msm_bus_bimc_qos_mode qmode;
+
+	switch (info->node_info->qos_params.mode) {
+	case BIMC_QOS_MODE_FIXED:
+		qmode.fixed.prio_level = info->node_info->qos_params.prio_lvl;
+		qmode.fixed.areq_prio_rd = info->node_info->qos_params.prio_rd;
+		qmode.fixed.areq_prio_wr = info->node_info->qos_params.prio_wr;
+		break;
+	case BIMC_QOS_MODE_LIMITER:
+		qmode.rl.qhealth[0].limit_commands = 1;
+		qmode.rl.qhealth[1].limit_commands = 0;
+		qmode.rl.qhealth[2].limit_commands = 0;
+		qmode.rl.qhealth[3].limit_commands = 0;
+		break;
+	default:
+		break;
+	}
+
+	if (ZERO_OR_NULL_PTR(info->node_info->qport)) {
+		MSM_BUS_DBG("No QoS Ports to init\n");
+		return 0;
+	}
+
+	for (i = 0; i < info->node_info->num_qports; i++) {
+		/* If not in bypass mode, update priority */
+		if (info->node_info->qos_params.mode != BIMC_QOS_MODE_BYPASS)
+			msm_bus_bimc_set_qos_prio(qos_base, info->node_info->
+				qport[i], info->node_info->qos_params.mode,
+									&qmode);
+
+		/* set mode */
+		if (info->node_info->qos_params.mode == BIMC_QOS_MODE_LIMITER)
+			bke_switch(qos_base, info->node_info->qport[i],
+				BKE_OFF, BIMC_QOS_MODE_FIXED);
+		else
+		       msm_bus_bimc_set_qos_mode(qos_base,
+				info->node_info->qport[i],
+				info->node_info->qos_params.mode);
+	}
+
+	return 0;
+}
+
+static int msm_bus_bimc_set_bw(struct msm_bus_node_device_type *dev,
+				void __iomem *qos_base, uint32_t qos_off,
+				uint32_t qos_delta, uint32_t qos_freq)
+{
+	struct msm_bus_bimc_qos_bw qbw;
+	int i;
+	int64_t bw = 0;
+	int ret = 0;
+	struct msm_bus_node_info_type *info = dev->node_info;
+
+	if (info && info->num_qports &&
+		((info->qos_params.mode == BIMC_QOS_MODE_LIMITER) ||
+		(info->qos_params.mode == BIMC_QOS_MODE_REGULATOR))) {
+		bw = msm_bus_div64(info->num_qports,
+				dev->node_ab.ab[DUAL_CTX]);
+
+		for (i = 0; i < info->num_qports; i++) {
+			MSM_BUS_DBG("BIMC: Update mas_bw for ID: %d -> %llu\n",
+				info->id, bw);
+
+			if (!info->qport) {
+				MSM_BUS_DBG("No qos ports to update!\n");
+				break;
+			}
+
+			qbw.bw = bw + info->qos_params.bw_buffer;
+			trace_bus_bimc_config_limiter(info->id, bw);
+
+			/* Default to gp of 5us */
+			qbw.gp = (info->qos_params.gp ?
+					info->qos_params.gp : 5000);
+			/* Default to thmp of 50% */
+			qbw.thmp = (info->qos_params.thmp ?
+					info->qos_params.thmp : 50);
+			/*
+			 * If the BW vote is 0 then set the QoS mode to
+			 * Fixed.
+			 */
+			if (bw) {
+				bimc_set_static_qos_bw(qos_base, qos_freq,
+					info->qport[i], &qbw);
+				bke_switch(qos_base, info->qport[i],
+					BKE_ON, info->qos_params.mode);
+			} else {
+				bke_switch(qos_base, info->qport[i],
+					BKE_OFF, BIMC_QOS_MODE_FIXED);
+			}
+		}
+	}
+	return ret;
+}
+
+int msm_bus_bimc_hw_init(struct msm_bus_fabric_registration *pdata,
+	struct msm_bus_hw_algorithm *hw_algo)
+{
+	/* Set interleaving to true by default */
+	MSM_BUS_DBG("\nInitializing BIMC...\n");
+	pdata->il_flag = true;
+	hw_algo->allocate_commit_data = msm_bus_bimc_allocate_commit_data;
+	hw_algo->allocate_hw_data = msm_bus_bimc_allocate_bimc_data;
+	hw_algo->node_init = msm_bus_bimc_node_init;
+	hw_algo->free_commit_data = free_commit_data;
+	hw_algo->update_bw = msm_bus_bimc_update_bw;
+	hw_algo->commit = msm_bus_bimc_commit;
+	hw_algo->port_halt = msm_bus_bimc_port_halt;
+	hw_algo->port_unhalt = msm_bus_bimc_port_unhalt;
+	hw_algo->config_master = msm_bus_bimc_config_master;
+	hw_algo->config_limiter = msm_bus_bimc_config_limiter;
+	hw_algo->update_bw_reg = msm_bus_bimc_update_bw_reg;
+	/* BIMC slaves are shared. Slave registers are set through RPM */
+	if (!pdata->ahb)
+		pdata->rpm_enabled = 1;
+	return 0;
+}
+
+int msm_bus_bimc_set_ops(struct msm_bus_node_device_type *bus_dev)
+{
+	if (!bus_dev)
+		return -ENODEV;
+	else {
+		bus_dev->fabdev->noc_ops.qos_init = msm_bus_bimc_qos_init;
+		bus_dev->fabdev->noc_ops.set_bw = msm_bus_bimc_set_bw;
+		bus_dev->fabdev->noc_ops.limit_mport = msm_bus_bimc_limit_mport;
+		bus_dev->fabdev->noc_ops.update_bw_reg =
+						msm_bus_bimc_update_bw_reg;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(msm_bus_bimc_set_ops);
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_bimc.h
@@ -0,0 +1,127 @@
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _ARCH_ARM_MACH_MSM_BUS_BIMC_H
+#define _ARCH_ARM_MACH_MSM_BUS_BIMC_H
+
+struct msm_bus_bimc_params {
+	uint32_t bus_id;
+	uint32_t addr_width;
+	uint32_t data_width;
+	uint32_t nmasters;
+	uint32_t nslaves;
+};
+
+struct msm_bus_bimc_commit {
+	struct msm_bus_node_hw_info *mas;
+	struct msm_bus_node_hw_info *slv;
+};
+
+struct msm_bus_bimc_info {
+	void __iomem *base;
+	uint32_t base_addr;
+	uint32_t qos_freq;
+	struct msm_bus_bimc_params params;
+	struct msm_bus_bimc_commit cdata[NUM_CTX];
+};
+
+struct msm_bus_bimc_node {
+	uint32_t conn_mask;
+	uint32_t data_width;
+	uint8_t slv_arb_mode;
+};
+
+enum msm_bus_bimc_arb_mode {
+	BIMC_ARB_MODE_RR = 0,
+	BIMC_ARB_MODE_PRIORITY_RR,
+	BIMC_ARB_MODE_TIERED_RR,
+};
+
+
+enum msm_bus_bimc_interleave {
+	BIMC_INTERLEAVE_NONE = 0,
+	BIMC_INTERLEAVE_ODD,
+	BIMC_INTERLEAVE_EVEN,
+};
+
+struct msm_bus_bimc_slave_seg {
+	bool enable;
+	uint64_t start_addr;
+	uint64_t seg_size;
+	uint8_t interleave;
+};
+
+enum msm_bus_bimc_qos_mode_type {
+	BIMC_QOS_MODE_FIXED = 0,
+	BIMC_QOS_MODE_LIMITER,
+	BIMC_QOS_MODE_BYPASS,
+	BIMC_QOS_MODE_REGULATOR,
+};
+
+struct msm_bus_bimc_qos_health {
+	bool limit_commands;
+	uint32_t areq_prio;
+	uint32_t prio_level;
+};
+
+struct msm_bus_bimc_mode_fixed {
+	uint32_t prio_level;
+	uint32_t areq_prio_rd;
+	uint32_t areq_prio_wr;
+};
+
+struct msm_bus_bimc_mode_rl {
+	uint8_t qhealthnum;
+	struct msm_bus_bimc_qos_health qhealth[4];
+};
+
+struct msm_bus_bimc_qos_mode {
+	uint8_t mode;
+	struct msm_bus_bimc_mode_fixed fixed;
+	struct msm_bus_bimc_mode_rl rl;
+};
+
+struct msm_bus_bimc_qos_bw {
+	uint64_t bw;	/* bw is in Bytes/sec */
+	uint32_t ws;	/* Window size in nano seconds*/
+	int64_t thh;	/* Threshold high, bytes per second */
+	int64_t thm;	/* Threshold medium, bytes per second */
+	int64_t thl;	/* Threshold low, bytes per second */
+	u32 gp;	/* Grant Period in micro seconds */
+	u32 thmp; /* Threshold medium in percentage */
+};
+
+struct msm_bus_bimc_clk_gate {
+	bool core_clk_gate_en;
+	bool arb_clk_gate_en;	/* For arbiter */
+	bool port_clk_gate_en;	/* For regs on BIMC core clock */
+};
+
+void msm_bus_bimc_set_slave_seg(struct msm_bus_bimc_info *binfo,
+	uint32_t slv_index, uint32_t seg_index,
+	struct msm_bus_bimc_slave_seg *bsseg);
+void msm_bus_bimc_set_slave_clk_gate(struct msm_bus_bimc_info *binfo,
+	uint32_t slv_index, struct msm_bus_bimc_clk_gate *bgate);
+void msm_bus_bimc_set_mas_clk_gate(struct msm_bus_bimc_info *binfo,
+	uint32_t mas_index, struct msm_bus_bimc_clk_gate *bgate);
+void msm_bus_bimc_arb_en(struct msm_bus_bimc_info *binfo,
+	uint32_t slv_index, bool en);
+void msm_bus_bimc_get_params(struct msm_bus_bimc_info *binfo,
+	struct msm_bus_bimc_params *params);
+void msm_bus_bimc_get_mas_params(struct msm_bus_bimc_info *binfo,
+	uint32_t mas_index, struct msm_bus_bimc_node *mparams);
+void msm_bus_bimc_get_slv_params(struct msm_bus_bimc_info *binfo,
+	uint32_t slv_index, struct msm_bus_bimc_node *sparams);
+bool msm_bus_bimc_get_arb_en(struct msm_bus_bimc_info *binfo,
+	uint32_t slv_index);
+
+#endif /*_ARCH_ARM_MACH_MSM_BUS_BIMC_H*/
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_client_api.c
@@ -0,0 +1,83 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "AXI: %s(): " fmt, __func__
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/radix-tree.h>
+#include <linux/clk.h>
+#include "msm-bus.h"
+#include "msm_bus_core.h"
+
+struct msm_bus_arb_ops arb_ops;
+
+/**
+ * msm_bus_scale_register_client() - Register the clients with the msm bus
+ * driver
+ * @pdata: Platform data of the client, containing src, dest, ab, ib.
+ * Return non-zero value in case of success, 0 in case of failure.
+ *
+ * Client data contains the vectors specifying arbitrated bandwidth (ab)
+ * and instantaneous bandwidth (ib) requested between a particular
+ * src and dest.
+ */
+uint32_t msm_bus_scale_register_client(struct msm_bus_scale_pdata *pdata)
+{
+	if (arb_ops.register_client)
+		return arb_ops.register_client(pdata);
+	else {
+		pr_err("%s: Bus driver not ready.",
+				__func__);
+		return 0;
+	}
+}
+EXPORT_SYMBOL(msm_bus_scale_register_client);
+
+/**
+ * msm_bus_scale_client_update_request() - Update the request for bandwidth
+ * from a particular client
+ *
+ * cl: Handle to the client
+ * index: Index into the vector, to which the bw and clock values need to be
+ * updated
+ */
+int msm_bus_scale_client_update_request(uint32_t cl, unsigned int index)
+{
+	if (arb_ops.update_request)
+		return arb_ops.update_request(cl, index);
+	else {
+		pr_err("%s: Bus driver not ready.",
+				__func__);
+		return -EPROBE_DEFER;
+	}
+}
+EXPORT_SYMBOL(msm_bus_scale_client_update_request);
+
+/**
+ * msm_bus_scale_unregister_client() - Unregister the client from the bus driver
+ * @cl: Handle to the client
+ */
+void msm_bus_scale_unregister_client(uint32_t cl)
+{
+	if (arb_ops.unregister_client)
+		arb_ops.unregister_client(cl);
+	else {
+		pr_err("%s: Bus driver not ready.",
+				__func__);
+	}
+}
+EXPORT_SYMBOL(msm_bus_scale_unregister_client);
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_core.c
@@ -0,0 +1,125 @@
+/* Copyright (c) 2010-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "AXI: %s(): " fmt, __func__
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/radix-tree.h>
+#include <linux/clk.h>
+#include "msm-bus-board.h"
+#include "msm-bus.h"
+#include "msm_bus_core.h"
+
+static atomic_t num_fab = ATOMIC_INIT(0);
+
+int msm_bus_get_num_fab(void)
+{
+	return atomic_read(&num_fab);
+}
+
+int msm_bus_device_match(struct device *dev, void *id)
+{
+	struct msm_bus_fabric_device *fabdev = to_msm_bus_fabric_device(dev);
+
+	if (!fabdev) {
+		MSM_BUS_WARN("Fabric %p returning 0\n", fabdev);
+		return 0;
+	}
+	return fabdev->id == *(int *)id;
+}
+
+static void msm_bus_release(struct device *device)
+{
+}
+
+struct bus_type msm_bus_type = {
+	.name      = "msm-bus-type",
+};
+EXPORT_SYMBOL(msm_bus_type);
+
+/**
+ * msm_bus_get_fabric_device() - This function is used to search for
+ * the fabric device on the bus
+ * @fabid: Fabric id
+ * Function returns: Pointer to the fabric device
+ */
+struct msm_bus_fabric_device *msm_bus_get_fabric_device(int fabid)
+{
+	struct device *dev;
+	struct msm_bus_fabric_device *fabric;
+	dev = bus_find_device(&msm_bus_type, NULL, (void *)&fabid,
+		msm_bus_device_match);
+	if (!dev)
+		return NULL;
+	fabric = to_msm_bus_fabric_device(dev);
+	return fabric;
+}
+
+/**
+ * msm_bus_fabric_device_register() - Registers a fabric on msm bus
+ * @fabdev: Fabric device to be registered
+ */
+int msm_bus_fabric_device_register(struct msm_bus_fabric_device *fabdev)
+{
+	int ret = 0;
+	fabdev->dev.bus = &msm_bus_type;
+	fabdev->dev.release = msm_bus_release;
+	ret = dev_set_name(&fabdev->dev, fabdev->name);
+	if (ret) {
+		MSM_BUS_ERR("error setting dev name\n");
+		goto err;
+	}
+
+	ret = device_register(&fabdev->dev);
+	if (ret < 0) {
+		MSM_BUS_ERR("error registering device%d %s\n",
+				ret, fabdev->name);
+		goto err;
+	}
+	atomic_inc(&num_fab);
+err:
+	return ret;
+}
+
+/**
+ * msm_bus_fabric_device_unregister() - Unregisters the fabric
+ * devices from the msm bus
+ */
+void msm_bus_fabric_device_unregister(struct msm_bus_fabric_device *fabdev)
+{
+	device_unregister(&fabdev->dev);
+	atomic_dec(&num_fab);
+}
+
+static void __exit msm_bus_exit(void)
+{
+	bus_unregister(&msm_bus_type);
+}
+
+static int __init msm_bus_init(void)
+{
+	int retval = 0;
+	retval = bus_register(&msm_bus_type);
+	if (retval)
+		MSM_BUS_ERR("bus_register error! %d\n",
+			retval);
+	return retval;
+}
+postcore_initcall(msm_bus_init);
+module_exit(msm_bus_exit);
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("0.2");
+MODULE_ALIAS("platform:msm_bus");
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_core.h
@@ -0,0 +1,375 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _ARCH_ARM_MACH_MSM_BUS_CORE_H
+#define _ARCH_ARM_MACH_MSM_BUS_CORE_H
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/radix-tree.h>
+#include <linux/platform_device.h>
+#include "msm-bus-board.h"
+#include "msm-bus.h"
+
+#define MSM_BUS_DBG(msg, ...) \
+	pr_debug(msg, ## __VA_ARGS__)
+#define MSM_BUS_ERR(msg, ...) \
+	pr_err(msg, ## __VA_ARGS__)
+#define MSM_BUS_WARN(msg, ...) \
+	pr_warn(msg, ## __VA_ARGS__)
+#define MSM_FAB_ERR(msg, ...) \
+	dev_err(&fabric->fabdev.dev, msg, ## __VA_ARGS__)
+
+#define IS_MASTER_VALID(mas) \
+	(((mas >= MSM_BUS_MASTER_FIRST) && (mas <= MSM_BUS_MASTER_LAST)) \
+	 ? 1 : 0)
+#define IS_SLAVE_VALID(slv) \
+	(((slv >= MSM_BUS_SLAVE_FIRST) && (slv <= MSM_BUS_SLAVE_LAST)) ? 1 : 0)
+
+#define INTERLEAVED_BW(fab_pdata, bw, ports) \
+	((fab_pdata->il_flag) ? ((bw < 0) \
+	? -msm_bus_div64((ports), (-bw)) : msm_bus_div64((ports), (bw))) : (bw))
+#define INTERLEAVED_VAL(fab_pdata, n) \
+	((fab_pdata->il_flag) ? (n) : 1)
+#define KBTOB(a) (a * 1000ULL)
+
+enum msm_bus_dbg_op_type {
+	MSM_BUS_DBG_UNREGISTER = -2,
+	MSM_BUS_DBG_REGISTER,
+	MSM_BUS_DBG_OP = 1,
+};
+
+enum msm_bus_hw_sel {
+	MSM_BUS_RPM = 0,
+	MSM_BUS_NOC,
+	MSM_BUS_BIMC,
+};
+
+struct msm_bus_arb_ops {
+	uint32_t (*register_client)(struct msm_bus_scale_pdata *pdata);
+	int (*update_request)(uint32_t cl, unsigned int index);
+	void (*unregister_client)(uint32_t cl);
+};
+
+enum {
+	SLAVE_NODE,
+	MASTER_NODE,
+	CLK_NODE,
+	NR_LIM_NODE,
+};
+
+
+extern struct bus_type msm_bus_type;
+extern struct msm_bus_arb_ops arb_ops;
+extern void msm_bus_arb_setops_legacy(struct msm_bus_arb_ops *arb_ops);
+
+struct msm_bus_node_info {
+	unsigned int id;
+	unsigned int priv_id;
+	unsigned int mas_hw_id;
+	unsigned int slv_hw_id;
+	int gateway;
+	int *masterp;
+	int *qport;
+	int num_mports;
+	int *slavep;
+	int num_sports;
+	int *tier;
+	int num_tiers;
+	int ahb;
+	int hw_sel;
+	const char *slaveclk[NUM_CTX];
+	const char *memclk[NUM_CTX];
+	const char *iface_clk_node;
+	unsigned int buswidth;
+	unsigned int ws;
+	unsigned int mode;
+	unsigned int perm_mode;
+	unsigned int prio_lvl;
+	unsigned int prio_rd;
+	unsigned int prio_wr;
+	unsigned int prio1;
+	unsigned int prio0;
+	unsigned int num_thresh;
+	u64 *th;
+	u64 cur_lim_bw;
+	unsigned int mode_thresh;
+	bool dual_conf;
+	u64 *bimc_bw;
+	bool nr_lim;
+	u32 ff;
+	bool rt_mas;
+	u32 bimc_gp;
+	u32 bimc_thmp;
+	u64 floor_bw;
+	const char *name;
+};
+
+struct path_node {
+	uint64_t clk[NUM_CTX];
+	uint64_t bw[NUM_CTX];
+	uint64_t *sel_clk;
+	uint64_t *sel_bw;
+	int next;
+};
+
+struct msm_bus_link_info {
+	uint64_t clk[NUM_CTX];
+	uint64_t *sel_clk;
+	uint64_t memclk;
+	int64_t bw[NUM_CTX];
+	int64_t *sel_bw;
+	int *tier;
+	int num_tiers;
+};
+
+struct nodeclk {
+	struct clk *clk;
+	uint64_t rate;
+	bool dirty;
+	bool enable;
+};
+
+struct msm_bus_inode_info {
+	struct msm_bus_node_info *node_info;
+	uint64_t max_bw;
+	uint64_t max_clk;
+	uint64_t cur_lim_bw;
+	uint64_t cur_prg_bw;
+	struct msm_bus_link_info link_info;
+	int num_pnodes;
+	struct path_node *pnode;
+	int commit_index;
+	struct nodeclk nodeclk[NUM_CTX];
+	struct nodeclk memclk[NUM_CTX];
+	struct nodeclk iface_clk;
+	void *hw_data;
+};
+
+struct msm_bus_node_hw_info {
+	bool dirty;
+	unsigned int hw_id;
+	uint64_t bw;
+};
+
+struct msm_bus_hw_algorithm {
+	int (*allocate_commit_data)(struct msm_bus_fabric_registration
+		*fab_pdata, void **cdata, int ctx);
+	void *(*allocate_hw_data)(struct platform_device *pdev,
+		struct msm_bus_fabric_registration *fab_pdata);
+	void (*node_init)(void *hw_data, struct msm_bus_inode_info *info);
+	void (*free_commit_data)(void *cdata);
+	void (*update_bw)(struct msm_bus_inode_info *hop,
+		struct msm_bus_inode_info *info,
+		struct msm_bus_fabric_registration *fab_pdata,
+		void *sel_cdata, int *master_tiers,
+		int64_t add_bw);
+	void (*fill_cdata_buffer)(int *curr, char *buf, const int max_size,
+		void *cdata, int nmasters, int nslaves, int ntslaves);
+	int (*commit)(struct msm_bus_fabric_registration
+		*fab_pdata, void *hw_data, void **cdata);
+	int (*port_unhalt)(uint32_t haltid, uint8_t mport);
+	int (*port_halt)(uint32_t haltid, uint8_t mport);
+	void (*config_master)(struct msm_bus_fabric_registration *fab_pdata,
+		struct msm_bus_inode_info *info,
+		uint64_t req_clk, uint64_t req_bw);
+	void (*config_limiter)(struct msm_bus_fabric_registration *fab_pdata,
+		struct msm_bus_inode_info *info);
+	bool (*update_bw_reg)(int mode);
+};
+
+struct msm_bus_fabric_device {
+	int id;
+	const char *name;
+	struct device dev;
+	const struct msm_bus_fab_algorithm *algo;
+	const struct msm_bus_board_algorithm *board_algo;
+	struct msm_bus_hw_algorithm hw_algo;
+	int visited;
+	int num_nr_lim;
+	u64 nr_lim_thresh;
+	u32 eff_fact;
+};
+#define to_msm_bus_fabric_device(d) container_of(d, \
+		struct msm_bus_fabric_device, d)
+
+struct msm_bus_fabric {
+	struct msm_bus_fabric_device fabdev;
+	int ahb;
+	void *cdata[NUM_CTX];
+	bool arb_dirty;
+	bool clk_dirty;
+	struct radix_tree_root fab_tree;
+	int num_nodes;
+	struct list_head gateways;
+	struct msm_bus_inode_info info;
+	struct msm_bus_fabric_registration *pdata;
+	void *hw_data;
+};
+#define to_msm_bus_fabric(d) container_of(d, \
+	struct msm_bus_fabric, d)
+
+
+struct msm_bus_fab_algorithm {
+	int (*update_clks)(struct msm_bus_fabric_device *fabdev,
+		struct msm_bus_inode_info *pme, int index,
+		uint64_t curr_clk, uint64_t req_clk,
+		uint64_t bwsum, int flag, int ctx,
+		unsigned int cl_active_flag);
+	int (*port_halt)(struct msm_bus_fabric_device *fabdev, int portid);
+	int (*port_unhalt)(struct msm_bus_fabric_device *fabdev, int portid);
+	int (*commit)(struct msm_bus_fabric_device *fabdev);
+	struct msm_bus_inode_info *(*find_node)(struct msm_bus_fabric_device
+		*fabdev, int id);
+	struct msm_bus_inode_info *(*find_gw_node)(struct msm_bus_fabric_device
+		*fabdev, int id);
+	struct list_head *(*get_gw_list)(struct msm_bus_fabric_device *fabdev);
+	void (*update_bw)(struct msm_bus_fabric_device *fabdev, struct
+		msm_bus_inode_info * hop, struct msm_bus_inode_info *info,
+		int64_t add_bw, int *master_tiers, int ctx);
+	void (*config_master)(struct msm_bus_fabric_device *fabdev,
+		struct msm_bus_inode_info *info, uint64_t req_clk,
+		uint64_t req_bw);
+	void (*config_limiter)(struct msm_bus_fabric_device *fabdev,
+		struct msm_bus_inode_info *info);
+};
+
+struct msm_bus_board_algorithm {
+	int board_nfab;
+	void (*assign_iids)(struct msm_bus_fabric_registration *fabreg,
+		int fabid);
+	int (*get_iid)(int id);
+};
+
+/**
+ * Used to store the list of fabrics and other info to be
+ * maintained outside the fabric structure.
+ * Used while calculating path, and to find fabric ptrs
+ */
+struct msm_bus_fabnodeinfo {
+	struct list_head list;
+	struct msm_bus_inode_info *info;
+};
+
+struct msm_bus_client {
+	int id;
+	struct msm_bus_scale_pdata *pdata;
+	int *src_pnode;
+	int curr;
+};
+
+uint64_t msm_bus_div64(unsigned int width, uint64_t bw);
+int msm_bus_fabric_device_register(struct msm_bus_fabric_device *fabric);
+void msm_bus_fabric_device_unregister(struct msm_bus_fabric_device *fabric);
+struct msm_bus_fabric_device *msm_bus_get_fabric_device(int fabid);
+int msm_bus_get_num_fab(void);
+
+
+int msm_bus_hw_fab_init(struct msm_bus_fabric_registration *pdata,
+	struct msm_bus_hw_algorithm *hw_algo);
+void msm_bus_board_init(struct msm_bus_fabric_registration *pdata);
+void msm_bus_board_set_nfab(struct msm_bus_fabric_registration *pdata,
+	int nfab);
+#if defined(CONFIG_MSM_RPM_SMD)
+int msm_bus_rpm_hw_init(struct msm_bus_fabric_registration *pdata,
+	struct msm_bus_hw_algorithm *hw_algo);
+int msm_bus_remote_hw_commit(struct msm_bus_fabric_registration
+	*fab_pdata, void *hw_data, void **cdata);
+void msm_bus_rpm_fill_cdata_buffer(int *curr, char *buf, const int max_size,
+	void *cdata, int nmasters, int nslaves, int ntslaves);
+#else
+static inline int msm_bus_rpm_hw_init(struct msm_bus_fabric_registration *pdata,
+	struct msm_bus_hw_algorithm *hw_algo)
+{
+	return 0;
+}
+static inline int msm_bus_remote_hw_commit(struct msm_bus_fabric_registration
+	*fab_pdata, void *hw_data, void **cdata)
+{
+	return 0;
+}
+static inline void msm_bus_rpm_fill_cdata_buffer(int *curr, char *buf,
+	const int max_size, void *cdata, int nmasters, int nslaves,
+	int ntslaves)
+{
+}
+#endif
+
+int msm_bus_noc_hw_init(struct msm_bus_fabric_registration *pdata,
+	struct msm_bus_hw_algorithm *hw_algo);
+int msm_bus_bimc_hw_init(struct msm_bus_fabric_registration *pdata,
+	struct msm_bus_hw_algorithm *hw_algo);
+#if defined(CONFIG_DEBUG_FS) && defined(CONFIG_MSM_BUS_SCALING)
+void msm_bus_dbg_client_data(struct msm_bus_scale_pdata *pdata, int index,
+	uint32_t cl);
+void msm_bus_dbg_commit_data(const char *fabname, void *cdata,
+	int nmasters, int nslaves, int ntslaves, int op);
+#else
+static inline void msm_bus_dbg_client_data(struct msm_bus_scale_pdata *pdata,
+	int index, uint32_t cl)
+{
+}
+static inline void msm_bus_dbg_commit_data(const char *fabname,
+	void *cdata, int nmasters, int nslaves, int ntslaves,
+	int op)
+{
+}
+#endif
+
+#ifdef CONFIG_CORESIGHT
+int msmbus_coresight_init(struct platform_device *pdev);
+void msmbus_coresight_remove(struct platform_device *pdev);
+int msmbus_coresight_init_adhoc(struct platform_device *pdev,
+		struct device_node *of_node);
+void msmbus_coresight_remove_adhoc(struct platform_device *pdev);
+#else
+static inline int msmbus_coresight_init(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static inline void msmbus_coresight_remove(struct platform_device *pdev)
+{
+}
+
+static inline int msmbus_coresight_init_adhoc(struct platform_device *pdev,
+		struct device_node *of_node)
+{
+	return 0;
+}
+
+static inline void msmbus_coresight_remove_adhoc(struct platform_device *pdev)
+{
+}
+#endif
+
+
+#ifdef CONFIG_OF
+void msm_bus_of_get_nfab(struct platform_device *pdev,
+		struct msm_bus_fabric_registration *pdata);
+struct msm_bus_fabric_registration
+	*msm_bus_of_get_fab_data(struct platform_device *pdev);
+#else
+static inline void msm_bus_of_get_nfab(struct platform_device *pdev,
+		struct msm_bus_fabric_registration *pdata)
+{
+	return;
+}
+
+static inline struct msm_bus_fabric_registration
+	*msm_bus_of_get_fab_data(struct platform_device *pdev)
+{
+	return NULL;
+}
+#endif
+
+#endif /*_ARCH_ARM_MACH_MSM_BUS_CORE_H*/
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_dbg.c
@@ -0,0 +1,810 @@
+/* Copyright (c) 2010-2012, 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#define pr_fmt(fmt) "AXI: %s(): " fmt, __func__
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/seq_file.h>
+#include <linux/debugfs.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/string.h>
+#include <linux/uaccess.h>
+#include <linux/hrtimer.h>
+#include "msm-bus-board.h"
+#include "msm-bus.h"
+#include "msm_bus_rules.h"
+#include "msm_bus_core.h"
+#include "msm_bus_adhoc.h"
+
+#define CREATE_TRACE_POINTS
+#include <trace/events/trace_msm_bus.h>
+
+#define MAX_BUFF_SIZE 4096
+#define FILL_LIMIT 128
+
+static struct dentry *clients;
+static struct dentry *dir;
+static DEFINE_MUTEX(msm_bus_dbg_fablist_lock);
+struct msm_bus_dbg_state {
+	uint32_t cl;
+	uint8_t enable;
+	uint8_t current_index;
+} clstate;
+
+struct msm_bus_cldata {
+	const struct msm_bus_scale_pdata *pdata;
+	int index;
+	uint32_t clid;
+	int size;
+	struct dentry *file;
+	struct list_head list;
+	char buffer[MAX_BUFF_SIZE];
+};
+
+struct msm_bus_fab_list {
+	const char *name;
+	int size;
+	struct dentry *file;
+	struct list_head list;
+	char buffer[MAX_BUFF_SIZE];
+};
+
+static char *rules_buf;
+
+LIST_HEAD(fabdata_list);
+LIST_HEAD(cl_list);
+
+/**
+ * The following structures and funtions are used for
+ * the test-client which can be created at run-time.
+ */
+
+static struct msm_bus_vectors init_vectors[1];
+static struct msm_bus_vectors current_vectors[1];
+static struct msm_bus_vectors requested_vectors[1];
+
+static struct msm_bus_paths shell_client_usecases[] = {
+	{
+		.num_paths = ARRAY_SIZE(init_vectors),
+		.vectors = init_vectors,
+	},
+	{
+		.num_paths = ARRAY_SIZE(current_vectors),
+		.vectors = current_vectors,
+	},
+	{
+		.num_paths = ARRAY_SIZE(requested_vectors),
+		.vectors = requested_vectors,
+	},
+};
+
+static struct msm_bus_scale_pdata shell_client = {
+	.usecase = shell_client_usecases,
+	.num_usecases = ARRAY_SIZE(shell_client_usecases),
+	.name = "test-client",
+};
+
+static void msm_bus_dbg_init_vectors(void)
+{
+	init_vectors[0].src = -1;
+	init_vectors[0].dst = -1;
+	init_vectors[0].ab = 0;
+	init_vectors[0].ib = 0;
+	current_vectors[0].src = -1;
+	current_vectors[0].dst = -1;
+	current_vectors[0].ab = 0;
+	current_vectors[0].ib = 0;
+	requested_vectors[0].src = -1;
+	requested_vectors[0].dst = -1;
+	requested_vectors[0].ab = 0;
+	requested_vectors[0].ib = 0;
+	clstate.enable = 0;
+	clstate.current_index = 0;
+}
+
+static int msm_bus_dbg_update_cl_request(uint32_t cl)
+{
+	int ret = 0;
+
+	if (clstate.current_index < 2)
+		clstate.current_index = 2;
+	else {
+		clstate.current_index = 1;
+		current_vectors[0].ab = requested_vectors[0].ab;
+		current_vectors[0].ib = requested_vectors[0].ib;
+	}
+
+	if (clstate.enable) {
+		MSM_BUS_DBG("Updating request for shell client, index: %d\n",
+			clstate.current_index);
+		ret = msm_bus_scale_client_update_request(clstate.cl,
+			clstate.current_index);
+	} else
+		MSM_BUS_DBG("Enable bit not set. Skipping update request\n");
+
+	return ret;
+}
+
+static void msm_bus_dbg_unregister_client(uint32_t cl)
+{
+	MSM_BUS_DBG("Unregistering shell client\n");
+	msm_bus_scale_unregister_client(clstate.cl);
+	clstate.cl = 0;
+}
+
+static uint32_t msm_bus_dbg_register_client(void)
+{
+	int ret = 0;
+
+	if (init_vectors[0].src != requested_vectors[0].src) {
+		MSM_BUS_DBG("Shell client master changed. Unregistering\n");
+		msm_bus_dbg_unregister_client(clstate.cl);
+	}
+	if (init_vectors[0].dst != requested_vectors[0].dst) {
+		MSM_BUS_DBG("Shell client slave changed. Unregistering\n");
+		msm_bus_dbg_unregister_client(clstate.cl);
+	}
+
+	current_vectors[0].src = init_vectors[0].src;
+	requested_vectors[0].src = init_vectors[0].src;
+	current_vectors[0].dst = init_vectors[0].dst;
+	requested_vectors[0].dst = init_vectors[0].dst;
+
+	if (!clstate.enable) {
+		MSM_BUS_DBG("Enable bit not set, skipping registration: cl "
+			"%d\n",	clstate.cl);
+		return 0;
+	}
+
+	if (clstate.cl) {
+		MSM_BUS_DBG("Client  registered, skipping registration\n");
+		return clstate.cl;
+	}
+
+	MSM_BUS_DBG("Registering shell client\n");
+	ret = msm_bus_scale_register_client(&shell_client);
+	return ret;
+}
+
+static int msm_bus_dbg_mas_get(void  *data, u64 *val)
+{
+	*val = init_vectors[0].src;
+	MSM_BUS_DBG("Get master: %llu\n", *val);
+	return 0;
+}
+
+static int msm_bus_dbg_mas_set(void  *data, u64 val)
+{
+	init_vectors[0].src = val;
+	MSM_BUS_DBG("Set master: %llu\n", val);
+	clstate.cl = msm_bus_dbg_register_client();
+	return 0;
+}
+DEFINE_SIMPLE_ATTRIBUTE(shell_client_mas_fops, msm_bus_dbg_mas_get,
+	msm_bus_dbg_mas_set, "%llu\n");
+
+static int msm_bus_dbg_slv_get(void  *data, u64 *val)
+{
+	*val = init_vectors[0].dst;
+	MSM_BUS_DBG("Get slave: %llu\n", *val);
+	return 0;
+}
+
+static int msm_bus_dbg_slv_set(void  *data, u64 val)
+{
+	init_vectors[0].dst = val;
+	MSM_BUS_DBG("Set slave: %llu\n", val);
+	clstate.cl = msm_bus_dbg_register_client();
+	return 0;
+}
+DEFINE_SIMPLE_ATTRIBUTE(shell_client_slv_fops, msm_bus_dbg_slv_get,
+	msm_bus_dbg_slv_set, "%llu\n");
+
+static int msm_bus_dbg_ab_get(void  *data, u64 *val)
+{
+	*val = requested_vectors[0].ab;
+	MSM_BUS_DBG("Get ab: %llu\n", *val);
+	return 0;
+}
+
+static int msm_bus_dbg_ab_set(void  *data, u64 val)
+{
+	requested_vectors[0].ab = val;
+	MSM_BUS_DBG("Set ab: %llu\n", val);
+	return 0;
+}
+DEFINE_SIMPLE_ATTRIBUTE(shell_client_ab_fops, msm_bus_dbg_ab_get,
+	msm_bus_dbg_ab_set, "%llu\n");
+
+static int msm_bus_dbg_ib_get(void  *data, u64 *val)
+{
+	*val = requested_vectors[0].ib;
+	MSM_BUS_DBG("Get ib: %llu\n", *val);
+	return 0;
+}
+
+static int msm_bus_dbg_ib_set(void  *data, u64 val)
+{
+	requested_vectors[0].ib = val;
+	MSM_BUS_DBG("Set ib: %llu\n", val);
+	return 0;
+}
+DEFINE_SIMPLE_ATTRIBUTE(shell_client_ib_fops, msm_bus_dbg_ib_get,
+	msm_bus_dbg_ib_set, "%llu\n");
+
+static int msm_bus_dbg_en_get(void  *data, u64 *val)
+{
+	*val = clstate.enable;
+	MSM_BUS_DBG("Get enable: %llu\n", *val);
+	return 0;
+}
+
+static int msm_bus_dbg_en_set(void  *data, u64 val)
+{
+	int ret = 0;
+
+	clstate.enable = val;
+	if (clstate.enable) {
+		if (!clstate.cl) {
+			MSM_BUS_DBG("client: %u\n", clstate.cl);
+			clstate.cl = msm_bus_dbg_register_client();
+			if (clstate.cl)
+				ret = msm_bus_dbg_update_cl_request(clstate.cl);
+		} else {
+			MSM_BUS_DBG("update request for cl: %u\n", clstate.cl);
+			ret = msm_bus_dbg_update_cl_request(clstate.cl);
+		}
+	}
+
+	MSM_BUS_DBG("Set enable: %llu\n", val);
+	return ret;
+}
+DEFINE_SIMPLE_ATTRIBUTE(shell_client_en_fops, msm_bus_dbg_en_get,
+	msm_bus_dbg_en_set, "%llu\n");
+
+/**
+ * The following funtions are used for viewing the client data
+ * and changing the client request at run-time
+ */
+
+static ssize_t client_data_read(struct file *file, char __user *buf,
+	size_t count, loff_t *ppos)
+{
+	int bsize = 0;
+	uint32_t cl = (uint32_t)(uintptr_t)file->private_data;
+	struct msm_bus_cldata *cldata = NULL;
+	int found = 0;
+
+	list_for_each_entry(cldata, &cl_list, list) {
+		if (cldata->clid == cl) {
+			found = 1;
+			break;
+		}
+	}
+	if (!found)
+		return 0;
+
+	bsize = cldata->size;
+	return simple_read_from_buffer(buf, count, ppos,
+		cldata->buffer, bsize);
+}
+
+static int client_data_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static const struct file_operations client_data_fops = {
+	.open		= client_data_open,
+	.read		= client_data_read,
+};
+
+struct dentry *msm_bus_dbg_create(const char *name, mode_t mode,
+	struct dentry *dent, uint32_t clid)
+{
+	if (dent == NULL) {
+		MSM_BUS_DBG("debugfs not ready yet\n");
+		return NULL;
+	}
+	return debugfs_create_file(name, mode, dent, (void *)(uintptr_t)clid,
+		&client_data_fops);
+}
+
+#if defined(CONFIG_DEBUG_FS) && defined(CONFIG_MSM_BUS_SCALING)
+static int msm_bus_dbg_record_client(const struct msm_bus_scale_pdata *pdata,
+	int index, uint32_t clid, struct dentry *file)
+{
+	struct msm_bus_cldata *cldata;
+
+	cldata = kmalloc(sizeof(struct msm_bus_cldata), GFP_KERNEL);
+	if (!cldata) {
+		MSM_BUS_DBG("Failed to allocate memory for client data\n");
+		return -ENOMEM;
+	}
+	cldata->pdata = pdata;
+	cldata->index = index;
+	cldata->clid = clid;
+	cldata->file = file;
+	cldata->size = 0;
+	list_add_tail(&cldata->list, &cl_list);
+	return 0;
+}
+
+static void msm_bus_dbg_free_client(uint32_t clid)
+{
+	struct msm_bus_cldata *cldata = NULL;
+
+	list_for_each_entry(cldata, &cl_list, list) {
+		if (cldata->clid == clid) {
+			debugfs_remove(cldata->file);
+			list_del(&cldata->list);
+			kfree(cldata);
+			break;
+		}
+	}
+}
+
+static int msm_bus_dbg_fill_cl_buffer(const struct msm_bus_scale_pdata *pdata,
+	int index, uint32_t clid)
+{
+	int i = 0, j;
+	char *buf = NULL;
+	struct msm_bus_cldata *cldata = NULL;
+	struct timespec ts;
+	int found = 0;
+
+	list_for_each_entry(cldata, &cl_list, list) {
+		if (cldata->clid == clid) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found)
+		return -ENOENT;
+
+	if (cldata->file == NULL) {
+		if (pdata->name == NULL) {
+			MSM_BUS_DBG("Client doesn't have a name\n");
+			return -EINVAL;
+		}
+		cldata->file = msm_bus_dbg_create(pdata->name, S_IRUGO,
+			clients, clid);
+	}
+
+	if (cldata->size < (MAX_BUFF_SIZE - FILL_LIMIT))
+		i = cldata->size;
+	else {
+		i = 0;
+		cldata->size = 0;
+	}
+	buf = cldata->buffer;
+	ts = ktime_to_timespec(ktime_get());
+	i += scnprintf(buf + i, MAX_BUFF_SIZE - i, "\n%d.%d\n",
+		(int)ts.tv_sec, (int)ts.tv_nsec);
+	i += scnprintf(buf + i, MAX_BUFF_SIZE - i, "curr   : %d\n", index);
+	i += scnprintf(buf + i, MAX_BUFF_SIZE - i, "masters: ");
+
+	for (j = 0; j < pdata->usecase->num_paths; j++)
+		i += scnprintf(buf + i, MAX_BUFF_SIZE - i, "%d  ",
+			pdata->usecase[index].vectors[j].src);
+	i += scnprintf(buf + i, MAX_BUFF_SIZE - i, "\nslaves : ");
+	for (j = 0; j < pdata->usecase->num_paths; j++)
+		i += scnprintf(buf + i, MAX_BUFF_SIZE - i, "%d  ",
+			pdata->usecase[index].vectors[j].dst);
+	i += scnprintf(buf + i, MAX_BUFF_SIZE - i, "\nab     : ");
+	for (j = 0; j < pdata->usecase->num_paths; j++)
+		i += scnprintf(buf + i, MAX_BUFF_SIZE - i, "%llu  ",
+			pdata->usecase[index].vectors[j].ab);
+	i += scnprintf(buf + i, MAX_BUFF_SIZE - i, "\nib     : ");
+	for (j = 0; j < pdata->usecase->num_paths; j++)
+		i += scnprintf(buf + i, MAX_BUFF_SIZE - i, "%llu  ",
+			pdata->usecase[index].vectors[j].ib);
+	i += scnprintf(buf + i, MAX_BUFF_SIZE - i, "\n");
+
+	for (j = 0; j < pdata->usecase->num_paths; j++)
+		trace_bus_update_request((int)ts.tv_sec, (int)ts.tv_nsec,
+		pdata->name, index,
+		pdata->usecase[index].vectors[j].src,
+		pdata->usecase[index].vectors[j].dst,
+		pdata->usecase[index].vectors[j].ab,
+		pdata->usecase[index].vectors[j].ib);
+
+	cldata->size = i;
+	return i;
+}
+#endif
+
+static int msm_bus_dbg_update_request(struct msm_bus_cldata *cldata, int index)
+{
+	int ret = 0;
+
+	if ((index < 0) || (index > cldata->pdata->num_usecases)) {
+		MSM_BUS_DBG("Invalid index!\n");
+		return -EINVAL;
+	}
+	ret = msm_bus_scale_client_update_request(cldata->clid, index);
+	return ret;
+}
+
+static ssize_t  msm_bus_dbg_update_request_write(struct file *file,
+	const char __user *ubuf, size_t cnt, loff_t *ppos)
+{
+	struct msm_bus_cldata *cldata;
+	unsigned long index = 0;
+	int ret = 0;
+	char *chid;
+	char *buf = kmalloc((sizeof(char) * (cnt + 1)), GFP_KERNEL);
+	int found = 0;
+
+	if (!buf || IS_ERR(buf)) {
+		MSM_BUS_ERR("Memory allocation for buffer failed\n");
+		return -ENOMEM;
+	}
+	if (cnt == 0) {
+		kfree(buf);
+		return 0;
+	}
+	if (copy_from_user(buf, ubuf, cnt)) {
+		kfree(buf);
+		return -EFAULT;
+	}
+	buf[cnt] = '\0';
+	chid = buf;
+	MSM_BUS_DBG("buffer: %s\n size: %zu\n", buf, sizeof(ubuf));
+
+	list_for_each_entry(cldata, &cl_list, list) {
+		if (strnstr(chid, cldata->pdata->name, cnt)) {
+			found = 1;
+			cldata = cldata;
+			strsep(&chid, " ");
+			if (chid) {
+				ret = kstrtoul(chid, 10, &index);
+				if (ret) {
+					MSM_BUS_DBG("Index conversion"
+						" failed\n");
+					return -EFAULT;
+				}
+			} else {
+				MSM_BUS_DBG("Error parsing input. Index not"
+					" found\n");
+				found = 0;
+			}
+			break;
+		}
+	}
+
+	if (found)
+		msm_bus_dbg_update_request(cldata, index);
+	kfree(buf);
+	return cnt;
+}
+
+/**
+ * The following funtions are used for viewing the commit data
+ * for each fabric
+ */
+static ssize_t fabric_data_read(struct file *file, char __user *buf,
+	size_t count, loff_t *ppos)
+{
+	struct msm_bus_fab_list *fablist = NULL;
+	int bsize = 0;
+	ssize_t ret;
+	const char *name = file->private_data;
+	int found = 0;
+
+	mutex_lock(&msm_bus_dbg_fablist_lock);
+	list_for_each_entry(fablist, &fabdata_list, list) {
+		if (strcmp(fablist->name, name) == 0) {
+			found = 1;
+			break;
+		}
+	}
+	if (!found)
+		return -ENOENT;
+	bsize = fablist->size;
+	ret = simple_read_from_buffer(buf, count, ppos,
+		fablist->buffer, bsize);
+	mutex_unlock(&msm_bus_dbg_fablist_lock);
+	return ret;
+}
+
+static const struct file_operations fabric_data_fops = {
+	.open		= client_data_open,
+	.read		= fabric_data_read,
+};
+
+static ssize_t rules_dbg_read(struct file *file, char __user *buf,
+	size_t count, loff_t *ppos)
+{
+	ssize_t ret;
+	memset(rules_buf, 0, MAX_BUFF_SIZE);
+	print_rules_buf(rules_buf, MAX_BUFF_SIZE);
+	ret = simple_read_from_buffer(buf, count, ppos,
+		rules_buf, MAX_BUFF_SIZE);
+	return ret;
+}
+
+static int rules_dbg_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static const struct file_operations rules_dbg_fops = {
+	.open		= rules_dbg_open,
+	.read		= rules_dbg_read,
+};
+
+#if defined(CONFIG_DEBUG_FS) && defined(CONFIG_MSM_BUS_SCALING)
+static int msm_bus_dbg_record_fabric(const char *fabname, struct dentry *file)
+{
+	struct msm_bus_fab_list *fablist;
+	int ret = 0;
+
+	mutex_lock(&msm_bus_dbg_fablist_lock);
+	fablist = kmalloc(sizeof(struct msm_bus_fab_list), GFP_KERNEL);
+	if (!fablist) {
+		MSM_BUS_DBG("Failed to allocate memory for commit data\n");
+		ret =  -ENOMEM;
+		goto err;
+	}
+
+	fablist->name = fabname;
+	fablist->size = 0;
+	list_add_tail(&fablist->list, &fabdata_list);
+err:
+	mutex_unlock(&msm_bus_dbg_fablist_lock);
+	return ret;
+}
+
+static void msm_bus_dbg_free_fabric(const char *fabname)
+{
+	struct msm_bus_fab_list *fablist = NULL;
+
+	mutex_lock(&msm_bus_dbg_fablist_lock);
+	list_for_each_entry(fablist, &fabdata_list, list) {
+		if (strcmp(fablist->name, fabname) == 0) {
+			debugfs_remove(fablist->file);
+			list_del(&fablist->list);
+			kfree(fablist);
+			break;
+		}
+	}
+	mutex_unlock(&msm_bus_dbg_fablist_lock);
+}
+
+static int msm_bus_dbg_fill_fab_buffer(const char *fabname,
+	void *cdata, int nmasters, int nslaves,
+	int ntslaves)
+{
+	int i;
+	char *buf = NULL;
+	struct msm_bus_fab_list *fablist = NULL;
+	struct timespec ts;
+	int found = 0;
+
+	mutex_lock(&msm_bus_dbg_fablist_lock);
+	list_for_each_entry(fablist, &fabdata_list, list) {
+		if (strcmp(fablist->name, fabname) == 0) {
+			found = 1;
+			break;
+		}
+	}
+	if (!found)
+		return -ENOENT;
+
+	if (fablist->file == NULL) {
+		MSM_BUS_DBG("Fabric dbg entry does not exist\n");
+		mutex_unlock(&msm_bus_dbg_fablist_lock);
+		return -EFAULT;
+	}
+
+	if (fablist->size < MAX_BUFF_SIZE - 256)
+		i = fablist->size;
+	else {
+		i = 0;
+		fablist->size = 0;
+	}
+	buf = fablist->buffer;
+	mutex_unlock(&msm_bus_dbg_fablist_lock);
+	ts = ktime_to_timespec(ktime_get());
+	i += scnprintf(buf + i, MAX_BUFF_SIZE - i, "\n%d.%d\n",
+		(int)ts.tv_sec, (int)ts.tv_nsec);
+
+	msm_bus_rpm_fill_cdata_buffer(&i, buf, MAX_BUFF_SIZE, cdata,
+		nmasters, nslaves, ntslaves);
+	i += scnprintf(buf + i, MAX_BUFF_SIZE - i, "\n");
+	mutex_lock(&msm_bus_dbg_fablist_lock);
+	fablist->size = i;
+	mutex_unlock(&msm_bus_dbg_fablist_lock);
+	return 0;
+}
+#endif
+
+static const struct file_operations msm_bus_dbg_update_request_fops = {
+	.open = client_data_open,
+	.write = msm_bus_dbg_update_request_write,
+};
+
+#if defined(CONFIG_DEBUG_FS) && defined(CONFIG_MSM_BUS_SCALING)
+/**
+ * msm_bus_dbg_client_data() - Add debug data for clients
+ * @pdata: Platform data of the client
+ * @index: The current index or operation to be performed
+ * @clid: Client handle obtained during registration
+ */
+void msm_bus_dbg_client_data(struct msm_bus_scale_pdata *pdata, int index,
+	uint32_t clid)
+{
+	struct dentry *file = NULL;
+
+	if (index == MSM_BUS_DBG_REGISTER) {
+		msm_bus_dbg_record_client(pdata, index, clid, file);
+		if (!pdata->name) {
+			MSM_BUS_DBG("Cannot create debugfs entry. Null name\n");
+			return;
+		}
+	} else if (index == MSM_BUS_DBG_UNREGISTER) {
+		msm_bus_dbg_free_client(clid);
+		MSM_BUS_DBG("Client %d unregistered\n", clid);
+	} else
+		msm_bus_dbg_fill_cl_buffer(pdata, index, clid);
+}
+EXPORT_SYMBOL(msm_bus_dbg_client_data);
+
+/**
+ * msm_bus_dbg_commit_data() - Add commit data from fabrics
+ * @fabname: Fabric name specified in platform data
+ * @cdata: Commit Data
+ * @nmasters: Number of masters attached to fabric
+ * @nslaves: Number of slaves attached to fabric
+ * @ntslaves: Number of tiered slaves attached to fabric
+ * @op: Operation to be performed
+ */
+void msm_bus_dbg_commit_data(const char *fabname, void *cdata,
+	int nmasters, int nslaves, int ntslaves, int op)
+{
+	struct dentry *file = NULL;
+
+	if (op == MSM_BUS_DBG_REGISTER)
+		msm_bus_dbg_record_fabric(fabname, file);
+	else if (op == MSM_BUS_DBG_UNREGISTER)
+		msm_bus_dbg_free_fabric(fabname);
+	else
+		msm_bus_dbg_fill_fab_buffer(fabname, cdata, nmasters,
+			nslaves, ntslaves);
+}
+EXPORT_SYMBOL(msm_bus_dbg_commit_data);
+#endif
+
+static int __init msm_bus_debugfs_init(void)
+{
+	struct dentry *commit, *shell_client, *rules_dbg;
+	struct msm_bus_fab_list *fablist;
+	struct msm_bus_cldata *cldata = NULL;
+	uint64_t val = 0;
+
+	dir = debugfs_create_dir("msm-bus-dbg", NULL);
+	if ((!dir) || IS_ERR(dir)) {
+		MSM_BUS_ERR("Couldn't create msm-bus-dbg\n");
+		goto err;
+	}
+
+	clients = debugfs_create_dir("client-data", dir);
+	if ((!dir) || IS_ERR(dir)) {
+		MSM_BUS_ERR("Couldn't create clients\n");
+		goto err;
+	}
+
+	shell_client = debugfs_create_dir("shell-client", dir);
+	if ((!dir) || IS_ERR(dir)) {
+		MSM_BUS_ERR("Couldn't create clients\n");
+		goto err;
+	}
+
+	commit = debugfs_create_dir("commit-data", dir);
+	if ((!dir) || IS_ERR(dir)) {
+		MSM_BUS_ERR("Couldn't create commit\n");
+		goto err;
+	}
+
+	rules_dbg = debugfs_create_dir("rules-dbg", dir);
+	if ((!rules_dbg) || IS_ERR(rules_dbg)) {
+		MSM_BUS_ERR("Couldn't create rules-dbg\n");
+		goto err;
+	}
+
+	if (debugfs_create_file("print_rules", S_IRUGO | S_IWUSR,
+		rules_dbg, &val, &rules_dbg_fops) == NULL)
+		goto err;
+
+	if (debugfs_create_file("update_request", S_IRUGO | S_IWUSR,
+		shell_client, &val, &shell_client_en_fops) == NULL)
+		goto err;
+	if (debugfs_create_file("ib", S_IRUGO | S_IWUSR, shell_client, &val,
+		&shell_client_ib_fops) == NULL)
+		goto err;
+	if (debugfs_create_file("ab", S_IRUGO | S_IWUSR, shell_client, &val,
+		&shell_client_ab_fops) == NULL)
+		goto err;
+	if (debugfs_create_file("slv", S_IRUGO | S_IWUSR, shell_client,
+		&val, &shell_client_slv_fops) == NULL)
+		goto err;
+	if (debugfs_create_file("mas", S_IRUGO | S_IWUSR, shell_client,
+		&val, &shell_client_mas_fops) == NULL)
+		goto err;
+	if (debugfs_create_file("update-request", S_IRUGO | S_IWUSR,
+		clients, NULL, &msm_bus_dbg_update_request_fops) == NULL)
+		goto err;
+
+	rules_buf = kzalloc(MAX_BUFF_SIZE, GFP_KERNEL);
+	if (!rules_buf) {
+		MSM_BUS_ERR("Failed to alloc rules_buf");
+		goto err;
+	}
+
+	list_for_each_entry(cldata, &cl_list, list) {
+		if (cldata->pdata->name == NULL) {
+			MSM_BUS_DBG("Client name not found\n");
+			continue;
+		}
+		cldata->file = msm_bus_dbg_create(cldata->
+			pdata->name, S_IRUGO, clients, cldata->clid);
+	}
+
+	mutex_lock(&msm_bus_dbg_fablist_lock);
+	list_for_each_entry(fablist, &fabdata_list, list) {
+		fablist->file = debugfs_create_file(fablist->name, S_IRUGO,
+			commit, (void *)fablist->name, &fabric_data_fops);
+		if (fablist->file == NULL) {
+			MSM_BUS_DBG("Cannot create files for commit data\n");
+			kfree(rules_buf);
+			goto err;
+		}
+	}
+	mutex_unlock(&msm_bus_dbg_fablist_lock);
+
+	msm_bus_dbg_init_vectors();
+	return 0;
+err:
+	debugfs_remove_recursive(dir);
+	return -ENODEV;
+}
+late_initcall(msm_bus_debugfs_init);
+
+static void __exit msm_bus_dbg_teardown(void)
+{
+	struct msm_bus_fab_list *fablist = NULL, *fablist_temp;
+	struct msm_bus_cldata *cldata = NULL, *cldata_temp;
+
+	debugfs_remove_recursive(dir);
+	list_for_each_entry_safe(cldata, cldata_temp, &cl_list, list) {
+		list_del(&cldata->list);
+		kfree(cldata);
+	}
+	mutex_lock(&msm_bus_dbg_fablist_lock);
+	list_for_each_entry_safe(fablist, fablist_temp, &fabdata_list, list) {
+		list_del(&fablist->list);
+		kfree(fablist);
+	}
+	kfree(rules_buf);
+	mutex_unlock(&msm_bus_dbg_fablist_lock);
+}
+module_exit(msm_bus_dbg_teardown);
+MODULE_DESCRIPTION("Debugfs for msm bus scaling client");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Gagan Mac <gmac@codeaurora.org>");
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_fabric_adhoc.c
@@ -0,0 +1,1281 @@
+/* Copyright (c) 2014, Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include "rpm-smd.h"
+#include "msm_bus_core.h"
+#include "msm_bus_adhoc.h"
+#include "msm_bus_noc.h"
+#include "msm_bus_bimc.h"
+
+ssize_t vrail_show(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct msm_bus_node_info_type *node_info = NULL;
+	struct msm_bus_node_device_type *bus_node = NULL;
+
+	bus_node = dev->platform_data;
+	if (!bus_node)
+		return -EINVAL;
+	node_info = bus_node->node_info;
+
+	return snprintf(buf, PAGE_SIZE, "%u", node_info->vrail_comp);
+}
+
+ssize_t vrail_store(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct msm_bus_node_info_type *node_info = NULL;
+	struct msm_bus_node_device_type *bus_node = NULL;
+	int ret = 0;
+
+	bus_node = dev->platform_data;
+	if (!bus_node)
+		return -EINVAL;
+	node_info = bus_node->node_info;
+
+	ret = sscanf(buf, "%u", &node_info->vrail_comp);
+	if (ret != 1)
+		return -EINVAL;
+	return count;
+}
+
+DEVICE_ATTR(vrail, 0600, vrail_show, vrail_store);
+
+struct static_rules_type {
+	int num_rules;
+	struct bus_rule_type *rules;
+};
+
+static struct static_rules_type static_rules;
+
+static int enable_nodeclk(struct nodeclk *nclk)
+{
+	int ret = 0;
+
+	if (!nclk->enable) {
+		ret = clk_prepare_enable(nclk->clk);
+
+		if (ret) {
+			MSM_BUS_ERR("%s: failed to enable clk ", __func__);
+			nclk->enable = false;
+		} else
+			nclk->enable = true;
+	}
+	return ret;
+}
+
+static int disable_nodeclk(struct nodeclk *nclk)
+{
+	int ret = 0;
+
+	if (nclk->enable) {
+		clk_disable_unprepare(nclk->clk);
+		nclk->enable = false;
+	}
+	return ret;
+}
+
+static int setrate_nodeclk(struct nodeclk *nclk, long rate)
+{
+	int ret = 0;
+
+	ret = clk_set_rate(nclk->clk, rate);
+
+	if (ret)
+		MSM_BUS_ERR("%s: failed to setrate clk", __func__);
+	return ret;
+}
+
+static int msm_bus_agg_fab_clks(struct device *bus_dev, void *data)
+{
+	struct msm_bus_node_device_type *node = NULL;
+	int ret = 0;
+	int ctx = *(int *)data;
+
+	if (ctx >= NUM_CTX) {
+		MSM_BUS_ERR("%s: Invalid Context %d", __func__, ctx);
+		goto exit_agg_fab_clks;
+	}
+
+	node = bus_dev->platform_data;
+	if (!node) {
+		MSM_BUS_ERR("%s: Can't get device info", __func__);
+		goto exit_agg_fab_clks;
+	}
+
+	if (!node->node_info->is_fab_dev) {
+		struct msm_bus_node_device_type *bus_dev = NULL;
+
+		bus_dev = node->node_info->bus_device->platform_data;
+
+		if (node->cur_clk_hz[ctx] >= bus_dev->cur_clk_hz[ctx])
+			bus_dev->cur_clk_hz[ctx] = node->cur_clk_hz[ctx];
+	}
+
+exit_agg_fab_clks:
+	return ret;
+}
+
+static int msm_bus_reset_fab_clks(struct device *bus_dev, void *data)
+{
+	struct msm_bus_node_device_type *node = NULL;
+	int ret = 0;
+	int ctx = *(int *)data;
+
+	if (ctx >= NUM_CTX) {
+		MSM_BUS_ERR("%s: Invalid Context %d", __func__, ctx);
+		goto exit_reset_fab_clks;
+	}
+
+	node = bus_dev->platform_data;
+	if (!node) {
+		MSM_BUS_ERR("%s: Can't get device info", __func__);
+		goto exit_reset_fab_clks;
+	}
+
+	if (node->node_info->is_fab_dev) {
+		node->cur_clk_hz[ctx] = 0;
+		MSM_BUS_DBG("Resetting for node %d", node->node_info->id);
+	}
+exit_reset_fab_clks:
+	return ret;
+}
+
+
+static int send_rpm_msg(struct device *device)
+{
+	int ret = 0;
+	int ctx;
+	int rsc_type;
+	struct msm_bus_node_device_type *ndev =
+					device->platform_data;
+	struct msm_rpm_kvp rpm_kvp;
+
+	if (!ndev) {
+		MSM_BUS_ERR("%s: Error getting node info.", __func__);
+		ret = -ENODEV;
+		goto exit_send_rpm_msg;
+	}
+
+	rpm_kvp.length = sizeof(uint64_t);
+	rpm_kvp.key = RPM_MASTER_FIELD_BW;
+
+	for (ctx = MSM_RPM_CTX_ACTIVE_SET; ctx <= MSM_RPM_CTX_SLEEP_SET;
+					ctx++) {
+		if (ctx == MSM_RPM_CTX_ACTIVE_SET)
+			rpm_kvp.data =
+			(uint8_t *)&ndev->node_ab.ab[MSM_RPM_CTX_ACTIVE_SET];
+		else {
+			rpm_kvp.data =
+			(uint8_t *) &ndev->node_ab.ab[MSM_RPM_CTX_SLEEP_SET];
+		}
+
+		if (ndev->node_info->mas_rpm_id != -1) {
+			rsc_type = RPM_BUS_MASTER_REQ;
+			ret = msm_rpm_send_message(ctx, rsc_type,
+				ndev->node_info->mas_rpm_id, &rpm_kvp, 1);
+			if (ret) {
+				MSM_BUS_ERR("%s: Failed to send RPM message:",
+						__func__);
+				MSM_BUS_ERR("%s:Node Id %d RPM id %d",
+				__func__, ndev->node_info->id,
+					 ndev->node_info->mas_rpm_id);
+				goto exit_send_rpm_msg;
+			}
+		}
+
+		if (ndev->node_info->slv_rpm_id != -1) {
+			rsc_type = RPM_BUS_SLAVE_REQ;
+			ret = msm_rpm_send_message(ctx, rsc_type,
+				ndev->node_info->slv_rpm_id, &rpm_kvp, 1);
+			if (ret) {
+				MSM_BUS_ERR("%s: Failed to send RPM message:",
+							__func__);
+				MSM_BUS_ERR("%s: Node Id %d RPM id %d",
+				__func__, ndev->node_info->id,
+					ndev->node_info->slv_rpm_id);
+				goto exit_send_rpm_msg;
+			}
+		}
+	}
+exit_send_rpm_msg:
+	return ret;
+}
+
+static int flush_bw_data(struct device *node_device, int ctx)
+{
+	struct msm_bus_node_device_type *node_info;
+	int ret = 0;
+
+	node_info = node_device->platform_data;
+	if (!node_info) {
+		MSM_BUS_ERR("%s: Unable to find bus device for device",
+			__func__);
+		ret = -ENODEV;
+		goto exit_flush_bw_data;
+	}
+
+	if (node_info->node_ab.dirty) {
+		if (node_info->ap_owned) {
+			struct msm_bus_node_device_type *bus_device =
+				node_info->node_info->bus_device->platform_data;
+			struct msm_bus_fab_device_type *fabdev =
+							bus_device->fabdev;
+
+			if (fabdev && fabdev->noc_ops.update_bw_reg &&
+				fabdev->noc_ops.update_bw_reg
+					(node_info->node_info->qos_params.mode))
+				ret = fabdev->noc_ops.set_bw(node_info,
+							fabdev->qos_base,
+							fabdev->base_offset,
+							fabdev->qos_off,
+							fabdev->qos_freq);
+		} else {
+			ret = send_rpm_msg(node_device);
+
+			if (ret)
+				MSM_BUS_ERR("%s: Failed to send RPM msg for%d",
+				__func__, node_info->node_info->id);
+		}
+		node_info->node_ab.dirty = false;
+	}
+
+exit_flush_bw_data:
+	return ret;
+
+}
+
+static int flush_clk_data(struct device *node_device, int ctx)
+{
+	struct msm_bus_node_device_type *node;
+	struct nodeclk *nodeclk = NULL;
+	int ret = 0;
+
+	node = node_device->platform_data;
+	if (!node) {
+		MSM_BUS_ERR("Unable to find bus device");
+		ret = -ENODEV;
+		goto exit_flush_clk_data;
+	}
+
+	nodeclk = &node->clk[ctx];
+	if (node->node_info->is_fab_dev) {
+		if (nodeclk->rate != node->cur_clk_hz[ctx]) {
+			nodeclk->rate = node->cur_clk_hz[ctx];
+			nodeclk->dirty = true;
+		}
+	}
+
+	if (nodeclk && nodeclk->clk && nodeclk->dirty) {
+		long rounded_rate;
+
+		if (nodeclk->rate) {
+			rounded_rate = clk_round_rate(nodeclk->clk,
+							nodeclk->rate);
+			ret = setrate_nodeclk(nodeclk, rounded_rate);
+
+			if (ret) {
+				MSM_BUS_ERR("%s: Failed to set_rate %lu for %d",
+					__func__, rounded_rate,
+						node->node_info->id);
+				ret = -ENODEV;
+				goto exit_flush_clk_data;
+			}
+
+			ret = enable_nodeclk(nodeclk);
+		} else
+			ret = disable_nodeclk(nodeclk);
+
+		if (ret) {
+			MSM_BUS_ERR("%s: Failed to enable for %d", __func__,
+						node->node_info->id);
+			ret = -ENODEV;
+			goto exit_flush_clk_data;
+		}
+		MSM_BUS_DBG("%s: Updated %d clk to %llu", __func__,
+				node->node_info->id, nodeclk->rate);
+
+	}
+exit_flush_clk_data:
+	/* Reset the aggregated clock rate for fab devices*/
+	if (node && node->node_info->is_fab_dev)
+		node->cur_clk_hz[ctx] = 0;
+
+	if (nodeclk)
+		nodeclk->dirty = 0;
+	return ret;
+}
+
+int msm_bus_commit_data(int *dirty_nodes, int ctx, int num_dirty)
+{
+	int ret = 0;
+	int i = 0;
+
+	/* Aggregate the bus clocks */
+	bus_for_each_dev(&msm_bus_type, NULL, (void *)&ctx,
+				msm_bus_agg_fab_clks);
+
+	for (i = 0; i < num_dirty; i++) {
+		struct device *node_device =
+					bus_find_device(&msm_bus_type, NULL,
+						(void *)&dirty_nodes[i],
+						msm_bus_device_match_adhoc);
+
+		if (!node_device) {
+			MSM_BUS_ERR("Can't find device for %d", dirty_nodes[i]);
+			continue;
+		}
+
+		ret = flush_bw_data(node_device, ctx);
+		if (ret)
+			MSM_BUS_ERR("%s: Error flushing bw data for node %d",
+					__func__, dirty_nodes[i]);
+
+		ret = flush_clk_data(node_device, ctx);
+		if (ret)
+			MSM_BUS_ERR("%s: Error flushing clk data for node %d",
+					__func__, dirty_nodes[i]);
+	}
+	kfree(dirty_nodes);
+	/* Aggregate the bus clocks */
+	bus_for_each_dev(&msm_bus_type, NULL, (void *)&ctx,
+				msm_bus_reset_fab_clks);
+	return ret;
+}
+
+void *msm_bus_realloc_devmem(struct device *dev, void *p, size_t old_size,
+					size_t new_size, gfp_t flags)
+{
+	void *ret;
+	size_t copy_size = old_size;
+
+	if (!new_size) {
+		devm_kfree(dev, p);
+		return ZERO_SIZE_PTR;
+	}
+
+	if (new_size < old_size)
+		copy_size = new_size;
+
+	ret = devm_kzalloc(dev, new_size, flags);
+	if (!ret) {
+		MSM_BUS_ERR("%s: Error Reallocating memory", __func__);
+		goto exit_realloc_devmem;
+	}
+
+	memcpy(ret, p, copy_size);
+	devm_kfree(dev, p);
+exit_realloc_devmem:
+	return ret;
+}
+
+
+static int add_dirty_node(int **dirty_nodes, int id, int *num_dirty)
+{
+	int i;
+	int found = 0;
+	int ret = 0;
+	int *dnode = NULL;
+
+	for (i = 0; i < *num_dirty; i++) {
+		if ((*dirty_nodes)[i] == id) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		(*num_dirty)++;
+		dnode =
+			krealloc(*dirty_nodes, sizeof(int) * (*num_dirty),
+								GFP_KERNEL);
+
+		if (ZERO_OR_NULL_PTR(dnode)) {
+			MSM_BUS_ERR("%s: Failure allocating dirty nodes array",
+								 __func__);
+			ret = -ENOMEM;
+		} else {
+			*dirty_nodes = dnode;
+			(*dirty_nodes)[(*num_dirty) - 1] = id;
+		}
+	}
+
+	return ret;
+}
+
+int msm_bus_update_bw(struct msm_bus_node_device_type *nodedev, int ctx,
+			int64_t add_bw, int **dirty_nodes, int *num_dirty)
+{
+	int ret = 0;
+	int i, j;
+	uint64_t cur_ab_slp = 0;
+	uint64_t cur_ab_act = 0;
+
+	if (nodedev->node_info->virt_dev)
+		goto exit_update_bw;
+
+	for (i = 0; i < NUM_CTX; i++) {
+		for (j = 0; j < nodedev->num_lnodes; j++) {
+			if (i == DUAL_CTX) {
+				cur_ab_act +=
+					nodedev->lnode_list[j].lnode_ab[i];
+				cur_ab_slp +=
+					nodedev->lnode_list[j].lnode_ab[i];
+			} else
+				cur_ab_act +=
+					nodedev->lnode_list[j].lnode_ab[i];
+		}
+	}
+
+	if (nodedev->node_ab.ab[MSM_RPM_CTX_ACTIVE_SET] != cur_ab_act) {
+		nodedev->node_ab.ab[MSM_RPM_CTX_ACTIVE_SET] = cur_ab_act;
+		nodedev->node_ab.ab[MSM_RPM_CTX_SLEEP_SET] = cur_ab_slp;
+		nodedev->node_ab.dirty = true;
+		ret = add_dirty_node(dirty_nodes, nodedev->node_info->id,
+								num_dirty);
+
+		if (ret) {
+			MSM_BUS_ERR("%s: Failed to add dirty node %d", __func__,
+						nodedev->node_info->id);
+			goto exit_update_bw;
+		}
+	}
+
+exit_update_bw:
+	return ret;
+}
+
+int msm_bus_update_clks(struct msm_bus_node_device_type *nodedev,
+		int ctx, int **dirty_nodes, int *num_dirty)
+{
+	int status = 0;
+	struct nodeclk *nodeclk;
+	struct nodeclk *busclk;
+	struct msm_bus_node_device_type *bus_info = NULL;
+	uint64_t req_clk;
+
+	bus_info = nodedev->node_info->bus_device->platform_data;
+
+	if (!bus_info) {
+		MSM_BUS_ERR("%s: Unable to find bus device for device %d",
+			__func__, nodedev->node_info->id);
+		status = -ENODEV;
+		goto exit_set_clks;
+	}
+
+	req_clk = nodedev->cur_clk_hz[ctx];
+	busclk = &bus_info->clk[ctx];
+
+	if (busclk->rate != req_clk) {
+		busclk->rate = req_clk;
+		busclk->dirty = 1;
+		MSM_BUS_DBG("%s: Modifying bus clk %d Rate %llu", __func__,
+					bus_info->node_info->id, req_clk);
+		status = add_dirty_node(dirty_nodes, bus_info->node_info->id,
+								num_dirty);
+
+		if (status) {
+			MSM_BUS_ERR("%s: Failed to add dirty node %d", __func__,
+						bus_info->node_info->id);
+			goto exit_set_clks;
+		}
+	}
+
+	req_clk = nodedev->cur_clk_hz[ctx];
+	nodeclk = &nodedev->clk[ctx];
+
+	if (IS_ERR_OR_NULL(nodeclk))
+		goto exit_set_clks;
+
+	if (!nodeclk->dirty || (nodeclk->dirty && (nodeclk->rate < req_clk))) {
+		nodeclk->rate = req_clk;
+		nodeclk->dirty = 1;
+		MSM_BUS_DBG("%s: Modifying node clk %d Rate %llu", __func__,
+					nodedev->node_info->id, req_clk);
+		status = add_dirty_node(dirty_nodes, nodedev->node_info->id,
+								num_dirty);
+		if (status) {
+			MSM_BUS_ERR("%s: Failed to add dirty node %d", __func__,
+						nodedev->node_info->id);
+			goto exit_set_clks;
+		}
+	}
+
+exit_set_clks:
+	return status;
+}
+
+static void msm_bus_fab_init_noc_ops(struct msm_bus_node_device_type *bus_dev)
+{
+	switch (bus_dev->fabdev->bus_type) {
+	case MSM_BUS_NOC:
+		msm_bus_noc_set_ops(bus_dev);
+		break;
+	case MSM_BUS_BIMC:
+		msm_bus_bimc_set_ops(bus_dev);
+		break;
+	default:
+		MSM_BUS_ERR("%s: Invalid Bus type", __func__);
+	}
+}
+
+static int msm_bus_qos_disable_clk(struct msm_bus_node_device_type *node,
+				int disable_bus_qos_clk)
+{
+	struct msm_bus_node_device_type *bus_node = NULL;
+	int ret = 0;
+
+	if (!node) {
+		ret = -ENXIO;
+		goto exit_disable_qos_clk;
+	}
+
+	bus_node = node->node_info->bus_device->platform_data;
+
+	if (!bus_node) {
+		ret = -ENXIO;
+		goto exit_disable_qos_clk;
+	}
+
+	if (disable_bus_qos_clk)
+		ret = disable_nodeclk(&bus_node->clk[DUAL_CTX]);
+
+	if (ret) {
+		MSM_BUS_ERR("%s: Failed to disable bus clk, node %d",
+			__func__, node->node_info->id);
+		goto exit_disable_qos_clk;
+	}
+
+	if (!IS_ERR_OR_NULL(node->qos_clk.clk)) {
+		ret = disable_nodeclk(&node->qos_clk);
+
+		if (ret) {
+			MSM_BUS_ERR("%s: Failed to disable mas qos clk,node %d",
+				__func__, node->node_info->id);
+			goto exit_disable_qos_clk;
+		}
+	}
+
+exit_disable_qos_clk:
+	return ret;
+}
+
+static int msm_bus_qos_enable_clk(struct msm_bus_node_device_type *node)
+{
+	struct msm_bus_node_device_type *bus_node = NULL;
+	long rounded_rate;
+	int ret = 0;
+	int bus_qos_enabled = 0;
+
+	if (!node) {
+		ret = -ENXIO;
+		goto exit_enable_qos_clk;
+	}
+
+	bus_node = node->node_info->bus_device->platform_data;
+
+	if (!bus_node) {
+		ret = -ENXIO;
+		goto exit_enable_qos_clk;
+	}
+
+	/* Check if the bus clk is already set before trying to set it
+	 * Do this only during
+	 *	a. Bootup
+	 *	b. Only for bus clks
+	 **/
+	if (!clk_get_rate(bus_node->clk[DUAL_CTX].clk)) {
+		rounded_rate = clk_round_rate(bus_node->clk[DUAL_CTX].clk, 1);
+		ret = setrate_nodeclk(&bus_node->clk[DUAL_CTX], rounded_rate);
+		if (ret) {
+			MSM_BUS_ERR("%s: Failed to set bus clk, node %d",
+				__func__, node->node_info->id);
+			goto exit_enable_qos_clk;
+		}
+
+		ret = enable_nodeclk(&bus_node->clk[DUAL_CTX]);
+		if (ret) {
+			MSM_BUS_ERR("%s: Failed to enable bus clk, node %d",
+				__func__, node->node_info->id);
+			goto exit_enable_qos_clk;
+		}
+		bus_qos_enabled = 1;
+	}
+
+	if (!IS_ERR_OR_NULL(node->qos_clk.clk)) {
+		rounded_rate = clk_round_rate(node->qos_clk.clk, 1);
+		ret = setrate_nodeclk(&node->qos_clk, rounded_rate);
+		if (ret) {
+			MSM_BUS_ERR("%s: Failed to enable mas qos clk, node %d",
+				__func__, node->node_info->id);
+			goto exit_enable_qos_clk;
+		}
+
+		ret = enable_nodeclk(&node->qos_clk);
+		if (ret) {
+			MSM_BUS_ERR("Err enable mas qos clk, node %d ret %d",
+				node->node_info->id, ret);
+			goto exit_enable_qos_clk;
+		}
+	}
+	ret = bus_qos_enabled;
+
+exit_enable_qos_clk:
+	return ret;
+}
+
+int msm_bus_enable_limiter(struct msm_bus_node_device_type *node_dev,
+				bool enable, uint64_t lim_bw)
+{
+	int ret = 0;
+	struct msm_bus_node_device_type *bus_node_dev;
+
+	if (!node_dev) {
+		MSM_BUS_ERR("No device specified");
+		ret = -ENXIO;
+		goto exit_enable_limiter;
+	}
+
+	if (!node_dev->ap_owned) {
+		MSM_BUS_ERR("Device is not AP owned %d.",
+						node_dev->node_info->id);
+		ret = -ENXIO;
+		goto exit_enable_limiter;
+	}
+
+	bus_node_dev = node_dev->node_info->bus_device->platform_data;
+	if (!bus_node_dev) {
+		MSM_BUS_ERR("Unable to get bus device infofor %d",
+			node_dev->node_info->id);
+		ret = -ENXIO;
+		goto exit_enable_limiter;
+	}
+	if (bus_node_dev->fabdev &&
+		bus_node_dev->fabdev->noc_ops.limit_mport) {
+		ret = msm_bus_qos_enable_clk(node_dev);
+		if (ret < 0) {
+			MSM_BUS_ERR("Can't Enable QoS clk %d",
+				node_dev->node_info->id);
+			goto exit_enable_limiter;
+		}
+		bus_node_dev->fabdev->noc_ops.limit_mport(
+				node_dev,
+				bus_node_dev->fabdev->qos_base,
+				bus_node_dev->fabdev->base_offset,
+				bus_node_dev->fabdev->qos_off,
+				bus_node_dev->fabdev->qos_freq,
+				enable, lim_bw);
+		msm_bus_qos_disable_clk(node_dev, ret);
+	}
+
+exit_enable_limiter:
+	return ret;
+}
+
+static int msm_bus_dev_init_qos(struct device *dev, void *data)
+{
+	int ret = 0;
+	struct msm_bus_node_device_type *node_dev = NULL;
+
+	node_dev = dev->platform_data;
+
+	if (!node_dev) {
+		MSM_BUS_ERR("%s: Unable to get node device info" , __func__);
+		ret = -ENXIO;
+		goto exit_init_qos;
+	}
+
+	MSM_BUS_DBG("Device = %d", node_dev->node_info->id);
+
+	if (node_dev->ap_owned) {
+		struct msm_bus_node_device_type *bus_node_info;
+
+		bus_node_info = node_dev->node_info->bus_device->platform_data;
+
+		if (!bus_node_info) {
+			MSM_BUS_ERR("%s: Unable to get bus device infofor %d",
+				__func__,
+				node_dev->node_info->id);
+			ret = -ENXIO;
+			goto exit_init_qos;
+		}
+
+		if (bus_node_info->fabdev &&
+			bus_node_info->fabdev->noc_ops.qos_init) {
+			int ret = 0;
+
+			if (node_dev->ap_owned &&
+				(node_dev->node_info->qos_params.mode) != -1) {
+
+				if (bus_node_info->fabdev->bypass_qos_prg)
+					goto exit_init_qos;
+
+				ret = msm_bus_qos_enable_clk(node_dev);
+				if (ret < 0) {
+					MSM_BUS_ERR("Can't Enable QoS clk %d",
+					node_dev->node_info->id);
+					goto exit_init_qos;
+				}
+
+				bus_node_info->fabdev->noc_ops.qos_init(
+					node_dev,
+					bus_node_info->fabdev->qos_base,
+					bus_node_info->fabdev->base_offset,
+					bus_node_info->fabdev->qos_off,
+					bus_node_info->fabdev->qos_freq);
+				msm_bus_qos_disable_clk(node_dev, ret);
+			}
+		} else
+			MSM_BUS_ERR("%s: Skipping QOS init for %d",
+				__func__, node_dev->node_info->id);
+	}
+exit_init_qos:
+	return ret;
+}
+
+static int msm_bus_fabric_init(struct device *dev,
+			struct msm_bus_node_device_type *pdata)
+{
+	struct msm_bus_fab_device_type *fabdev;
+	struct msm_bus_node_device_type *node_dev = NULL;
+	int ret = 0;
+
+	node_dev = dev->platform_data;
+	if (!node_dev) {
+		MSM_BUS_ERR("%s: Unable to get bus device info" , __func__);
+		ret = -ENXIO;
+		goto exit_fabric_init;
+	}
+
+	if (node_dev->node_info->virt_dev) {
+		MSM_BUS_ERR("%s: Skip Fab init for virtual device %d", __func__,
+						node_dev->node_info->id);
+		goto exit_fabric_init;
+	}
+
+	fabdev = devm_kzalloc(dev, sizeof(struct msm_bus_fab_device_type),
+								GFP_KERNEL);
+	if (!fabdev) {
+		MSM_BUS_ERR("Fabric alloc failed\n");
+		ret = -ENOMEM;
+		goto exit_fabric_init;
+	}
+
+	node_dev->fabdev = fabdev;
+	fabdev->pqos_base = pdata->fabdev->pqos_base;
+	fabdev->qos_range = pdata->fabdev->qos_range;
+	fabdev->base_offset = pdata->fabdev->base_offset;
+	fabdev->qos_off = pdata->fabdev->qos_off;
+	fabdev->qos_freq = pdata->fabdev->qos_freq;
+	fabdev->bus_type = pdata->fabdev->bus_type;
+	fabdev->bypass_qos_prg = pdata->fabdev->bypass_qos_prg;
+	fabdev->util_fact = pdata->fabdev->util_fact;
+	fabdev->vrail_comp = pdata->fabdev->vrail_comp;
+	msm_bus_fab_init_noc_ops(node_dev);
+
+	fabdev->qos_base = devm_ioremap(dev,
+				fabdev->pqos_base, fabdev->qos_range);
+	if (!fabdev->qos_base) {
+		MSM_BUS_ERR("%s: Error remapping address 0x%zx :bus device %d",
+			__func__,
+			 (size_t)fabdev->pqos_base, node_dev->node_info->id);
+		ret = -ENOMEM;
+		goto exit_fabric_init;
+	}
+
+	/*if (msmbus_coresight_init(pdev))
+		pr_warn("Coresight support absent for bus: %d\n", pdata->id);*/
+exit_fabric_init:
+	return ret;
+}
+
+static int msm_bus_init_clk(struct device *bus_dev,
+				struct msm_bus_node_device_type *pdata)
+{
+	unsigned int ctx;
+	int ret = 0;
+	struct msm_bus_node_device_type *node_dev = bus_dev->platform_data;
+
+	for (ctx = 0; ctx < NUM_CTX; ctx++) {
+		if (!IS_ERR_OR_NULL(pdata->clk[ctx].clk)) {
+			node_dev->clk[ctx].clk = pdata->clk[ctx].clk;
+			node_dev->clk[ctx].enable = false;
+			node_dev->clk[ctx].dirty = false;
+			MSM_BUS_ERR("%s: Valid node clk node %d ctx %d",
+				__func__, node_dev->node_info->id, ctx);
+		}
+	}
+
+	if (!IS_ERR_OR_NULL(pdata->qos_clk.clk)) {
+		node_dev->qos_clk.clk = pdata->qos_clk.clk;
+		node_dev->qos_clk.enable = false;
+		MSM_BUS_ERR("%s: Valid Iface clk node %d", __func__,
+						node_dev->node_info->id);
+	}
+
+	return ret;
+}
+
+static int msm_bus_copy_node_info(struct msm_bus_node_device_type *pdata,
+				struct device *bus_dev)
+{
+	int ret = 0;
+	struct msm_bus_node_info_type *node_info = NULL;
+	struct msm_bus_node_info_type *pdata_node_info = NULL;
+	struct msm_bus_node_device_type *bus_node = NULL;
+
+	bus_node = bus_dev->platform_data;
+
+	if (!bus_node || !pdata) {
+		ret = -ENXIO;
+		MSM_BUS_ERR("%s: Invalid pointers pdata %p, bus_node %p",
+			__func__, pdata, bus_node);
+		goto exit_copy_node_info;
+	}
+
+	node_info = bus_node->node_info;
+	pdata_node_info = pdata->node_info;
+
+	node_info->name = pdata_node_info->name;
+	node_info->id =  pdata_node_info->id;
+	node_info->bus_device_id = pdata_node_info->bus_device_id;
+	node_info->mas_rpm_id = pdata_node_info->mas_rpm_id;
+	node_info->slv_rpm_id = pdata_node_info->slv_rpm_id;
+	node_info->num_connections = pdata_node_info->num_connections;
+	node_info->num_blist = pdata_node_info->num_blist;
+	node_info->num_qports = pdata_node_info->num_qports;
+	node_info->buswidth = pdata_node_info->buswidth;
+	node_info->virt_dev = pdata_node_info->virt_dev;
+	node_info->is_fab_dev = pdata_node_info->is_fab_dev;
+	node_info->qos_params.mode = pdata_node_info->qos_params.mode;
+	node_info->qos_params.prio1 = pdata_node_info->qos_params.prio1;
+	node_info->qos_params.prio0 = pdata_node_info->qos_params.prio0;
+	node_info->qos_params.prio_lvl = pdata_node_info->qos_params.prio_lvl;
+	node_info->qos_params.prio_rd = pdata_node_info->qos_params.prio_rd;
+	node_info->qos_params.prio_wr = pdata_node_info->qos_params.prio_wr;
+	node_info->qos_params.gp = pdata_node_info->qos_params.gp;
+	node_info->qos_params.thmp = pdata_node_info->qos_params.thmp;
+	node_info->qos_params.ws = pdata_node_info->qos_params.ws;
+	node_info->qos_params.bw_buffer = pdata_node_info->qos_params.bw_buffer;
+	node_info->util_fact = pdata_node_info->util_fact;
+	node_info->vrail_comp = pdata_node_info->vrail_comp;
+
+	node_info->dev_connections = devm_kzalloc(bus_dev,
+			sizeof(struct device *) *
+				pdata_node_info->num_connections,
+			GFP_KERNEL);
+	if (!node_info->dev_connections) {
+		MSM_BUS_ERR("%s:Bus dev connections alloc failed\n", __func__);
+		ret = -ENOMEM;
+		goto exit_copy_node_info;
+	}
+
+	node_info->connections = devm_kzalloc(bus_dev,
+			sizeof(int) * pdata_node_info->num_connections,
+			GFP_KERNEL);
+	if (!node_info->connections) {
+		MSM_BUS_ERR("%s:Bus connections alloc failed\n", __func__);
+		devm_kfree(bus_dev, node_info->dev_connections);
+		ret = -ENOMEM;
+		goto exit_copy_node_info;
+	}
+
+	memcpy(node_info->connections,
+		pdata_node_info->connections,
+		sizeof(int) * pdata_node_info->num_connections);
+
+	node_info->black_connections = devm_kzalloc(bus_dev,
+			sizeof(struct device *) *
+				pdata_node_info->num_blist,
+			GFP_KERNEL);
+	if (!node_info->black_connections) {
+		MSM_BUS_ERR("%s: Bus black connections alloc failed\n",
+			__func__);
+		devm_kfree(bus_dev, node_info->dev_connections);
+		devm_kfree(bus_dev, node_info->connections);
+		ret = -ENOMEM;
+		goto exit_copy_node_info;
+	}
+
+	node_info->black_listed_connections = devm_kzalloc(bus_dev,
+			pdata_node_info->num_blist * sizeof(int),
+			GFP_KERNEL);
+	if (!node_info->black_listed_connections) {
+		MSM_BUS_ERR("%s:Bus black list connections alloc failed\n",
+					__func__);
+		devm_kfree(bus_dev, node_info->black_connections);
+		devm_kfree(bus_dev, node_info->dev_connections);
+		devm_kfree(bus_dev, node_info->connections);
+		ret = -ENOMEM;
+		goto exit_copy_node_info;
+	}
+
+	memcpy(node_info->black_listed_connections,
+		pdata_node_info->black_listed_connections,
+		sizeof(int) * pdata_node_info->num_blist);
+
+	node_info->qport = devm_kzalloc(bus_dev,
+			sizeof(int) * pdata_node_info->num_qports,
+			GFP_KERNEL);
+	if (!node_info->qport) {
+		MSM_BUS_ERR("%s:Bus qport allocation failed\n", __func__);
+		devm_kfree(bus_dev, node_info->dev_connections);
+		devm_kfree(bus_dev, node_info->connections);
+		devm_kfree(bus_dev, node_info->black_listed_connections);
+		ret = -ENOMEM;
+		goto exit_copy_node_info;
+	}
+
+	memcpy(node_info->qport,
+		pdata_node_info->qport,
+		sizeof(int) * pdata_node_info->num_qports);
+
+exit_copy_node_info:
+	return ret;
+}
+
+static struct device *msm_bus_device_init(
+			struct msm_bus_node_device_type *pdata)
+{
+	struct device *bus_dev = NULL;
+	struct msm_bus_node_device_type *bus_node = NULL;
+	struct msm_bus_node_info_type *node_info = NULL;
+	int ret = 0;
+
+	bus_dev = kzalloc(sizeof(struct device), GFP_KERNEL);
+	if (!bus_dev) {
+		MSM_BUS_ERR("%s:Device alloc failed\n", __func__);
+		bus_dev = NULL;
+		goto exit_device_init;
+	}
+	/**
+	* Init here so we can use devm calls
+	*/
+	device_initialize(bus_dev);
+
+	bus_node = devm_kzalloc(bus_dev,
+			sizeof(struct msm_bus_node_device_type), GFP_KERNEL);
+	if (!bus_node) {
+		MSM_BUS_ERR("%s:Bus node alloc failed\n", __func__);
+		kfree(bus_dev);
+		bus_dev = NULL;
+		goto exit_device_init;
+	}
+
+	node_info = devm_kzalloc(bus_dev,
+			sizeof(struct msm_bus_node_info_type), GFP_KERNEL);
+	if (!node_info) {
+		MSM_BUS_ERR("%s:Bus node info alloc failed\n", __func__);
+		devm_kfree(bus_dev, bus_node);
+		kfree(bus_dev);
+		bus_dev = NULL;
+		goto exit_device_init;
+	}
+
+	bus_node->node_info = node_info;
+	bus_node->ap_owned = pdata->ap_owned;
+	bus_dev->platform_data = bus_node;
+
+	if (msm_bus_copy_node_info(pdata, bus_dev) < 0) {
+		devm_kfree(bus_dev, bus_node);
+		devm_kfree(bus_dev, node_info);
+		kfree(bus_dev);
+		bus_dev = NULL;
+		goto exit_device_init;
+	}
+
+	bus_dev->bus = &msm_bus_type;
+	dev_set_name(bus_dev, bus_node->node_info->name);
+
+	ret = device_add(bus_dev);
+	if (ret < 0) {
+		MSM_BUS_ERR("%s: Error registering device %d",
+				__func__, pdata->node_info->id);
+		devm_kfree(bus_dev, bus_node);
+		devm_kfree(bus_dev, node_info->dev_connections);
+		devm_kfree(bus_dev, node_info->connections);
+		devm_kfree(bus_dev, node_info->black_connections);
+		devm_kfree(bus_dev, node_info->black_listed_connections);
+		devm_kfree(bus_dev, node_info);
+		kfree(bus_dev);
+		bus_dev = NULL;
+		goto exit_device_init;
+	}
+	device_create_file(bus_dev, &dev_attr_vrail);
+
+exit_device_init:
+	return bus_dev;
+}
+
+static int msm_bus_setup_dev_conn(struct device *bus_dev, void *data)
+{
+	struct msm_bus_node_device_type *bus_node = NULL;
+	int ret = 0;
+	int j;
+
+	bus_node = bus_dev->platform_data;
+	if (!bus_node) {
+		MSM_BUS_ERR("%s: Can't get device info", __func__);
+		ret = -ENODEV;
+		goto exit_setup_dev_conn;
+	}
+
+	/* Setup parent bus device for this node */
+	if (!bus_node->node_info->is_fab_dev) {
+		struct device *bus_parent_device =
+			bus_find_device(&msm_bus_type, NULL,
+				(void *)&bus_node->node_info->bus_device_id,
+				msm_bus_device_match_adhoc);
+
+		if (!bus_parent_device) {
+			MSM_BUS_ERR("%s: Error finding parentdev %d parent %d",
+				__func__,
+				bus_node->node_info->id,
+				bus_node->node_info->bus_device_id);
+			ret = -ENXIO;
+			goto exit_setup_dev_conn;
+		}
+		bus_node->node_info->bus_device = bus_parent_device;
+	}
+
+	bus_node->node_info->is_traversed = false;
+
+	for (j = 0; j < bus_node->node_info->num_connections; j++) {
+		bus_node->node_info->dev_connections[j] =
+			bus_find_device(&msm_bus_type, NULL,
+				(void *)&bus_node->node_info->connections[j],
+				msm_bus_device_match_adhoc);
+
+		if (!bus_node->node_info->dev_connections[j]) {
+			MSM_BUS_ERR("%s: Error finding conn %d for device %d",
+				__func__, bus_node->node_info->connections[j],
+				 bus_node->node_info->id);
+			ret = -ENODEV;
+			goto exit_setup_dev_conn;
+		}
+	}
+
+	for (j = 0; j < bus_node->node_info->num_blist; j++) {
+		bus_node->node_info->black_connections[j] =
+			bus_find_device(&msm_bus_type, NULL,
+				(void *)&bus_node->node_info->
+				black_listed_connections[j],
+				msm_bus_device_match_adhoc);
+
+		if (!bus_node->node_info->black_connections[j]) {
+			MSM_BUS_ERR("%s: Error finding conn %d for device %d\n",
+				__func__, bus_node->node_info->
+				black_listed_connections[j],
+				bus_node->node_info->id);
+			ret = -ENODEV;
+			goto exit_setup_dev_conn;
+		}
+	}
+
+exit_setup_dev_conn:
+	return ret;
+}
+
+static int msm_bus_node_debug(struct device *bus_dev, void *data)
+{
+	int j;
+	int ret = 0;
+	struct msm_bus_node_device_type *bus_node = NULL;
+
+	bus_node = bus_dev->platform_data;
+	if (!bus_node) {
+		MSM_BUS_ERR("%s: Can't get device info", __func__);
+		ret = -ENODEV;
+		goto exit_node_debug;
+	}
+
+	MSM_BUS_DBG("Device = %d buswidth %u", bus_node->node_info->id,
+				bus_node->node_info->buswidth);
+	for (j = 0; j < bus_node->node_info->num_connections; j++) {
+		struct msm_bus_node_device_type *bdev =
+			(struct msm_bus_node_device_type *)
+			bus_node->node_info->dev_connections[j]->platform_data;
+		MSM_BUS_DBG("\n\t Connection[%d] %d", j, bdev->node_info->id);
+	}
+
+exit_node_debug:
+	return ret;
+}
+
+static int msm_bus_device_probe(struct platform_device *pdev)
+{
+	unsigned int i, ret;
+	struct msm_bus_device_node_registration *pdata;
+
+	/* If possible, get pdata from device-tree */
+	if (pdev->dev.of_node)
+		pdata = msm_bus_of_to_pdata(pdev);
+	else {
+		pdata = (struct msm_bus_device_node_registration *)pdev->
+			dev.platform_data;
+	}
+
+	if (IS_ERR_OR_NULL(pdata)) {
+		MSM_BUS_ERR("No platform data found");
+		ret = -ENODATA;
+		goto exit_device_probe;
+	}
+
+	for (i = 0; i < pdata->num_devices; i++) {
+		struct device *node_dev = NULL;
+
+		node_dev = msm_bus_device_init(&pdata->info[i]);
+
+		if (!node_dev) {
+			MSM_BUS_ERR("%s: Error during dev init for %d",
+				__func__, pdata->info[i].node_info->id);
+			ret = -ENXIO;
+			goto exit_device_probe;
+		}
+
+		ret = msm_bus_init_clk(node_dev, &pdata->info[i]);
+		/*Is this a fabric device ?*/
+		if (pdata->info[i].node_info->is_fab_dev) {
+			MSM_BUS_DBG("%s: %d is a fab", __func__,
+						pdata->info[i].node_info->id);
+			ret = msm_bus_fabric_init(node_dev, &pdata->info[i]);
+			if (ret) {
+				MSM_BUS_ERR("%s: Error intializing fab %d",
+					__func__, pdata->info[i].node_info->id);
+				goto exit_device_probe;
+			}
+		}
+	}
+
+	ret = bus_for_each_dev(&msm_bus_type, NULL, NULL,
+						msm_bus_setup_dev_conn);
+	if (ret) {
+		MSM_BUS_ERR("%s: Error setting up dev connections", __func__);
+		goto exit_device_probe;
+	}
+
+	ret = bus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_dev_init_qos);
+	if (ret) {
+		MSM_BUS_ERR("%s: Error during qos init", __func__);
+		goto exit_device_probe;
+	}
+
+	bus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_node_debug);
+
+	/* Register the arb layer ops */
+	msm_bus_arb_setops_adhoc(&arb_ops);
+	devm_kfree(&pdev->dev, pdata->info);
+	devm_kfree(&pdev->dev, pdata);
+exit_device_probe:
+	return ret;
+}
+
+static int msm_bus_device_rules_probe(struct platform_device *pdev)
+{
+	struct bus_rule_type *rule_data = NULL;
+	int num_rules = 0;
+
+	num_rules = msm_bus_of_get_static_rules(pdev, &rule_data);
+
+	if (!rule_data)
+		goto exit_rules_probe;
+
+	msm_rule_register(num_rules, rule_data, NULL);
+	static_rules.num_rules = num_rules;
+	static_rules.rules = rule_data;
+	pdev->dev.platform_data = &static_rules;
+
+exit_rules_probe:
+	return 0;
+}
+
+int msm_bus_device_rules_remove(struct platform_device *pdev)
+{
+	struct static_rules_type *static_rules = NULL;
+
+	static_rules = pdev->dev.platform_data;
+	if (static_rules)
+		msm_rule_unregister(static_rules->num_rules,
+					static_rules->rules, NULL);
+	return 0;
+}
+
+static int msm_bus_free_dev(struct device *dev, void *data)
+{
+	struct msm_bus_node_device_type *bus_node = NULL;
+
+	bus_node = dev->platform_data;
+
+	if (bus_node)
+		MSM_BUS_ERR("\n%s: Removing device %d", __func__,
+						bus_node->node_info->id);
+	device_unregister(dev);
+	return 0;
+}
+
+int msm_bus_device_remove(struct platform_device *pdev)
+{
+	bus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_free_dev);
+	return 0;
+}
+
+static struct of_device_id rules_match[] = {
+	{.compatible = "qcom,msm-bus-static-bw-rules"},
+	{}
+};
+
+static struct platform_driver msm_bus_rules_driver = {
+	.probe = msm_bus_device_rules_probe,
+	.remove = msm_bus_device_rules_remove,
+	.driver = {
+		.name = "msm_bus_rules_device",
+		.owner = THIS_MODULE,
+		.of_match_table = rules_match,
+	},
+};
+
+static struct of_device_id fabric_match[] = {
+	{.compatible = "qcom,msm-bus-device"},
+	{}
+};
+
+static struct platform_driver msm_bus_device_driver = {
+	.probe = msm_bus_device_probe,
+	.remove = msm_bus_device_remove,
+	.driver = {
+		.name = "msm_bus_device",
+		.owner = THIS_MODULE,
+		.of_match_table = fabric_match,
+	},
+};
+
+int __init msm_bus_device_init_driver(void)
+{
+	int rc;
+
+	MSM_BUS_ERR("msm_bus_fabric_init_driver\n");
+	rc =  platform_driver_register(&msm_bus_device_driver);
+
+	if (rc) {
+		MSM_BUS_ERR("Failed to register bus device driver");
+		return rc;
+	}
+	return platform_driver_register(&msm_bus_rules_driver);
+}
+subsys_initcall(msm_bus_device_init_driver);
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_id.c
@@ -0,0 +1,94 @@
+/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include "msm-bus.h"
+#include "msm-bus-board.h"
+#include "msm_bus_core.h"
+#include "msm_bus_noc.h"
+#include "msm_bus_bimc.h"
+
+static uint32_t master_iids[MSM_BUS_MASTER_LAST];
+static uint32_t slave_iids[MSM_BUS_SLAVE_LAST - SLAVE_ID_KEY];
+
+static void msm_bus_assign_iids(struct msm_bus_fabric_registration
+	*fabreg, int fabid)
+{
+	int i;
+	for (i = 0; i < fabreg->len; i++) {
+		if (!fabreg->info[i].gateway) {
+			fabreg->info[i].priv_id = fabid + fabreg->info[i].id;
+			if (fabreg->info[i].id < SLAVE_ID_KEY) {
+				if (fabreg->info[i].id >= MSM_BUS_MASTER_LAST) {
+					WARN(1, "id %d exceeds array size!\n",
+						fabreg->info[i].id);
+					continue;
+				}
+
+				master_iids[fabreg->info[i].id] =
+					fabreg->info[i].priv_id;
+			} else {
+				if ((fabreg->info[i].id - SLAVE_ID_KEY) >=
+					(MSM_BUS_SLAVE_LAST - SLAVE_ID_KEY)) {
+					WARN(1, "id %d exceeds array size!\n",
+						fabreg->info[i].id);
+					continue;
+				}
+
+				slave_iids[fabreg->info[i].id - (SLAVE_ID_KEY)]
+					= fabreg->info[i].priv_id;
+			}
+		} else {
+			fabreg->info[i].priv_id = fabreg->info[i].id;
+		}
+	}
+}
+
+static int msm_bus_get_iid(int id)
+{
+	if ((id < SLAVE_ID_KEY && id >= MSM_BUS_MASTER_LAST) ||
+		id >= MSM_BUS_SLAVE_LAST) {
+		MSM_BUS_ERR("Cannot get iid. Invalid id %d passed\n", id);
+		return -EINVAL;
+	}
+
+	return CHECK_ID(((id < SLAVE_ID_KEY) ? master_iids[id] :
+		slave_iids[id - SLAVE_ID_KEY]), id);
+}
+
+static struct msm_bus_board_algorithm msm_bus_id_algo = {
+	.get_iid = msm_bus_get_iid,
+	.assign_iids = msm_bus_assign_iids,
+};
+
+int msm_bus_board_rpm_get_il_ids(uint16_t *id)
+{
+	return -ENXIO;
+}
+
+void msm_bus_board_init(struct msm_bus_fabric_registration *pdata)
+{
+	pdata->board_algo = &msm_bus_id_algo;
+}
+
+void msm_bus_board_set_nfab(struct msm_bus_fabric_registration *pdata,
+	int nfab)
+{
+	if (nfab <= 0)
+		return;
+
+	msm_bus_id_algo.board_nfab = nfab;
+}
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_noc.c
@@ -0,0 +1,770 @@
+/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "AXI: NOC: %s(): " fmt, __func__
+
+#include <linux/slab.h>
+#include <linux/io.h>
+#include "msm-bus-board.h"
+#include "msm_bus_core.h"
+#include "msm_bus_noc.h"
+#include "msm_bus_adhoc.h"
+
+/* NOC_QOS generic */
+#define __CLZ(x) ((8 * sizeof(uint32_t)) - 1 - __fls(x))
+#define SAT_SCALE 16	/* 16 bytes minimum for saturation */
+#define BW_SCALE  256	/* 1/256 byte per cycle unit */
+#define QOS_DEFAULT_BASEOFFSET		0x00003000
+#define QOS_DEFAULT_DELTA		0x80
+#define MAX_BW_FIELD (NOC_QOS_BWn_BW_BMSK >> NOC_QOS_BWn_BW_SHFT)
+#define MAX_SAT_FIELD (NOC_QOS_SATn_SAT_BMSK >> NOC_QOS_SATn_SAT_SHFT)
+
+#define NOC_QOS_REG_BASE(b, o)		((b) + (o))
+
+#define NOC_QOS_ID_COREIDn_ADDR(b, o, n, d) \
+	(NOC_QOS_REG_BASE(b, o) + (d) * (n))
+enum noc_qos_id_coreidn {
+	NOC_QOS_ID_COREIDn_RMSK			= 0xffffffff,
+	NOC_QOS_ID_COREIDn_MAXn			= 32,
+	NOC_QOS_ID_COREIDn_CORECHSUM_BMSK	= 0xffffff00,
+	NOC_QOS_ID_COREIDn_CORECHSUM_SHFT	= 0x8,
+	NOC_QOS_ID_COREIDn_CORETYPEID_BMSK	= 0xff,
+	NOC_QOS_ID_COREIDn_CORETYPEID_SHFT	= 0x0,
+};
+
+#define NOC_QOS_ID_REVISIONIDn_ADDR(b, o, n, d) \
+	(NOC_QOS_REG_BASE(b, o) + 0x4 + (d) * (n))
+enum noc_qos_id_revisionidn {
+	NOC_QOS_ID_REVISIONIDn_RMSK		= 0xffffffff,
+	NOC_QOS_ID_REVISIONIDn_MAXn		= 32,
+	NOC_QOS_ID_REVISIONIDn_FLEXNOCID_BMSK	= 0xffffff00,
+	NOC_QOS_ID_REVISIONIDn_FLEXNOCID_SHFT	= 0x8,
+	NOC_QOS_ID_REVISIONIDn_USERID_BMSK	= 0xff,
+	NOC_QOS_ID_REVISIONIDn_USERID_SHFT	= 0x0,
+};
+
+#define NOC_QOS_PRIORITYn_ADDR(b, o, n, d)	\
+	(NOC_QOS_REG_BASE(b, o) + 0x8 + (d) * (n))
+enum noc_qos_id_priorityn {
+	NOC_QOS_PRIORITYn_RMSK		= 0x0000000f,
+	NOC_QOS_PRIORITYn_MAXn		= 32,
+	NOC_QOS_PRIORITYn_P1_BMSK	= 0xc,
+	NOC_QOS_PRIORITYn_P1_SHFT	= 0x2,
+	NOC_QOS_PRIORITYn_P0_BMSK	= 0x3,
+	NOC_QOS_PRIORITYn_P0_SHFT	= 0x0,
+};
+
+#define NOC_QOS_MODEn_ADDR(b, o, n, d) \
+	(NOC_QOS_REG_BASE(b, o) + 0xC + (d) * (n))
+enum noc_qos_id_moden_rmsk {
+	NOC_QOS_MODEn_RMSK		= 0x00000003,
+	NOC_QOS_MODEn_MAXn		= 32,
+	NOC_QOS_MODEn_MODE_BMSK		= 0x3,
+	NOC_QOS_MODEn_MODE_SHFT		= 0x0,
+};
+
+#define NOC_QOS_BWn_ADDR(b, o, n, d) \
+	(NOC_QOS_REG_BASE(b, o) + 0x10 + (d) * (n))
+enum noc_qos_id_bwn {
+	NOC_QOS_BWn_RMSK		= 0x0000ffff,
+	NOC_QOS_BWn_MAXn		= 32,
+	NOC_QOS_BWn_BW_BMSK		= 0xffff,
+	NOC_QOS_BWn_BW_SHFT		= 0x0,
+};
+
+/* QOS Saturation registers */
+#define NOC_QOS_SATn_ADDR(b, o, n, d) \
+	(NOC_QOS_REG_BASE(b, o) + 0x14 + (d) * (n))
+enum noc_qos_id_saturationn {
+	NOC_QOS_SATn_RMSK		= 0x000003ff,
+	NOC_QOS_SATn_MAXn		= 32,
+	NOC_QOS_SATn_SAT_BMSK		= 0x3ff,
+	NOC_QOS_SATn_SAT_SHFT		= 0x0,
+};
+
+static int noc_div(uint64_t *a, uint32_t b)
+{
+	if ((*a > 0) && (*a < b))
+		return 1;
+	else
+		return do_div(*a, b);
+}
+
+/**
+ * Calculates bw hardware is using from register values
+ * bw returned is in bytes/sec
+ */
+static uint64_t noc_bw(uint32_t bw_field, uint32_t qos_freq)
+{
+	uint64_t res;
+	uint32_t rem, scale;
+
+	res = 2 * qos_freq * bw_field;
+	scale = BW_SCALE * 1000;
+	rem = noc_div(&res, scale);
+	MSM_BUS_DBG("NOC: Calculated bw: %llu\n", res * 1000000ULL);
+	return res * 1000000ULL;
+}
+
+static uint32_t noc_bw_ceil(long int bw_field, uint32_t qos_freq)
+{
+	uint64_t bw_temp = 2 * qos_freq * bw_field;
+	uint32_t scale = 1000 * BW_SCALE;
+	noc_div(&bw_temp, scale);
+	return bw_temp * 1000000;
+}
+#define MAX_BW(timebase) noc_bw_ceil(MAX_BW_FIELD, (timebase))
+
+/**
+ * Calculates ws hardware is using from register values
+ * ws returned is in nanoseconds
+ */
+static uint32_t noc_ws(uint64_t bw, uint32_t sat, uint32_t qos_freq)
+{
+	if (bw && qos_freq) {
+		uint32_t bwf = bw * qos_freq;
+		uint64_t scale = 1000000000000LL * BW_SCALE *
+			SAT_SCALE * sat;
+		noc_div(&scale, bwf);
+		MSM_BUS_DBG("NOC: Calculated ws: %llu\n", scale);
+		return scale;
+	}
+
+	return 0;
+}
+#define MAX_WS(bw, timebase) noc_ws((bw), MAX_SAT_FIELD, (timebase))
+
+/* Calculate bandwidth field value for requested bandwidth  */
+static uint32_t noc_bw_field(uint64_t bw, uint32_t qos_freq)
+{
+	uint32_t bw_field = 0;
+
+	if (bw) {
+		uint32_t rem;
+		uint64_t bw_capped = min_t(uint64_t, bw, MAX_BW(qos_freq));
+		uint64_t bwc = bw_capped * BW_SCALE;
+		uint64_t qf = 2 * qos_freq * 1000;
+
+		rem = noc_div(&bwc, qf);
+		bw_field = (uint32_t)min_t(uint64_t, bwc, MAX_BW_FIELD);
+	}
+
+	MSM_BUS_DBG("NOC: bw_field: %u\n", bw_field);
+	return bw_field;
+}
+
+static uint32_t noc_sat_field(uint64_t bw, uint32_t ws, uint32_t qos_freq)
+{
+	uint32_t sat_field = 0, win;
+
+	if (bw) {
+		/* Limit to max bw and scale bw to 100 KB increments */
+		uint64_t tbw, tscale;
+		uint64_t bw_scaled = min_t(uint64_t, bw, MAX_BW(qos_freq));
+		uint32_t rem = noc_div(&bw_scaled, 100000);
+
+		/**
+		 * Calculate saturation from windows size.
+		 * WS must be at least one arb period.
+		 * Saturation must not exceed max field size
+		 *
+		 * Bandwidth is in 100KB increments
+		 * Window size is in ns
+		 * qos_freq is in KHz
+		 */
+		win = max(ws, 1000000 / qos_freq);
+		tbw = bw_scaled * win * qos_freq;
+		tscale = 10000000ULL * BW_SCALE * SAT_SCALE;
+		rem = noc_div(&tbw, tscale);
+		sat_field = (uint32_t)min_t(uint64_t, tbw, MAX_SAT_FIELD);
+	}
+
+	MSM_BUS_DBG("NOC: sat_field: %d\n", sat_field);
+	return sat_field;
+}
+
+static void noc_set_qos_mode(void __iomem *base, uint32_t qos_off,
+		uint32_t mport, uint32_t qos_delta, uint8_t mode,
+		uint8_t perm_mode)
+{
+	if (mode < NOC_QOS_MODE_MAX &&
+		((1 << mode) & perm_mode)) {
+		uint32_t reg_val;
+
+		reg_val = readl_relaxed(NOC_QOS_MODEn_ADDR(base, qos_off,
+			mport, qos_delta)) & NOC_QOS_MODEn_RMSK;
+		writel_relaxed(((reg_val & (~(NOC_QOS_MODEn_MODE_BMSK))) |
+			(mode & NOC_QOS_MODEn_MODE_BMSK)),
+			NOC_QOS_MODEn_ADDR(base, qos_off, mport, qos_delta));
+	}
+	/* Ensure qos mode is set before exiting */
+	wmb();
+}
+
+static void noc_set_qos_priority(void __iomem *base, uint32_t qos_off,
+		uint32_t mport, uint32_t qos_delta,
+		struct msm_bus_noc_qos_priority *priority)
+{
+	uint32_t reg_val, val;
+
+	reg_val = readl_relaxed(NOC_QOS_PRIORITYn_ADDR(base, qos_off, mport,
+		qos_delta)) & NOC_QOS_PRIORITYn_RMSK;
+	val = priority->p1 << NOC_QOS_PRIORITYn_P1_SHFT;
+	writel_relaxed(((reg_val & (~(NOC_QOS_PRIORITYn_P1_BMSK))) |
+		(val & NOC_QOS_PRIORITYn_P1_BMSK)),
+		NOC_QOS_PRIORITYn_ADDR(base, qos_off, mport, qos_delta));
+
+	reg_val = readl_relaxed(NOC_QOS_PRIORITYn_ADDR(base, qos_off, mport,
+								qos_delta))
+		& NOC_QOS_PRIORITYn_RMSK;
+	writel_relaxed(((reg_val & (~(NOC_QOS_PRIORITYn_P0_BMSK))) |
+		(priority->p0 & NOC_QOS_PRIORITYn_P0_BMSK)),
+		NOC_QOS_PRIORITYn_ADDR(base, qos_off, mport, qos_delta));
+	/* Ensure qos priority is set before exiting */
+	wmb();
+}
+
+static void msm_bus_noc_set_qos_bw(void __iomem *base, uint32_t qos_off,
+		uint32_t qos_freq, uint32_t mport, uint32_t qos_delta,
+		uint8_t perm_mode, struct msm_bus_noc_qos_bw *qbw)
+{
+	uint32_t reg_val, val, mode;
+
+	if (!qos_freq) {
+		MSM_BUS_DBG("Zero QoS Freq\n");
+		return;
+	}
+
+
+	/* If Limiter or Regulator modes are not supported, bw not available*/
+	if (perm_mode & (NOC_QOS_PERM_MODE_LIMITER |
+		NOC_QOS_PERM_MODE_REGULATOR)) {
+		uint32_t bw_val = noc_bw_field(qbw->bw, qos_freq);
+		uint32_t sat_val = noc_sat_field(qbw->bw, qbw->ws,
+			qos_freq);
+
+		MSM_BUS_DBG("NOC: BW: perm_mode: %d bw_val: %d, sat_val: %d\n",
+			perm_mode, bw_val, sat_val);
+		/*
+		 * If in Limiter/Regulator mode, first go to fixed mode.
+		 * Clear QoS accumulator
+		 **/
+		mode = readl_relaxed(NOC_QOS_MODEn_ADDR(base, qos_off,
+			mport, qos_delta)) & NOC_QOS_MODEn_MODE_BMSK;
+		if (mode == NOC_QOS_MODE_REGULATOR || mode ==
+			NOC_QOS_MODE_LIMITER) {
+			reg_val = readl_relaxed(NOC_QOS_MODEn_ADDR(
+				base, qos_off, mport, qos_delta));
+			val = NOC_QOS_MODE_FIXED;
+			writel_relaxed((reg_val & (~(NOC_QOS_MODEn_MODE_BMSK)))
+				| (val & NOC_QOS_MODEn_MODE_BMSK),
+				NOC_QOS_MODEn_ADDR(base, qos_off, mport,
+								qos_delta));
+		}
+
+		reg_val = readl_relaxed(NOC_QOS_BWn_ADDR(base, qos_off, mport,
+								qos_delta));
+		val = bw_val << NOC_QOS_BWn_BW_SHFT;
+		writel_relaxed(((reg_val & (~(NOC_QOS_BWn_BW_BMSK))) |
+			(val & NOC_QOS_BWn_BW_BMSK)),
+			NOC_QOS_BWn_ADDR(base, qos_off, mport, qos_delta));
+
+		MSM_BUS_DBG("NOC: BW: Wrote value: 0x%x\n", ((reg_val &
+			(~NOC_QOS_BWn_BW_BMSK)) | (val &
+			NOC_QOS_BWn_BW_BMSK)));
+
+		reg_val = readl_relaxed(NOC_QOS_SATn_ADDR(base, qos_off,
+			mport, qos_delta));
+		val = sat_val << NOC_QOS_SATn_SAT_SHFT;
+		writel_relaxed(((reg_val & (~(NOC_QOS_SATn_SAT_BMSK))) |
+			(val & NOC_QOS_SATn_SAT_BMSK)),
+			NOC_QOS_SATn_ADDR(base, qos_off, mport, qos_delta));
+
+		MSM_BUS_DBG("NOC: SAT: Wrote value: 0x%x\n", ((reg_val &
+			(~NOC_QOS_SATn_SAT_BMSK)) | (val &
+			NOC_QOS_SATn_SAT_BMSK)));
+
+		/* Set mode back to what it was initially */
+		reg_val = readl_relaxed(NOC_QOS_MODEn_ADDR(base, qos_off,
+			mport, qos_delta));
+		writel_relaxed((reg_val & (~(NOC_QOS_MODEn_MODE_BMSK)))
+			| (mode & NOC_QOS_MODEn_MODE_BMSK),
+			NOC_QOS_MODEn_ADDR(base, qos_off, mport, qos_delta));
+		/* Ensure that all writes for bandwidth registers have
+		 * completed before returning
+		 */
+		wmb();
+	}
+}
+
+uint8_t msm_bus_noc_get_qos_mode(void __iomem *base, uint32_t qos_off,
+	uint32_t mport, uint32_t qos_delta, uint32_t mode, uint32_t perm_mode)
+{
+	if (NOC_QOS_MODES_ALL_PERM == perm_mode)
+		return readl_relaxed(NOC_QOS_MODEn_ADDR(base, qos_off,
+			mport, qos_delta)) & NOC_QOS_MODEn_MODE_BMSK;
+	else
+		return 31 - __CLZ(mode &
+			NOC_QOS_MODES_ALL_PERM);
+}
+
+void msm_bus_noc_get_qos_priority(void __iomem *base, uint32_t qos_off,
+	uint32_t mport, uint32_t qos_delta,
+	struct msm_bus_noc_qos_priority *priority)
+{
+	priority->p1 = (readl_relaxed(NOC_QOS_PRIORITYn_ADDR(base, qos_off,
+		mport, qos_delta)) & NOC_QOS_PRIORITYn_P1_BMSK) >>
+		NOC_QOS_PRIORITYn_P1_SHFT;
+
+	priority->p0 = (readl_relaxed(NOC_QOS_PRIORITYn_ADDR(base, qos_off,
+		mport, qos_delta)) & NOC_QOS_PRIORITYn_P0_BMSK) >>
+		NOC_QOS_PRIORITYn_P0_SHFT;
+}
+
+void msm_bus_noc_get_qos_bw(void __iomem *base, uint32_t qos_off,
+	uint32_t qos_freq,
+	uint32_t mport, uint32_t qos_delta, uint8_t perm_mode,
+	struct msm_bus_noc_qos_bw *qbw)
+{
+	if (perm_mode & (NOC_QOS_PERM_MODE_LIMITER |
+		NOC_QOS_PERM_MODE_REGULATOR)) {
+		uint32_t bw_val = readl_relaxed(NOC_QOS_BWn_ADDR(
+			base, qos_off, mport, qos_delta)) & NOC_QOS_BWn_BW_BMSK;
+		uint32_t sat = readl_relaxed(NOC_QOS_SATn_ADDR(
+			base, qos_off, mport, qos_delta))
+						& NOC_QOS_SATn_SAT_BMSK;
+
+		qbw->bw = noc_bw(bw_val, qos_freq);
+		qbw->ws = noc_ws(qbw->bw, sat, qos_freq);
+	} else {
+		qbw->bw = 0;
+		qbw->ws = 0;
+	}
+}
+
+static int msm_bus_noc_mas_init(struct msm_bus_noc_info *ninfo,
+	struct msm_bus_inode_info *info)
+{
+	int i;
+	struct msm_bus_noc_qos_priority *prio;
+	prio = kzalloc(sizeof(struct msm_bus_noc_qos_priority),
+		GFP_KERNEL);
+	if (!prio) {
+		MSM_BUS_WARN("Couldn't alloc prio data for node: %d\n",
+			info->node_info->id);
+		return -ENOMEM;
+	}
+
+	prio->read_prio = info->node_info->prio_rd;
+	prio->write_prio = info->node_info->prio_wr;
+	prio->p1 = info->node_info->prio1;
+	prio->p0 = info->node_info->prio0;
+	info->hw_data = (void *)prio;
+
+	if (!info->node_info->qport) {
+		MSM_BUS_DBG("No QoS Ports to init\n");
+		return 0;
+	}
+
+	for (i = 0; i < info->node_info->num_mports; i++) {
+		if (info->node_info->mode != NOC_QOS_MODE_BYPASS) {
+			noc_set_qos_priority(ninfo->base, ninfo->qos_baseoffset,
+				info->node_info->qport[i], ninfo->qos_delta,
+				prio);
+
+			if (info->node_info->mode != NOC_QOS_MODE_FIXED) {
+				struct msm_bus_noc_qos_bw qbw;
+				qbw.ws = info->node_info->ws;
+				qbw.bw = 0;
+				msm_bus_noc_set_qos_bw(ninfo->base,
+					ninfo->qos_baseoffset,
+					ninfo->qos_freq, info->node_info->
+					qport[i], ninfo->qos_delta,
+					info->node_info->perm_mode,
+					&qbw);
+			}
+		}
+
+		noc_set_qos_mode(ninfo->base, ninfo->qos_baseoffset,
+			info->node_info->qport[i], ninfo->qos_delta,
+			info->node_info->mode,
+			info->node_info->perm_mode);
+	}
+
+	return 0;
+}
+
+static void msm_bus_noc_node_init(void *hw_data,
+	struct msm_bus_inode_info *info)
+{
+	struct msm_bus_noc_info *ninfo =
+		(struct msm_bus_noc_info *)hw_data;
+
+	if (!IS_SLAVE(info->node_info->priv_id))
+		if (info->node_info->hw_sel != MSM_BUS_RPM)
+			msm_bus_noc_mas_init(ninfo, info);
+}
+
+static int msm_bus_noc_allocate_commit_data(struct msm_bus_fabric_registration
+	*fab_pdata, void **cdata, int ctx)
+{
+	struct msm_bus_noc_commit **cd = (struct msm_bus_noc_commit **)cdata;
+	struct msm_bus_noc_info *ninfo =
+		(struct msm_bus_noc_info *)fab_pdata->hw_data;
+
+	*cd = kzalloc(sizeof(struct msm_bus_noc_commit), GFP_KERNEL);
+	if (!*cd) {
+		MSM_BUS_DBG("Couldn't alloc mem for cdata\n");
+		return -ENOMEM;
+	}
+
+	(*cd)->mas = ninfo->cdata[ctx].mas;
+	(*cd)->slv = ninfo->cdata[ctx].slv;
+
+	return 0;
+}
+
+static void *msm_bus_noc_allocate_noc_data(struct platform_device *pdev,
+	struct msm_bus_fabric_registration *fab_pdata)
+{
+	struct resource *noc_mem;
+	struct resource *noc_io;
+	struct msm_bus_noc_info *ninfo;
+	int i;
+
+	ninfo = kzalloc(sizeof(struct msm_bus_noc_info), GFP_KERNEL);
+	if (!ninfo) {
+		MSM_BUS_DBG("Couldn't alloc mem for noc info\n");
+		return NULL;
+	}
+
+	ninfo->nmasters = fab_pdata->nmasters;
+	ninfo->nqos_masters = fab_pdata->nmasters;
+	ninfo->nslaves = fab_pdata->nslaves;
+	ninfo->qos_freq = fab_pdata->qos_freq;
+
+	if (!fab_pdata->qos_baseoffset)
+		ninfo->qos_baseoffset = QOS_DEFAULT_BASEOFFSET;
+	else
+		ninfo->qos_baseoffset = fab_pdata->qos_baseoffset;
+
+	if (!fab_pdata->qos_delta)
+		ninfo->qos_delta = QOS_DEFAULT_DELTA;
+	else
+		ninfo->qos_delta = fab_pdata->qos_delta;
+
+	ninfo->mas_modes = kzalloc(sizeof(uint32_t) * fab_pdata->nmasters,
+		GFP_KERNEL);
+	if (!ninfo->mas_modes) {
+		MSM_BUS_DBG("Couldn't alloc mem for noc master-modes\n");
+		kfree(ninfo);
+		return NULL;
+	}
+
+	for (i = 0; i < NUM_CTX; i++) {
+		ninfo->cdata[i].mas = kzalloc(sizeof(struct
+			msm_bus_node_hw_info) * fab_pdata->nmasters * 2,
+			GFP_KERNEL);
+		if (!ninfo->cdata[i].mas) {
+			MSM_BUS_DBG("Couldn't alloc mem for noc master-bw\n");
+			kfree(ninfo->mas_modes);
+			kfree(ninfo);
+			return NULL;
+		}
+
+		ninfo->cdata[i].slv = kzalloc(sizeof(struct
+			msm_bus_node_hw_info) * fab_pdata->nslaves * 2,
+			GFP_KERNEL);
+		if (!ninfo->cdata[i].slv) {
+			MSM_BUS_DBG("Couldn't alloc mem for noc master-bw\n");
+			kfree(ninfo->cdata[i].mas);
+			goto err;
+		}
+	}
+
+	/* If it's a virtual fabric, don't get memory info */
+	if (fab_pdata->virt)
+		goto skip_mem;
+
+	noc_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!noc_mem && !fab_pdata->virt) {
+		MSM_BUS_ERR("Cannot get NoC Base address\n");
+		goto err;
+	}
+
+	noc_io = request_mem_region(noc_mem->start,
+			resource_size(noc_mem), pdev->name);
+	if (!noc_io) {
+		MSM_BUS_ERR("NoC memory unavailable\n");
+		goto err;
+	}
+
+	ninfo->base = ioremap(noc_mem->start, resource_size(noc_mem));
+	if (!ninfo->base) {
+		MSM_BUS_ERR("IOremap failed for NoC!\n");
+		release_mem_region(noc_mem->start, resource_size(noc_mem));
+		goto err;
+	}
+
+skip_mem:
+	fab_pdata->hw_data = (void *)ninfo;
+	return (void *)ninfo;
+
+err:
+	kfree(ninfo->mas_modes);
+	kfree(ninfo);
+	return NULL;
+}
+
+static void free_commit_data(void *cdata)
+{
+	struct msm_bus_noc_commit *cd = (struct msm_bus_noc_commit *)cdata;
+
+	kfree(cd->mas);
+	kfree(cd->slv);
+	kfree(cd);
+}
+
+static bool msm_bus_noc_update_bw_reg(int mode)
+{
+	bool ret = false;
+
+	if ((mode == NOC_QOS_MODE_LIMITER) ||
+			(mode == NOC_QOS_MODE_REGULATOR))
+			ret = true;
+
+	return ret;
+}
+
+static void msm_bus_noc_update_bw(struct msm_bus_inode_info *hop,
+	struct msm_bus_inode_info *info,
+	struct msm_bus_fabric_registration *fab_pdata,
+	void *sel_cdata, int *master_tiers,
+	int64_t add_bw)
+{
+	struct msm_bus_noc_info *ninfo;
+	struct msm_bus_noc_qos_bw qos_bw;
+	int i, ports;
+	int64_t bw;
+	struct msm_bus_noc_commit *sel_cd =
+		(struct msm_bus_noc_commit *)sel_cdata;
+
+	ninfo = (struct msm_bus_noc_info *)fab_pdata->hw_data;
+	if (!ninfo->qos_freq) {
+		MSM_BUS_DBG("NOC: No qos frequency to update bw\n");
+		return;
+	}
+
+	if (info->node_info->num_mports == 0) {
+		MSM_BUS_DBG("NOC: Skip Master BW\n");
+		goto skip_mas_bw;
+	}
+
+	ports = info->node_info->num_mports;
+	bw = INTERLEAVED_BW(fab_pdata, add_bw, ports);
+
+	MSM_BUS_DBG("NOC: Update bw for: %d: %lld\n",
+		info->node_info->priv_id, add_bw);
+	for (i = 0; i < ports; i++) {
+		sel_cd->mas[info->node_info->masterp[i]].bw += bw;
+		sel_cd->mas[info->node_info->masterp[i]].hw_id =
+			info->node_info->mas_hw_id;
+		MSM_BUS_DBG("NOC: Update mas_bw: ID: %d, BW: %llu ports:%d\n",
+			info->node_info->priv_id,
+			sel_cd->mas[info->node_info->masterp[i]].bw,
+			ports);
+		/* Check if info is a shared master.
+		 * If it is, mark it dirty
+		 * If it isn't, then set QOS Bandwidth
+		 **/
+		if (info->node_info->hw_sel == MSM_BUS_RPM)
+			sel_cd->mas[info->node_info->masterp[i]].dirty = 1;
+		else {
+			if (!info->node_info->qport) {
+				MSM_BUS_DBG("No qos ports to update!\n");
+				break;
+			}
+
+			if (!(info->node_info->mode == NOC_QOS_MODE_REGULATOR)
+					|| (info->node_info->mode ==
+						NOC_QOS_MODE_LIMITER)) {
+				MSM_BUS_DBG("Skip QoS reg programming\n");
+				break;
+			}
+			qos_bw.bw = sel_cd->mas[info->node_info->masterp[i]].
+				bw;
+			qos_bw.ws = info->node_info->ws;
+			msm_bus_noc_set_qos_bw(ninfo->base,
+				ninfo->qos_baseoffset,
+				ninfo->qos_freq,
+				info->node_info->qport[i], ninfo->qos_delta,
+				info->node_info->perm_mode, &qos_bw);
+			MSM_BUS_DBG("NOC: QoS: Update mas_bw: ws: %u\n",
+				qos_bw.ws);
+		}
+	}
+
+skip_mas_bw:
+	ports = hop->node_info->num_sports;
+	for (i = 0; i < ports; i++) {
+		sel_cd->slv[hop->node_info->slavep[i]].bw += add_bw;
+		sel_cd->slv[hop->node_info->slavep[i]].hw_id =
+			hop->node_info->slv_hw_id;
+		MSM_BUS_DBG("NOC: Update slave_bw for ID: %d -> %llu\n",
+			hop->node_info->priv_id,
+			sel_cd->slv[hop->node_info->slavep[i]].bw);
+		MSM_BUS_DBG("NOC: Update slave_bw for hw_id: %d, index: %d\n",
+			hop->node_info->slv_hw_id, hop->node_info->slavep[i]);
+		/* Check if hop is a shared slave.
+		 * If it is, mark it dirty
+		 * If it isn't, then nothing to be done as the
+		 * slaves are in bypass mode.
+		 **/
+		if (hop->node_info->hw_sel == MSM_BUS_RPM)
+			sel_cd->slv[hop->node_info->slavep[i]].dirty = 1;
+	}
+}
+
+static int msm_bus_noc_commit(struct msm_bus_fabric_registration
+	*fab_pdata, void *hw_data, void **cdata)
+{
+	MSM_BUS_DBG("\nReached NOC Commit\n");
+	msm_bus_remote_hw_commit(fab_pdata, hw_data, cdata);
+	return 0;
+}
+
+static int msm_bus_noc_port_halt(uint32_t haltid, uint8_t mport)
+{
+	return 0;
+}
+
+static int msm_bus_noc_port_unhalt(uint32_t haltid, uint8_t mport)
+{
+	return 0;
+}
+
+static int msm_bus_noc_qos_init(struct msm_bus_node_device_type *info,
+				void __iomem *qos_base,
+				uint32_t qos_off, uint32_t qos_delta,
+				uint32_t qos_freq)
+{
+	struct msm_bus_noc_qos_priority prio;
+	int ret = 0;
+	int i;
+
+	prio.p1 = info->node_info->qos_params.prio1;
+	prio.p0 = info->node_info->qos_params.prio0;
+
+	if (!info->node_info->qport) {
+		MSM_BUS_DBG("No QoS Ports to init\n");
+		ret = 0;
+		goto err_qos_init;
+	}
+
+	for (i = 0; i < info->node_info->num_qports; i++) {
+		if (info->node_info->qos_params.mode != NOC_QOS_MODE_BYPASS) {
+			noc_set_qos_priority(qos_base, qos_off,
+					info->node_info->qport[i], qos_delta,
+					&prio);
+
+			if (info->node_info->qos_params.mode !=
+							NOC_QOS_MODE_FIXED) {
+				struct msm_bus_noc_qos_bw qbw;
+				qbw.ws = info->node_info->qos_params.ws;
+				qbw.bw = 0;
+				msm_bus_noc_set_qos_bw(qos_base, qos_off,
+					qos_freq,
+					info->node_info->qport[i],
+					qos_delta,
+					info->node_info->qos_params.mode,
+					&qbw);
+			}
+		}
+
+		noc_set_qos_mode(qos_base, qos_off, info->node_info->qport[i],
+				qos_delta, info->node_info->qos_params.mode,
+				(1 << info->node_info->qos_params.mode));
+	}
+err_qos_init:
+	return ret;
+}
+
+static int msm_bus_noc_set_bw(struct msm_bus_node_device_type *dev,
+				void __iomem *qos_base,
+				uint32_t qos_off, uint32_t qos_delta,
+				uint32_t qos_freq)
+{
+	int ret = 0;
+	uint64_t bw = 0;
+	int i;
+	struct msm_bus_node_info_type *info = dev->node_info;
+
+	if (info && info->num_qports &&
+		((info->qos_params.mode == NOC_QOS_MODE_REGULATOR) ||
+		(info->qos_params.mode ==
+			NOC_QOS_MODE_LIMITER))) {
+		struct msm_bus_noc_qos_bw qos_bw;
+
+		bw = msm_bus_div64(info->num_qports,
+				dev->node_ab.ab[DUAL_CTX]);
+
+		for (i = 0; i < info->num_qports; i++) {
+			if (!info->qport) {
+				MSM_BUS_DBG("No qos ports to update!\n");
+				break;
+			}
+
+			qos_bw.bw = bw;
+			qos_bw.ws = info->qos_params.ws;
+			msm_bus_noc_set_qos_bw(qos_base, qos_off, qos_freq,
+				info->qport[i], qos_delta,
+				info->qos_params.mode, &qos_bw);
+			MSM_BUS_DBG("NOC: QoS: Update mas_bw: ws: %u\n",
+				qos_bw.ws);
+		}
+	}
+	return ret;
+}
+int msm_bus_noc_hw_init(struct msm_bus_fabric_registration *pdata,
+	struct msm_bus_hw_algorithm *hw_algo)
+{
+	/* Set interleaving to true by default */
+	pdata->il_flag = true;
+	hw_algo->allocate_commit_data = msm_bus_noc_allocate_commit_data;
+	hw_algo->allocate_hw_data = msm_bus_noc_allocate_noc_data;
+	hw_algo->node_init = msm_bus_noc_node_init;
+	hw_algo->free_commit_data = free_commit_data;
+	hw_algo->update_bw = msm_bus_noc_update_bw;
+	hw_algo->commit = msm_bus_noc_commit;
+	hw_algo->port_halt = msm_bus_noc_port_halt;
+	hw_algo->port_unhalt = msm_bus_noc_port_unhalt;
+	hw_algo->update_bw_reg = msm_bus_noc_update_bw_reg;
+	hw_algo->config_master = NULL;
+	hw_algo->config_limiter = NULL;
+
+	return 0;
+}
+
+int msm_bus_noc_set_ops(struct msm_bus_node_device_type *bus_dev)
+{
+	if (!bus_dev)
+		return -ENODEV;
+	else {
+		bus_dev->fabdev->noc_ops.qos_init = msm_bus_noc_qos_init;
+		bus_dev->fabdev->noc_ops.set_bw = msm_bus_noc_set_bw;
+		bus_dev->fabdev->noc_ops.limit_mport = NULL;
+		bus_dev->fabdev->noc_ops.update_bw_reg =
+						msm_bus_noc_update_bw_reg;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(msm_bus_noc_set_ops);
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_noc.h
@@ -0,0 +1,76 @@
+/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _ARCH_ARM_MACH_MSM_BUS_BIMC_H
+#define _ARCH_ARM_MACH_MSM_BUS_BIMC_H
+
+enum msm_bus_noc_qos_mode_type {
+	NOC_QOS_MODE_FIXED = 0,
+	NOC_QOS_MODE_LIMITER,
+	NOC_QOS_MODE_BYPASS,
+	NOC_QOS_MODE_REGULATOR,
+	NOC_QOS_MODE_MAX,
+};
+
+enum msm_bus_noc_qos_mode_perm {
+	NOC_QOS_PERM_MODE_FIXED = (1 << NOC_QOS_MODE_FIXED),
+	NOC_QOS_PERM_MODE_LIMITER = (1 << NOC_QOS_MODE_LIMITER),
+	NOC_QOS_PERM_MODE_BYPASS = (1 << NOC_QOS_MODE_BYPASS),
+	NOC_QOS_PERM_MODE_REGULATOR = (1 << NOC_QOS_MODE_REGULATOR),
+};
+
+#define NOC_QOS_MODES_ALL_PERM (NOC_QOS_PERM_MODE_FIXED | \
+	NOC_QOS_PERM_MODE_LIMITER | NOC_QOS_PERM_MODE_BYPASS | \
+	NOC_QOS_PERM_MODE_REGULATOR)
+
+struct msm_bus_noc_commit {
+	struct msm_bus_node_hw_info *mas;
+	struct msm_bus_node_hw_info *slv;
+};
+
+struct msm_bus_noc_info {
+	void __iomem *base;
+	uint32_t base_addr;
+	uint32_t nmasters;
+	uint32_t nqos_masters;
+	uint32_t nslaves;
+	uint32_t qos_freq; /* QOS Clock in KHz */
+	uint32_t qos_baseoffset;
+	uint32_t qos_delta;
+	uint32_t *mas_modes;
+	struct msm_bus_noc_commit cdata[NUM_CTX];
+};
+
+struct msm_bus_noc_qos_priority {
+	uint32_t high_prio;
+	uint32_t low_prio;
+	uint32_t read_prio;
+	uint32_t write_prio;
+	uint32_t p1;
+	uint32_t p0;
+};
+
+struct msm_bus_noc_qos_bw {
+	uint64_t bw; /* Bandwidth in bytes per second */
+	uint32_t ws; /* Window size in nano seconds */
+};
+
+void msm_bus_noc_init(struct msm_bus_noc_info *ninfo);
+uint8_t msm_bus_noc_get_qos_mode(void __iomem *base, uint32_t qos_off,
+	uint32_t mport, uint32_t qos_delta, uint32_t mode, uint32_t perm_mode);
+void msm_bus_noc_get_qos_priority(void __iomem *base, uint32_t qos_off,
+	uint32_t mport, uint32_t qos_delta,
+	struct msm_bus_noc_qos_priority *qprio);
+void msm_bus_noc_get_qos_bw(void __iomem *base, uint32_t qos_off,
+	uint32_t qos_freq, uint32_t mport, uint32_t qos_delta,
+	uint8_t perm_mode, struct msm_bus_noc_qos_bw *qbw);
+#endif /*_ARCH_ARM_MACH_MSM_BUS_NOC_H */
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_of.c
@@ -0,0 +1,705 @@
+/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "AXI: %s(): " fmt, __func__
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include "msm-bus.h"
+#include "msm-bus-board.h"
+#include "msm_bus_core.h"
+
+static const char * const hw_sel_name[] = {"RPM", "NoC", "BIMC", NULL};
+static const char * const mode_sel_name[] = {"Fixed", "Limiter", "Bypass",
+						"Regulator", NULL};
+
+static int get_num(const char *const str[], const char *name)
+{
+	int i = 0;
+
+	do {
+		if (!strcmp(name, str[i]))
+			return i;
+
+		i++;
+	} while (str[i] != NULL);
+
+	pr_err("Error: string %s not found\n", name);
+	return -EINVAL;
+}
+
+#if defined(CONFIG_DEBUG_FS) && defined(CONFIG_MSM_BUS_SCALING)
+static struct msm_bus_scale_pdata *get_pdata(struct platform_device *pdev,
+	struct device_node *of_node)
+{
+	struct msm_bus_scale_pdata *pdata = NULL;
+	struct msm_bus_paths *usecase = NULL;
+	int i = 0, j, ret, num_usecases = 0, num_paths, len;
+	const uint32_t *vec_arr = NULL;
+	bool mem_err = false;
+
+	if (!pdev) {
+		pr_err("Error: Null Platform device\n");
+		return NULL;
+	}
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(struct msm_bus_scale_pdata),
+		GFP_KERNEL);
+	if (!pdata) {
+		pr_err("Error: Memory allocation for pdata failed\n");
+		mem_err = true;
+		goto err;
+	}
+
+	ret = of_property_read_string(of_node, "qcom,msm-bus,name",
+		&pdata->name);
+	if (ret) {
+		pr_err("Error: Client name not found\n");
+		goto err;
+	}
+
+	ret = of_property_read_u32(of_node, "qcom,msm-bus,num-cases",
+		&num_usecases);
+	if (ret) {
+		pr_err("Error: num-usecases not found\n");
+		goto err;
+	}
+
+	pdata->num_usecases = num_usecases;
+
+	if (of_property_read_bool(of_node, "qcom,msm-bus,active-only"))
+		pdata->active_only = 1;
+	else {
+		pr_debug("active_only flag absent.\n");
+		pr_debug("Using dual context by default\n");
+	}
+
+	usecase = devm_kzalloc(&pdev->dev, (sizeof(struct msm_bus_paths) *
+		pdata->num_usecases), GFP_KERNEL);
+	if (!usecase) {
+		pr_err("Error: Memory allocation for paths failed\n");
+		mem_err = true;
+		goto err;
+	}
+
+	ret = of_property_read_u32(of_node, "qcom,msm-bus,num-paths",
+		&num_paths);
+	if (ret) {
+		pr_err("Error: num_paths not found\n");
+		goto err;
+	}
+
+	vec_arr = of_get_property(of_node, "qcom,msm-bus,vectors-KBps", &len);
+	if (vec_arr == NULL) {
+		pr_err("Error: Vector array not found\n");
+		goto err;
+	}
+
+	if (len != num_usecases * num_paths * sizeof(uint32_t) * 4) {
+		pr_err("Error: Length-error on getting vectors\n");
+		goto err;
+	}
+
+	for (i = 0; i < num_usecases; i++) {
+		usecase[i].num_paths = num_paths;
+		usecase[i].vectors = devm_kzalloc(&pdev->dev, num_paths *
+			sizeof(struct msm_bus_vectors), GFP_KERNEL);
+		if (!usecase[i].vectors) {
+			mem_err = true;
+			pr_err("Error: Mem alloc failure in vectors\n");
+			goto err;
+		}
+
+		for (j = 0; j < num_paths; j++) {
+			int index = ((i * num_paths) + j) * 4;
+			usecase[i].vectors[j].src = be32_to_cpu(vec_arr[index]);
+			usecase[i].vectors[j].dst =
+				be32_to_cpu(vec_arr[index + 1]);
+			usecase[i].vectors[j].ab = (uint64_t)
+				KBTOB(be32_to_cpu(vec_arr[index + 2]));
+			usecase[i].vectors[j].ib = (uint64_t)
+				KBTOB(be32_to_cpu(vec_arr[index + 3]));
+		}
+	}
+
+	pdata->usecase = usecase;
+	return pdata;
+err:
+	if (mem_err) {
+		for (; i > 0; i--)
+			kfree(usecase[i-1].vectors);
+
+		kfree(usecase);
+		kfree(pdata);
+	}
+
+	return NULL;
+}
+
+/**
+ * msm_bus_cl_get_pdata() - Generate bus client data from device tree
+ * provided by clients.
+ *
+ * of_node: Device tree node to extract information from
+ *
+ * The function returns a valid pointer to the allocated bus-scale-pdata
+ * if the vectors were correctly read from the client's device node.
+ * Any error in reading or parsing the device node will return NULL
+ * to the caller.
+ */
+struct msm_bus_scale_pdata *msm_bus_cl_get_pdata(struct platform_device *pdev)
+{
+	struct device_node *of_node;
+	struct msm_bus_scale_pdata *pdata = NULL;
+
+	if (!pdev) {
+		pr_err("Error: Null Platform device\n");
+		return NULL;
+	}
+
+	of_node = pdev->dev.of_node;
+	pdata = get_pdata(pdev, of_node);
+	if (!pdata) {
+		pr_err("client has to provide missing entry for successful registration\n");
+		return NULL;
+	}
+
+	return pdata;
+}
+EXPORT_SYMBOL(msm_bus_cl_get_pdata);
+
+/**
+ * msm_bus_cl_pdata_from_node() - Generate bus client data from device tree
+ * node provided by clients. This function should be used when a client
+ * driver needs to register multiple bus-clients from a single device-tree
+ * node associated with the platform-device.
+ *
+ * of_node: The subnode containing information about the bus scaling
+ * data
+ *
+ * pdev: Platform device associated with the device-tree node
+ *
+ * The function returns a valid pointer to the allocated bus-scale-pdata
+ * if the vectors were correctly read from the client's device node.
+ * Any error in reading or parsing the device node will return NULL
+ * to the caller.
+ */
+struct msm_bus_scale_pdata *msm_bus_pdata_from_node(
+		struct platform_device *pdev, struct device_node *of_node)
+{
+	struct msm_bus_scale_pdata *pdata = NULL;
+
+	if (!pdev) {
+		pr_err("Error: Null Platform device\n");
+		return NULL;
+	}
+
+	if (!of_node) {
+		pr_err("Error: Null of_node passed to bus driver\n");
+		return NULL;
+	}
+
+	pdata = get_pdata(pdev, of_node);
+	if (!pdata) {
+		pr_err("client has to provide missing entry for successful registration\n");
+		return NULL;
+	}
+
+	return pdata;
+}
+EXPORT_SYMBOL(msm_bus_pdata_from_node);
+
+/**
+ * msm_bus_cl_clear_pdata() - Clear pdata allocated from device-tree
+ * of_node: Device tree node to extract information from
+ */
+void msm_bus_cl_clear_pdata(struct msm_bus_scale_pdata *pdata)
+{
+	int i;
+
+	for (i = 0; i < pdata->num_usecases; i++)
+		kfree(pdata->usecase[i].vectors);
+
+	kfree(pdata->usecase);
+	kfree(pdata);
+}
+EXPORT_SYMBOL(msm_bus_cl_clear_pdata);
+#endif
+
+static int *get_arr(struct platform_device *pdev,
+		const struct device_node *node, const char *prop,
+		int *nports)
+{
+	int size = 0, ret;
+	int *arr = NULL;
+
+	if (of_get_property(node, prop, &size)) {
+		*nports = size / sizeof(int);
+	} else {
+		pr_debug("Property %s not available\n", prop);
+		*nports = 0;
+		return NULL;
+	}
+
+	if (!size) {
+		*nports = 0;
+		return NULL;
+	}
+
+	arr = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
+	if (ZERO_OR_NULL_PTR(arr)) {
+		pr_err("Error: Failed to alloc mem for %s\n", prop);
+		return NULL;
+	}
+
+	ret = of_property_read_u32_array(node, prop, (u32 *)arr, *nports);
+	if (ret) {
+		pr_err("Error in reading property: %s\n", prop);
+		goto err;
+	}
+
+	return arr;
+err:
+	devm_kfree(&pdev->dev, arr);
+	return NULL;
+}
+
+static u64 *get_th_params(struct platform_device *pdev,
+		const struct device_node *node, const char *prop,
+		int *nports)
+{
+	int size = 0, ret;
+	u64 *ret_arr = NULL;
+	int *arr = NULL;
+	int i;
+
+	if (of_get_property(node, prop, &size)) {
+		*nports = size / sizeof(int);
+	} else {
+		pr_debug("Property %s not available\n", prop);
+		*nports = 0;
+		return NULL;
+	}
+
+	if (!size) {
+		*nports = 0;
+		return NULL;
+	}
+
+	ret_arr = devm_kzalloc(&pdev->dev, (*nports * sizeof(u64)),
+							GFP_KERNEL);
+	if (ZERO_OR_NULL_PTR(ret_arr)) {
+		pr_err("Error: Failed to alloc mem for ret arr %s\n", prop);
+		return NULL;
+	}
+
+	arr = kzalloc(size, GFP_KERNEL);
+	if ((ZERO_OR_NULL_PTR(arr))) {
+		pr_err("Error: Failed to alloc temp mem for %s\n", prop);
+		return NULL;
+	}
+
+	ret = of_property_read_u32_array(node, prop, (u32 *)arr, *nports);
+	if (ret) {
+		pr_err("Error in reading property: %s\n", prop);
+		goto err;
+	}
+
+	for (i = 0; i < *nports; i++)
+		ret_arr[i] = (uint64_t)KBTOB(arr[i]);
+
+	MSM_BUS_DBG("%s: num entries %d prop %s", __func__, *nports, prop);
+
+	for (i = 0; i < *nports; i++)
+		MSM_BUS_DBG("Th %d val %llu", i, ret_arr[i]);
+
+	kfree(arr);
+	return ret_arr;
+err:
+	kfree(arr);
+	devm_kfree(&pdev->dev, ret_arr);
+	return NULL;
+}
+
+static struct msm_bus_node_info *get_nodes(struct device_node *of_node,
+	struct platform_device *pdev,
+	struct msm_bus_fabric_registration *pdata)
+{
+	struct msm_bus_node_info *info;
+	struct device_node *child_node = NULL;
+	int i = 0, ret;
+	int num_bw = 0;
+	u32 temp;
+
+	for_each_child_of_node(of_node, child_node) {
+		i++;
+	}
+
+	pdata->len = i;
+	info = (struct msm_bus_node_info *)
+		devm_kzalloc(&pdev->dev, sizeof(struct msm_bus_node_info) *
+			pdata->len, GFP_KERNEL);
+	if (ZERO_OR_NULL_PTR(info)) {
+		pr_err("Failed to alloc memory for nodes: %d\n", pdata->len);
+		goto err;
+	}
+
+	i = 0;
+	child_node = NULL;
+	for_each_child_of_node(of_node, child_node) {
+		const char *sel_str;
+
+		ret = of_property_read_string(child_node, "label",
+			&info[i].name);
+		if (ret)
+			pr_err("Error reading node label\n");
+
+		ret = of_property_read_u32(child_node, "cell-id", &info[i].id);
+		if (ret) {
+			pr_err("Error reading node id\n");
+			goto err;
+		}
+
+		if (of_property_read_bool(child_node, "qcom,gateway"))
+			info[i].gateway = 1;
+
+		of_property_read_u32(child_node, "qcom,mas-hw-id",
+			&info[i].mas_hw_id);
+
+		of_property_read_u32(child_node, "qcom,slv-hw-id",
+			&info[i].slv_hw_id);
+		info[i].masterp = get_arr(pdev, child_node,
+					"qcom,masterp", &info[i].num_mports);
+		/* No need to store number of qports */
+		info[i].qport = get_arr(pdev, child_node,
+					"qcom,qport", &ret);
+		pdata->nmasters += info[i].num_mports;
+
+
+		info[i].slavep = get_arr(pdev, child_node,
+					"qcom,slavep", &info[i].num_sports);
+		pdata->nslaves += info[i].num_sports;
+
+
+		info[i].tier = get_arr(pdev, child_node,
+					"qcom,tier", &info[i].num_tiers);
+
+		if (of_property_read_bool(child_node, "qcom,ahb"))
+			info[i].ahb = 1;
+
+		ret = of_property_read_string(child_node, "qcom,hw-sel",
+			&sel_str);
+		if (ret)
+			info[i].hw_sel = 0;
+		else {
+			ret =  get_num(hw_sel_name, sel_str);
+			if (ret < 0) {
+				pr_err("Invalid hw-sel\n");
+				goto err;
+			}
+
+			info[i].hw_sel = ret;
+		}
+
+		of_property_read_u32(child_node, "qcom,buswidth",
+			&info[i].buswidth);
+		of_property_read_u32(child_node, "qcom,ws", &info[i].ws);
+
+		info[i].dual_conf =
+			of_property_read_bool(child_node, "qcom,dual-conf");
+
+
+		info[i].th = get_th_params(pdev, child_node, "qcom,thresh",
+						&info[i].num_thresh);
+
+		info[i].bimc_bw = get_th_params(pdev, child_node,
+						"qcom,bimc,bw", &num_bw);
+
+		if (num_bw != info[i].num_thresh) {
+			pr_err("%s:num_bw %d must equal num_thresh %d",
+				__func__, num_bw, info[i].num_thresh);
+			pr_err("%s:Err setting up dual conf for %s",
+				__func__, info[i].name);
+			goto err;
+		}
+
+		of_property_read_u32(child_node, "qcom,bimc,gp",
+			&info[i].bimc_gp);
+		of_property_read_u32(child_node, "qcom,bimc,thmp",
+			&info[i].bimc_thmp);
+
+		ret = of_property_read_string(child_node, "qcom,mode-thresh",
+			&sel_str);
+		if (ret)
+			info[i].mode_thresh = 0;
+		else {
+			ret = get_num(mode_sel_name, sel_str);
+			if (ret < 0) {
+				pr_err("Unknown mode :%s\n", sel_str);
+				goto err;
+			}
+
+			info[i].mode_thresh = ret;
+			MSM_BUS_DBG("AXI: THreshold mode set: %d\n",
+					info[i].mode_thresh);
+		}
+
+		ret = of_property_read_string(child_node, "qcom,mode",
+				&sel_str);
+
+		if (ret)
+			info[i].mode = 0;
+		else {
+			ret = get_num(mode_sel_name, sel_str);
+			if (ret < 0) {
+				pr_err("Unknown mode :%s\n", sel_str);
+				goto err;
+			}
+
+			info[i].mode = ret;
+		}
+
+		info[i].nr_lim =
+			of_property_read_bool(child_node, "qcom,nr-lim");
+
+		ret = of_property_read_u32(child_node, "qcom,ff",
+							&info[i].ff);
+		if (ret) {
+			pr_debug("fudge factor not present %d", info[i].id);
+			info[i].ff = 0;
+		}
+
+		ret = of_property_read_u32(child_node, "qcom,floor-bw",
+						&temp);
+		if (ret) {
+			pr_debug("fabdev floor bw not present %d", info[i].id);
+			info[i].floor_bw = 0;
+		} else {
+			info[i].floor_bw = KBTOB(temp);
+		}
+
+		info[i].rt_mas =
+			of_property_read_bool(child_node, "qcom,rt-mas");
+
+		ret = of_property_read_string(child_node, "qcom,perm-mode",
+			&sel_str);
+		if (ret)
+			info[i].perm_mode = 0;
+		else {
+			ret = get_num(mode_sel_name, sel_str);
+			if (ret < 0)
+				goto err;
+
+			info[i].perm_mode = 1 << ret;
+		}
+
+		of_property_read_u32(child_node, "qcom,prio-lvl",
+			&info[i].prio_lvl);
+		of_property_read_u32(child_node, "qcom,prio-rd",
+			&info[i].prio_rd);
+		of_property_read_u32(child_node, "qcom,prio-wr",
+			&info[i].prio_wr);
+		of_property_read_u32(child_node, "qcom,prio0", &info[i].prio0);
+		of_property_read_u32(child_node, "qcom,prio1", &info[i].prio1);
+		ret = of_property_read_string(child_node, "qcom,slaveclk-dual",
+			&info[i].slaveclk[DUAL_CTX]);
+		if (!ret)
+			pr_debug("Got slaveclk_dual: %s\n",
+				info[i].slaveclk[DUAL_CTX]);
+		else
+			info[i].slaveclk[DUAL_CTX] = NULL;
+
+		ret = of_property_read_string(child_node,
+			"qcom,slaveclk-active", &info[i].slaveclk[ACTIVE_CTX]);
+		if (!ret)
+			pr_debug("Got slaveclk_active\n");
+		else
+			info[i].slaveclk[ACTIVE_CTX] = NULL;
+
+		ret = of_property_read_string(child_node, "qcom,memclk-dual",
+			&info[i].memclk[DUAL_CTX]);
+		if (!ret)
+			pr_debug("Got memclk_dual\n");
+		else
+			info[i].memclk[DUAL_CTX] = NULL;
+
+		ret = of_property_read_string(child_node, "qcom,memclk-active",
+			&info[i].memclk[ACTIVE_CTX]);
+		if (!ret)
+			pr_debug("Got memclk_active\n");
+		else
+			info[i].memclk[ACTIVE_CTX] = NULL;
+
+		ret = of_property_read_string(child_node, "qcom,iface-clk-node",
+			&info[i].iface_clk_node);
+		if (!ret)
+			pr_debug("Got iface_clk_node\n");
+		else
+			info[i].iface_clk_node = NULL;
+
+		pr_debug("Node name: %s\n", info[i].name);
+		of_node_put(child_node);
+		i++;
+	}
+
+	pr_debug("Bus %d added: %d masters\n", pdata->id, pdata->nmasters);
+	pr_debug("Bus %d added: %d slaves\n", pdata->id, pdata->nslaves);
+	return info;
+err:
+	return NULL;
+}
+
+void msm_bus_of_get_nfab(struct platform_device *pdev,
+		struct msm_bus_fabric_registration *pdata)
+{
+	struct device_node *of_node;
+	int ret, nfab = 0;
+
+	if (!pdev) {
+		pr_err("Error: Null platform device\n");
+		return;
+	}
+
+	of_node = pdev->dev.of_node;
+	ret = of_property_read_u32(of_node, "qcom,nfab",
+		&nfab);
+	if (!ret)
+		pr_debug("Fab_of: Read number of buses: %u\n", nfab);
+
+	msm_bus_board_set_nfab(pdata, nfab);
+}
+
+struct msm_bus_fabric_registration
+	*msm_bus_of_get_fab_data(struct platform_device *pdev)
+{
+	struct device_node *of_node;
+	struct msm_bus_fabric_registration *pdata;
+	bool mem_err = false;
+	int ret = 0;
+	const char *sel_str;
+	u32 temp;
+
+	if (!pdev) {
+		pr_err("Error: Null platform device\n");
+		return NULL;
+	}
+
+	of_node = pdev->dev.of_node;
+	pdata = devm_kzalloc(&pdev->dev,
+			sizeof(struct msm_bus_fabric_registration), GFP_KERNEL);
+	if (!pdata) {
+		pr_err("Error: Memory allocation for pdata failed\n");
+		mem_err = true;
+		goto err;
+	}
+
+	ret = of_property_read_string(of_node, "label", &pdata->name);
+	if (ret) {
+		pr_err("Error: label not found\n");
+		goto err;
+	}
+	pr_debug("Fab_of: Read name: %s\n", pdata->name);
+
+	ret = of_property_read_u32(of_node, "cell-id",
+		&pdata->id);
+	if (ret) {
+		pr_err("Error: num-usecases not found\n");
+		goto err;
+	}
+	pr_debug("Fab_of: Read id: %u\n", pdata->id);
+
+	if (of_property_read_bool(of_node, "qcom,ahb"))
+		pdata->ahb = 1;
+
+	ret = of_property_read_string(of_node, "qcom,fabclk-dual",
+		&pdata->fabclk[DUAL_CTX]);
+	if (ret) {
+		pr_debug("fabclk_dual not available\n");
+		pdata->fabclk[DUAL_CTX] = NULL;
+	} else
+		pr_debug("Fab_of: Read clk dual ctx: %s\n",
+			pdata->fabclk[DUAL_CTX]);
+	ret = of_property_read_string(of_node, "qcom,fabclk-active",
+		&pdata->fabclk[ACTIVE_CTX]);
+	if (ret) {
+		pr_debug("Error: fabclk_active not available\n");
+		pdata->fabclk[ACTIVE_CTX] = NULL;
+	} else
+		pr_debug("Fab_of: Read clk act ctx: %s\n",
+			pdata->fabclk[ACTIVE_CTX]);
+
+	ret = of_property_read_u32(of_node, "qcom,ntieredslaves",
+		&pdata->ntieredslaves);
+	if (ret) {
+		pr_err("Error: ntieredslaves not found\n");
+		goto err;
+	}
+
+	ret = of_property_read_u32(of_node, "qcom,qos-freq", &pdata->qos_freq);
+	if (ret)
+		pr_debug("qos_freq not available\n");
+
+	ret = of_property_read_string(of_node, "qcom,hw-sel", &sel_str);
+	if (ret) {
+		pr_err("Error: hw_sel not found\n");
+		goto err;
+	} else {
+		ret = get_num(hw_sel_name, sel_str);
+		if (ret < 0)
+			goto err;
+
+		pdata->hw_sel = ret;
+	}
+
+	if (of_property_read_bool(of_node, "qcom,virt"))
+		pdata->virt = true;
+
+	ret = of_property_read_u32(of_node, "qcom,qos-baseoffset",
+						&pdata->qos_baseoffset);
+	if (ret)
+		pr_debug("%s:qos_baseoffset not available\n", __func__);
+
+	ret = of_property_read_u32(of_node, "qcom,qos-delta",
+						&pdata->qos_delta);
+	if (ret)
+		pr_debug("%s:qos_delta not available\n", __func__);
+
+	if (of_property_read_bool(of_node, "qcom,rpm-en"))
+		pdata->rpm_enabled = 1;
+
+	ret = of_property_read_u32(of_node, "qcom,nr-lim-thresh",
+						&temp);
+
+	if (ret) {
+		pr_err("nr-lim threshold not specified");
+		pdata->nr_lim_thresh = 0;
+	} else {
+		pdata->nr_lim_thresh = KBTOB(temp);
+	}
+
+	ret = of_property_read_u32(of_node, "qcom,eff-fact",
+						&pdata->eff_fact);
+	if (ret) {
+		pr_err("Fab eff-factor not present");
+		pdata->eff_fact = 0;
+	}
+
+	pdata->info = get_nodes(of_node, pdev, pdata);
+	return pdata;
+err:
+	return NULL;
+}
+EXPORT_SYMBOL(msm_bus_of_get_fab_data);
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_of_adhoc.c
@@ -0,0 +1,641 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "AXI: %s(): " fmt, __func__
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include "msm-bus.h"
+#include "msm-bus-board.h"
+#include "msm_bus_rules.h"
+#include "msm_bus_core.h"
+#include "msm_bus_adhoc.h"
+
+#define DEFAULT_QOS_FREQ	19200
+#define DEFAULT_UTIL_FACT	100
+#define DEFAULT_VRAIL_COMP	100
+
+static int get_qos_mode(struct platform_device *pdev,
+			struct device_node *node, const char *qos_mode)
+{
+	const char *qos_names[] = {"fixed", "limiter", "bypass", "regulator"};
+	int i = 0;
+	int ret = -1;
+
+	if (!qos_mode)
+		goto exit_get_qos_mode;
+
+	for (i = 0; i < ARRAY_SIZE(qos_names); i++) {
+		if (!strcmp(qos_mode, qos_names[i]))
+			break;
+	}
+	if (i == ARRAY_SIZE(qos_names))
+		dev_err(&pdev->dev, "Cannot match mode qos %s using Bypass",
+				qos_mode);
+	else
+		ret = i;
+
+exit_get_qos_mode:
+	return ret;
+}
+
+static int *get_arr(struct platform_device *pdev,
+		struct device_node *node, const char *prop,
+		int *nports)
+{
+	int size = 0, ret;
+	int *arr = NULL;
+
+	if (of_get_property(node, prop, &size)) {
+		*nports = size / sizeof(int);
+	} else {
+		dev_dbg(&pdev->dev, "Property %s not available\n", prop);
+		*nports = 0;
+		return NULL;
+	}
+
+	arr = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
+	if ((size > 0) && ZERO_OR_NULL_PTR(arr)) {
+		dev_err(&pdev->dev, "Error: Failed to alloc mem for %s\n",
+				prop);
+		return NULL;
+	}
+
+	ret = of_property_read_u32_array(node, prop, (u32 *)arr, *nports);
+	if (ret) {
+		dev_err(&pdev->dev, "Error in reading property: %s\n", prop);
+		goto arr_err;
+	}
+
+	return arr;
+arr_err:
+	devm_kfree(&pdev->dev, arr);
+	return NULL;
+}
+
+static struct msm_bus_fab_device_type *get_fab_device_info(
+		struct device_node *dev_node,
+		struct platform_device *pdev)
+{
+	struct msm_bus_fab_device_type *fab_dev;
+	unsigned int ret;
+	struct resource *res;
+	const char *base_name;
+
+	fab_dev = devm_kzalloc(&pdev->dev,
+			sizeof(struct msm_bus_fab_device_type),
+			GFP_KERNEL);
+	if (!fab_dev) {
+		dev_err(&pdev->dev,
+			"Error: Unable to allocate memory for fab_dev\n");
+		return NULL;
+	}
+
+	ret = of_property_read_string(dev_node, "qcom,base-name", &base_name);
+	if (ret) {
+		dev_err(&pdev->dev, "Error: Unable to get base address name\n");
+		goto fab_dev_err;
+	}
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, base_name);
+	if (!res) {
+		dev_err(&pdev->dev, "Error getting qos base addr %s\n",
+								base_name);
+		goto fab_dev_err;
+	}
+	fab_dev->pqos_base = res->start;
+	fab_dev->qos_range = resource_size(res);
+	fab_dev->bypass_qos_prg = of_property_read_bool(dev_node,
+						"qcom,bypass-qos-prg");
+
+	ret = of_property_read_u32(dev_node, "qcom,base-offset",
+			&fab_dev->base_offset);
+	if (ret)
+		dev_dbg(&pdev->dev, "Bus base offset is missing\n");
+
+	ret = of_property_read_u32(dev_node, "qcom,qos-off",
+			&fab_dev->qos_off);
+	if (ret)
+		dev_dbg(&pdev->dev, "Bus qos off is missing\n");
+
+
+	ret = of_property_read_u32(dev_node, "qcom,bus-type",
+						&fab_dev->bus_type);
+	if (ret) {
+		dev_warn(&pdev->dev, "Bus type is missing\n");
+		goto fab_dev_err;
+	}
+
+	ret = of_property_read_u32(dev_node, "qcom,qos-freq",
+						&fab_dev->qos_freq);
+	if (ret) {
+		dev_dbg(&pdev->dev, "Bus qos freq is missing\n");
+		fab_dev->qos_freq = DEFAULT_QOS_FREQ;
+	}
+
+	ret = of_property_read_u32(dev_node, "qcom,util-fact",
+						&fab_dev->util_fact);
+	if (ret) {
+		dev_info(&pdev->dev, "Util-fact is missing, default to %d\n",
+				DEFAULT_UTIL_FACT);
+		fab_dev->util_fact = DEFAULT_UTIL_FACT;
+	}
+
+	ret = of_property_read_u32(dev_node, "qcom,vrail-comp",
+						&fab_dev->vrail_comp);
+	if (ret) {
+		dev_info(&pdev->dev, "Vrail-comp is missing, default to %d\n",
+				DEFAULT_VRAIL_COMP);
+		fab_dev->vrail_comp = DEFAULT_VRAIL_COMP;
+	}
+
+	return fab_dev;
+
+fab_dev_err:
+	devm_kfree(&pdev->dev, fab_dev);
+	fab_dev = 0;
+	return NULL;
+}
+
+static void get_qos_params(
+		struct device_node * const dev_node,
+		struct platform_device * const pdev,
+		struct msm_bus_node_info_type *node_info)
+{
+	const char *qos_mode = NULL;
+	unsigned int ret;
+	unsigned int temp;
+
+	ret = of_property_read_string(dev_node, "qcom,qos-mode", &qos_mode);
+
+	if (ret)
+		node_info->qos_params.mode = -1;
+	else
+		node_info->qos_params.mode = get_qos_mode(pdev, dev_node,
+								qos_mode);
+
+	of_property_read_u32(dev_node, "qcom,prio-lvl",
+					&node_info->qos_params.prio_lvl);
+
+	of_property_read_u32(dev_node, "qcom,prio1",
+						&node_info->qos_params.prio1);
+
+	of_property_read_u32(dev_node, "qcom,prio0",
+						&node_info->qos_params.prio0);
+
+	of_property_read_u32(dev_node, "qcom,prio-rd",
+					&node_info->qos_params.prio_rd);
+
+	of_property_read_u32(dev_node, "qcom,prio-wr",
+						&node_info->qos_params.prio_wr);
+
+	of_property_read_u32(dev_node, "qcom,gp",
+						&node_info->qos_params.gp);
+
+	of_property_read_u32(dev_node, "qcom,thmp",
+						&node_info->qos_params.thmp);
+
+	of_property_read_u32(dev_node, "qcom,ws",
+						&node_info->qos_params.ws);
+
+	ret = of_property_read_u32(dev_node, "qcom,bw_buffer", &temp);
+
+	if (ret)
+		node_info->qos_params.bw_buffer = 0;
+	else
+		node_info->qos_params.bw_buffer = KBTOB(temp);
+
+}
+
+
+static struct msm_bus_node_info_type *get_node_info_data(
+		struct device_node * const dev_node,
+		struct platform_device * const pdev)
+{
+	struct msm_bus_node_info_type *node_info;
+	unsigned int ret;
+	int size;
+	int i;
+	struct device_node *con_node;
+	struct device_node *bus_dev;
+
+	node_info = devm_kzalloc(&pdev->dev,
+			sizeof(struct msm_bus_node_info_type),
+			GFP_KERNEL);
+	if (!node_info) {
+		dev_err(&pdev->dev,
+			"Error: Unable to allocate memory for node_info\n");
+		return NULL;
+	}
+
+	ret = of_property_read_u32(dev_node, "cell-id", &node_info->id);
+	if (ret) {
+		dev_warn(&pdev->dev, "Bus node is missing cell-id\n");
+		goto node_info_err;
+	}
+	ret = of_property_read_string(dev_node, "label", &node_info->name);
+	if (ret) {
+		dev_warn(&pdev->dev, "Bus node is missing name\n");
+		goto node_info_err;
+	}
+	node_info->qport = get_arr(pdev, dev_node, "qcom,qport",
+			&node_info->num_qports);
+
+	if (of_get_property(dev_node, "qcom,connections", &size)) {
+		node_info->num_connections = size / sizeof(int);
+		node_info->connections = devm_kzalloc(&pdev->dev, size,
+				GFP_KERNEL);
+	} else {
+		node_info->num_connections = 0;
+		node_info->connections = 0;
+	}
+
+	for (i = 0; i < node_info->num_connections; i++) {
+		con_node = of_parse_phandle(dev_node, "qcom,connections", i);
+		if (IS_ERR_OR_NULL(con_node))
+			goto node_info_err;
+
+		if (of_property_read_u32(con_node, "cell-id",
+				&node_info->connections[i]))
+			goto node_info_err;
+		of_node_put(con_node);
+	}
+
+	if (of_get_property(dev_node, "qcom,blacklist", &size)) {
+		node_info->num_blist = size/sizeof(u32);
+		node_info->black_listed_connections = devm_kzalloc(&pdev->dev,
+		size, GFP_KERNEL);
+	} else {
+		node_info->num_blist = 0;
+		node_info->black_listed_connections = 0;
+	}
+
+	for (i = 0; i < node_info->num_blist; i++) {
+		con_node = of_parse_phandle(dev_node, "qcom,blacklist", i);
+		if (IS_ERR_OR_NULL(con_node))
+			goto node_info_err;
+
+		if (of_property_read_u32(con_node, "cell-id",
+				&node_info->black_listed_connections[i]))
+			goto node_info_err;
+		of_node_put(con_node);
+	}
+
+	bus_dev = of_parse_phandle(dev_node, "qcom,bus-dev", 0);
+	if (!IS_ERR_OR_NULL(bus_dev)) {
+		if (of_property_read_u32(bus_dev, "cell-id",
+			&node_info->bus_device_id)) {
+			dev_err(&pdev->dev, "Can't find bus device. Node %d",
+					node_info->id);
+			goto node_info_err;
+		}
+
+		of_node_put(bus_dev);
+	} else
+		dev_dbg(&pdev->dev, "Can't find bdev phandle for %d",
+					node_info->id);
+
+	node_info->is_fab_dev = of_property_read_bool(dev_node, "qcom,fab-dev");
+	node_info->virt_dev = of_property_read_bool(dev_node, "qcom,virt-dev");
+
+	ret = of_property_read_u32(dev_node, "qcom,buswidth",
+						&node_info->buswidth);
+	if (ret) {
+		dev_dbg(&pdev->dev, "Using default 8 bytes %d", node_info->id);
+		node_info->buswidth = 8;
+	}
+
+	ret = of_property_read_u32(dev_node, "qcom,mas-rpm-id",
+						&node_info->mas_rpm_id);
+	if (ret) {
+		dev_dbg(&pdev->dev, "mas rpm id is missing\n");
+		node_info->mas_rpm_id = -1;
+	}
+
+	ret = of_property_read_u32(dev_node, "qcom,slv-rpm-id",
+						&node_info->slv_rpm_id);
+	if (ret) {
+		dev_dbg(&pdev->dev, "slv rpm id is missing\n");
+		node_info->slv_rpm_id = -1;
+	}
+	ret = of_property_read_u32(dev_node, "qcom,util-fact",
+						&node_info->util_fact);
+	if (ret)
+		node_info->util_fact = 0;
+	ret = of_property_read_u32(dev_node, "qcom,vrail-comp",
+						&node_info->vrail_comp);
+	if (ret)
+		node_info->vrail_comp = 0;
+	get_qos_params(dev_node, pdev, node_info);
+
+	return node_info;
+
+node_info_err:
+	devm_kfree(&pdev->dev, node_info);
+	node_info = 0;
+	return NULL;
+}
+
+static unsigned int get_bus_node_device_data(
+		struct device_node * const dev_node,
+		struct platform_device * const pdev,
+		struct msm_bus_node_device_type * const node_device)
+{
+	node_device->node_info = get_node_info_data(dev_node, pdev);
+	if (IS_ERR_OR_NULL(node_device->node_info)) {
+		dev_err(&pdev->dev, "Error: Node info missing\n");
+		return -ENODATA;
+	}
+	node_device->ap_owned = of_property_read_bool(dev_node,
+							"qcom,ap-owned");
+
+	if (node_device->node_info->is_fab_dev) {
+		dev_dbg(&pdev->dev, "Dev %d\n", node_device->node_info->id);
+
+		if (!node_device->node_info->virt_dev) {
+			node_device->fabdev =
+				get_fab_device_info(dev_node, pdev);
+			if (IS_ERR_OR_NULL(node_device->fabdev)) {
+				dev_err(&pdev->dev,
+					"Error: Fabric device info missing\n");
+				devm_kfree(&pdev->dev, node_device->node_info);
+				return -ENODATA;
+			}
+		}
+		node_device->clk[DUAL_CTX].clk = of_clk_get_by_name(dev_node,
+							"bus_clk");
+
+		if (IS_ERR_OR_NULL(node_device->clk[DUAL_CTX].clk))
+			dev_dbg(&pdev->dev,
+				"%s:Failed to get bus clk for bus%d ctx%d",
+				__func__, node_device->node_info->id,
+								DUAL_CTX);
+
+		node_device->clk[ACTIVE_CTX].clk = of_clk_get_by_name(dev_node,
+							"bus_a_clk");
+		if (IS_ERR_OR_NULL(node_device->clk[ACTIVE_CTX].clk))
+			dev_err(&pdev->dev,
+				"Failed to get bus clk for bus%d ctx%d",
+				 node_device->node_info->id, ACTIVE_CTX);
+		if (msmbus_coresight_init_adhoc(pdev, dev_node))
+			dev_warn(&pdev->dev,
+				 "Coresight support absent for bus: %d\n",
+				  node_device->node_info->id);
+	} else {
+		node_device->qos_clk.clk = of_clk_get_by_name(dev_node,
+							"bus_qos_clk");
+
+		if (IS_ERR_OR_NULL(node_device->qos_clk.clk))
+			dev_dbg(&pdev->dev,
+				"%s:Failed to get bus qos clk for mas%d",
+				__func__, node_device->node_info->id);
+
+		node_device->clk[DUAL_CTX].clk = of_clk_get_by_name(dev_node,
+							"node_clk");
+
+		if (IS_ERR_OR_NULL(node_device->clk[DUAL_CTX].clk))
+			dev_dbg(&pdev->dev,
+				"%s:Failed to get bus clk for bus%d ctx%d",
+				__func__, node_device->node_info->id,
+								DUAL_CTX);
+
+	}
+	return 0;
+}
+
+struct msm_bus_device_node_registration
+	*msm_bus_of_to_pdata(struct platform_device *pdev)
+{
+	struct device_node *of_node, *child_node;
+	struct msm_bus_device_node_registration *pdata;
+	unsigned int i = 0, j;
+	unsigned int ret;
+
+	if (!pdev) {
+		pr_err("Error: Null platform device\n");
+		return NULL;
+	}
+
+	of_node = pdev->dev.of_node;
+
+	pdata = devm_kzalloc(&pdev->dev,
+			sizeof(struct msm_bus_device_node_registration),
+			GFP_KERNEL);
+	if (!pdata) {
+		dev_err(&pdev->dev,
+				"Error: Memory allocation for pdata failed\n");
+		return NULL;
+	}
+
+	pdata->num_devices = of_get_child_count(of_node);
+
+	pdata->info = devm_kzalloc(&pdev->dev,
+			sizeof(struct msm_bus_node_device_type) *
+			pdata->num_devices, GFP_KERNEL);
+
+	if (!pdata->info) {
+		dev_err(&pdev->dev,
+			"Error: Memory allocation for pdata->info failed\n");
+		goto node_reg_err;
+	}
+
+	ret = 0;
+	for_each_child_of_node(of_node, child_node) {
+		ret = get_bus_node_device_data(child_node, pdev,
+				&pdata->info[i]);
+		if (ret) {
+			dev_err(&pdev->dev, "Error: unable to initialize bus nodes\n");
+			goto node_reg_err_1;
+		}
+		i++;
+	}
+
+	dev_dbg(&pdev->dev, "bus topology:\n");
+	for (i = 0; i < pdata->num_devices; i++) {
+		dev_dbg(&pdev->dev, "id %d\nnum_qports %d\nnum_connections %d",
+				pdata->info[i].node_info->id,
+				pdata->info[i].node_info->num_qports,
+				pdata->info[i].node_info->num_connections);
+		dev_dbg(&pdev->dev, "\nbus_device_id %d\n buswidth %d\n",
+				pdata->info[i].node_info->bus_device_id,
+				pdata->info[i].node_info->buswidth);
+		for (j = 0; j < pdata->info[i].node_info->num_connections;
+									j++) {
+			dev_dbg(&pdev->dev, "connection[%d]: %d\n", j,
+				pdata->info[i].node_info->connections[j]);
+		}
+		for (j = 0; j < pdata->info[i].node_info->num_blist;
+									 j++) {
+			dev_dbg(&pdev->dev, "black_listed_node[%d]: %d\n", j,
+				pdata->info[i].node_info->
+				black_listed_connections[j]);
+		}
+		if (pdata->info[i].fabdev)
+			dev_dbg(&pdev->dev, "base_addr %zu\nbus_type %d\n",
+					(size_t)pdata->info[i].
+						fabdev->pqos_base,
+					pdata->info[i].fabdev->bus_type);
+	}
+	return pdata;
+
+node_reg_err_1:
+	devm_kfree(&pdev->dev, pdata->info);
+node_reg_err:
+	devm_kfree(&pdev->dev, pdata);
+	pdata = NULL;
+	return NULL;
+}
+
+static int msm_bus_of_get_ids(struct platform_device *pdev,
+			struct device_node *dev_node, int **dev_ids,
+			int *num_ids, char *prop_name)
+{
+	int ret = 0;
+	int size, i;
+	struct device_node *rule_node;
+	int *ids = NULL;
+
+	if (of_get_property(dev_node, prop_name, &size)) {
+		*num_ids = size / sizeof(int);
+		ids = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
+	} else {
+		dev_err(&pdev->dev, "No rule nodes, skipping node");
+		ret = -ENXIO;
+		goto exit_get_ids;
+	}
+
+	*dev_ids = ids;
+	for (i = 0; i < *num_ids; i++) {
+		rule_node = of_parse_phandle(dev_node, prop_name, i);
+		if (IS_ERR_OR_NULL(rule_node)) {
+			dev_err(&pdev->dev, "Can't get rule node id");
+			ret = -ENXIO;
+			goto err_get_ids;
+		}
+
+		if (of_property_read_u32(rule_node, "cell-id",
+				&ids[i])) {
+			dev_err(&pdev->dev, "Can't get rule node id");
+			ret = -ENXIO;
+			goto err_get_ids;
+		}
+		of_node_put(rule_node);
+	}
+exit_get_ids:
+	return ret;
+err_get_ids:
+	devm_kfree(&pdev->dev, ids);
+	of_node_put(rule_node);
+	ids = NULL;
+	return ret;
+}
+
+int msm_bus_of_get_static_rules(struct platform_device *pdev,
+					struct bus_rule_type **static_rules)
+{
+	int ret = 0;
+	struct device_node *of_node, *child_node;
+	int num_rules = 0;
+	int rule_idx = 0;
+	int bw_fld = 0;
+	int i;
+	struct bus_rule_type *static_rule = NULL;
+
+	of_node = pdev->dev.of_node;
+	num_rules = of_get_child_count(of_node);
+	static_rule = devm_kzalloc(&pdev->dev,
+				sizeof(struct bus_rule_type) * num_rules,
+				GFP_KERNEL);
+
+	if (IS_ERR_OR_NULL(static_rule)) {
+		ret = -ENOMEM;
+		goto exit_static_rules;
+	}
+
+	*static_rules = static_rule;
+	for_each_child_of_node(of_node, child_node) {
+		ret = msm_bus_of_get_ids(pdev, child_node,
+			&static_rule[rule_idx].src_id,
+			&static_rule[rule_idx].num_src,
+			"qcom,src-nodes");
+
+		ret = msm_bus_of_get_ids(pdev, child_node,
+			&static_rule[rule_idx].dst_node,
+			&static_rule[rule_idx].num_dst,
+			"qcom,dest-node");
+
+		ret = of_property_read_u32(child_node, "qcom,src-field",
+				&static_rule[rule_idx].src_field);
+		if (ret) {
+			dev_err(&pdev->dev, "src-field missing");
+			ret = -ENXIO;
+			goto err_static_rules;
+		}
+
+		ret = of_property_read_u32(child_node, "qcom,src-op",
+				&static_rule[rule_idx].op);
+		if (ret) {
+			dev_err(&pdev->dev, "src-op missing");
+			ret = -ENXIO;
+			goto err_static_rules;
+		}
+
+		ret = of_property_read_u32(child_node, "qcom,mode",
+				&static_rule[rule_idx].mode);
+		if (ret) {
+			dev_err(&pdev->dev, "mode missing");
+			ret = -ENXIO;
+			goto err_static_rules;
+		}
+
+		ret = of_property_read_u32(child_node, "qcom,thresh", &bw_fld);
+		if (ret) {
+			dev_err(&pdev->dev, "thresh missing");
+			ret = -ENXIO;
+			goto err_static_rules;
+		} else
+			static_rule[rule_idx].thresh = KBTOB(bw_fld);
+
+		ret = of_property_read_u32(child_node, "qcom,dest-bw",
+								&bw_fld);
+		if (ret)
+			static_rule[rule_idx].dst_bw = 0;
+		else
+			static_rule[rule_idx].dst_bw = KBTOB(bw_fld);
+
+		rule_idx++;
+	}
+	ret = rule_idx;
+exit_static_rules:
+	return ret;
+err_static_rules:
+	for (i = 0; i < num_rules; i++) {
+		if (!IS_ERR_OR_NULL(static_rule)) {
+			if (!IS_ERR_OR_NULL(static_rule[i].src_id))
+				devm_kfree(&pdev->dev,
+						static_rule[i].src_id);
+			if (!IS_ERR_OR_NULL(static_rule[i].dst_node))
+				devm_kfree(&pdev->dev,
+						static_rule[i].dst_node);
+			devm_kfree(&pdev->dev, static_rule);
+		}
+	}
+	devm_kfree(&pdev->dev, *static_rules);
+	static_rules = NULL;
+	return ret;
+}
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_rules.c
@@ -0,0 +1,624 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/list_sort.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include "msm-bus-board.h"
+#include "msm_bus_rules.h"
+#include <trace/events/trace_msm_bus.h>
+
+struct node_vote_info {
+	int id;
+	u64 ib;
+	u64 ab;
+	u64 clk;
+};
+
+struct rules_def {
+	int rule_id;
+	int num_src;
+	int state;
+	struct node_vote_info *src_info;
+	struct bus_rule_type rule_ops;
+	bool state_change;
+	struct list_head link;
+};
+
+struct rule_node_info {
+	int id;
+	void *data;
+	struct raw_notifier_head rule_notify_list;
+	int cur_rule;
+	int num_rules;
+	struct list_head node_rules;
+	struct list_head link;
+	struct rule_apply_rcm_info apply;
+};
+
+DEFINE_MUTEX(msm_bus_rules_lock);
+static LIST_HEAD(node_list);
+static struct rule_node_info *get_node(u32 id, void *data);
+
+#define LE(op1, op2)	(op1 <= op2)
+#define LT(op1, op2)	(op1 < op2)
+#define GE(op1, op2)	(op1 >= op2)
+#define GT(op1, op2)	(op1 > op2)
+#define NB_ID		(0x201)
+
+static struct rule_node_info *get_node(u32 id, void *data)
+{
+	struct rule_node_info *node_it = NULL;
+	struct rule_node_info *node_match = NULL;
+
+	list_for_each_entry(node_it, &node_list, link) {
+		if (node_it->id == id) {
+			if ((id == NB_ID)) {
+				if ((node_it->data == data)) {
+					node_match = node_it;
+					break;
+				}
+			} else {
+				node_match = node_it;
+				break;
+			}
+		}
+	}
+	return node_match;
+}
+
+static struct rule_node_info *gen_node(u32 id, void *data)
+{
+	struct rule_node_info *node_it = NULL;
+	struct rule_node_info *node_match = NULL;
+
+	list_for_each_entry(node_it, &node_list, link) {
+		if (node_it->id == id) {
+			node_match = node_it;
+			break;
+		}
+	}
+
+	if (!node_match) {
+		node_match = kzalloc(sizeof(struct rule_node_info), GFP_KERNEL);
+		if (!node_match) {
+			pr_err("%s: Cannot allocate memory", __func__);
+			goto exit_node_match;
+		}
+
+		node_match->id = id;
+		node_match->cur_rule = -1;
+		node_match->num_rules = 0;
+		node_match->data = data;
+		list_add_tail(&node_match->link, &node_list);
+		INIT_LIST_HEAD(&node_match->node_rules);
+		RAW_INIT_NOTIFIER_HEAD(&node_match->rule_notify_list);
+		pr_debug("Added new node %d to list\n", id);
+	}
+exit_node_match:
+	return node_match;
+}
+
+static bool do_compare_op(u64 op1, u64 op2, int op)
+{
+	bool ret = false;
+
+	switch (op) {
+	case OP_LE:
+		ret = LE(op1, op2);
+		break;
+	case OP_LT:
+		ret = LT(op1, op2);
+		break;
+	case OP_GT:
+		ret = GT(op1, op2);
+		break;
+	case OP_GE:
+		ret = GE(op1, op2);
+		break;
+	case OP_NOOP:
+		ret = true;
+		break;
+	default:
+		pr_info("Invalid OP %d", op);
+		break;
+	}
+	return ret;
+}
+
+static void update_src_id_vote(struct rule_update_path_info *inp_node,
+				struct rule_node_info *rule_node)
+{
+	struct rules_def *rule;
+	int i;
+
+	list_for_each_entry(rule, &rule_node->node_rules, link) {
+		for (i = 0; i < rule->num_src; i++) {
+			if (rule->src_info[i].id == inp_node->id) {
+				rule->src_info[i].ib = inp_node->ib;
+				rule->src_info[i].ab = inp_node->ab;
+				rule->src_info[i].clk = inp_node->clk;
+			}
+		}
+	}
+}
+
+static u64 get_field(struct rules_def *rule, int src_id)
+{
+	u64 field = 0;
+	int i;
+
+	for (i = 0; i < rule->num_src; i++) {
+		switch (rule->rule_ops.src_field) {
+		case FLD_IB:
+			field += rule->src_info[i].ib;
+			break;
+		case FLD_AB:
+			field += rule->src_info[i].ab;
+			break;
+		case FLD_CLK:
+			field += rule->src_info[i].clk;
+			break;
+		}
+	}
+
+	return field;
+}
+
+static bool check_rule(struct rules_def *rule,
+			struct rule_update_path_info *inp)
+{
+	bool ret = false;
+
+	if (!rule)
+		return ret;
+
+	switch (rule->rule_ops.op) {
+	case OP_LE:
+	case OP_LT:
+	case OP_GT:
+	case OP_GE:
+	{
+		u64 src_field = get_field(rule, inp->id);
+		if (!src_field)
+			ret = false;
+		else
+			ret = do_compare_op(src_field, rule->rule_ops.thresh,
+							rule->rule_ops.op);
+		break;
+	}
+	default:
+		pr_err("Unsupported op %d", rule->rule_ops.op);
+		break;
+	}
+	return ret;
+}
+
+static void match_rule(struct rule_update_path_info *inp_node,
+			struct rule_node_info *node)
+{
+	struct rules_def *rule;
+	int i;
+
+	list_for_each_entry(rule, &node->node_rules, link) {
+		for (i = 0; i < rule->num_src; i++) {
+			if (rule->src_info[i].id == inp_node->id) {
+				if (check_rule(rule, inp_node)) {
+					trace_bus_rules_matches(node->cur_rule,
+						inp_node->id, inp_node->ab,
+						inp_node->ib, inp_node->clk);
+					if (rule->state ==
+						RULE_STATE_NOT_APPLIED)
+						rule->state_change = true;
+					rule->state = RULE_STATE_APPLIED;
+				} else {
+					if (rule->state ==
+						RULE_STATE_APPLIED)
+						rule->state_change = true;
+					rule->state = RULE_STATE_NOT_APPLIED;
+				}
+			}
+		}
+	}
+}
+
+static void apply_rule(struct rule_node_info *node,
+			struct list_head *output_list)
+{
+	struct rules_def *rule;
+
+	node->cur_rule = -1;
+	list_for_each_entry(rule, &node->node_rules, link) {
+		if ((rule->state == RULE_STATE_APPLIED) &&
+						(node->cur_rule == -1))
+			node->cur_rule = rule->rule_id;
+
+		if (node->id == NB_ID) {
+			if (rule->state_change) {
+				rule->state_change = false;
+				raw_notifier_call_chain(&node->rule_notify_list,
+					rule->state, (void *)&rule->rule_ops);
+			}
+		} else {
+			if ((rule->state == RULE_STATE_APPLIED) &&
+				(node->cur_rule == rule->rule_id)) {
+				node->apply.id = rule->rule_ops.dst_node[0];
+				node->apply.throttle = rule->rule_ops.mode;
+				node->apply.lim_bw = rule->rule_ops.dst_bw;
+				list_add_tail(&node->apply.link, output_list);
+			}
+			rule->state_change = false;
+		}
+	}
+
+}
+
+int msm_rules_update_path(struct list_head *input_list,
+			struct list_head *output_list)
+{
+	int ret = 0;
+	struct rule_update_path_info  *inp_node;
+	struct rule_node_info *node_it = NULL;
+
+	mutex_lock(&msm_bus_rules_lock);
+	list_for_each_entry(inp_node, input_list, link) {
+		list_for_each_entry(node_it, &node_list, link) {
+			update_src_id_vote(inp_node, node_it);
+			match_rule(inp_node, node_it);
+		}
+	}
+
+	list_for_each_entry(node_it, &node_list, link)
+		apply_rule(node_it, output_list);
+
+	mutex_unlock(&msm_bus_rules_lock);
+	return ret;
+}
+
+static bool ops_equal(int op1, int op2)
+{
+	bool ret = false;
+
+	switch (op1) {
+	case OP_GT:
+	case OP_GE:
+	case OP_LT:
+	case OP_LE:
+		if (abs(op1 - op2) <= 1)
+			ret = true;
+		break;
+	default:
+		ret = (op1 == op2);
+	}
+
+	return ret;
+}
+
+static int node_rules_compare(void *priv, struct list_head *a,
+					struct list_head *b)
+{
+	struct rules_def *ra = container_of(a, struct rules_def, link);
+	struct rules_def *rb = container_of(b, struct rules_def, link);
+	int ret = -1;
+	int64_t th_diff = 0;
+
+
+	if (ra->rule_ops.mode == rb->rule_ops.mode) {
+		if (ops_equal(ra->rule_ops.op, rb->rule_ops.op)) {
+			if ((ra->rule_ops.op == OP_LT) ||
+				(ra->rule_ops.op == OP_LE)) {
+				th_diff = ra->rule_ops.thresh -
+						rb->rule_ops.thresh;
+				if (th_diff > 0)
+					ret = 1;
+				 else
+					ret = -1;
+			} else if ((ra->rule_ops.op == OP_GT) ||
+					(ra->rule_ops.op == OP_GE)) {
+				th_diff = rb->rule_ops.thresh -
+							ra->rule_ops.thresh;
+				if (th_diff > 0)
+					ret = 1;
+				 else
+					ret = -1;
+			}
+		} else
+			ret = ra->rule_ops.op - rb->rule_ops.op;
+	} else if ((ra->rule_ops.mode == THROTTLE_OFF) &&
+		(rb->rule_ops.mode == THROTTLE_ON)) {
+		ret = 1;
+	} else if ((ra->rule_ops.mode == THROTTLE_ON) &&
+		(rb->rule_ops.mode == THROTTLE_OFF)) {
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static void print_rules(struct rule_node_info *node_it)
+{
+	struct rules_def *node_rule = NULL;
+	int i;
+
+	if (!node_it) {
+		pr_err("%s: no node for found", __func__);
+		return;
+	}
+
+	pr_info("\n Now printing rules for Node %d  cur rule %d\n",
+						node_it->id, node_it->cur_rule);
+	list_for_each_entry(node_rule, &node_it->node_rules, link) {
+		pr_info("\n num Rules %d  rule Id %d\n",
+				node_it->num_rules, node_rule->rule_id);
+		pr_info("Rule: src_field %d\n", node_rule->rule_ops.src_field);
+		for (i = 0; i < node_rule->rule_ops.num_src; i++)
+			pr_info("Rule: src %d\n",
+					node_rule->rule_ops.src_id[i]);
+		for (i = 0; i < node_rule->rule_ops.num_dst; i++)
+			pr_info("Rule: dst %d dst_bw %llu\n",
+						node_rule->rule_ops.dst_node[i],
+						node_rule->rule_ops.dst_bw);
+		pr_info("Rule: thresh %llu op %d mode %d State %d\n",
+					node_rule->rule_ops.thresh,
+					node_rule->rule_ops.op,
+					node_rule->rule_ops.mode,
+					node_rule->state);
+	}
+}
+
+void print_all_rules(void)
+{
+	struct rule_node_info *node_it = NULL;
+
+	list_for_each_entry(node_it, &node_list, link)
+		print_rules(node_it);
+}
+
+void print_rules_buf(char *buf, int max_buf)
+{
+	struct rule_node_info *node_it = NULL;
+	struct rules_def *node_rule = NULL;
+	int i;
+	int cnt = 0;
+
+	list_for_each_entry(node_it, &node_list, link) {
+		cnt += scnprintf(buf + cnt, max_buf - cnt,
+					"\n Now printing rules for Node %d cur_rule %d\n",
+					node_it->id, node_it->cur_rule);
+		list_for_each_entry(node_rule, &node_it->node_rules, link) {
+			cnt += scnprintf(buf + cnt, max_buf - cnt,
+				"\nNum Rules:%d ruleId %d STATE:%d change:%d\n",
+				node_it->num_rules, node_rule->rule_id,
+				node_rule->state, node_rule->state_change);
+			cnt += scnprintf(buf + cnt, max_buf - cnt,
+				"Src_field %d\n",
+				node_rule->rule_ops.src_field);
+			for (i = 0; i < node_rule->rule_ops.num_src; i++)
+				cnt += scnprintf(buf + cnt, max_buf - cnt,
+					"Src %d Cur Ib %llu Ab %llu\n",
+					node_rule->rule_ops.src_id[i],
+					node_rule->src_info[i].ib,
+					node_rule->src_info[i].ab);
+			for (i = 0; i < node_rule->rule_ops.num_dst; i++)
+				cnt += scnprintf(buf + cnt, max_buf - cnt,
+					"Dst %d dst_bw %llu\n",
+					node_rule->rule_ops.dst_node[0],
+					node_rule->rule_ops.dst_bw);
+			cnt += scnprintf(buf + cnt, max_buf - cnt,
+					"Thresh %llu op %d mode %d\n",
+					node_rule->rule_ops.thresh,
+					node_rule->rule_ops.op,
+					node_rule->rule_ops.mode);
+		}
+	}
+}
+
+static int copy_rule(struct bus_rule_type *src, struct rules_def *node_rule,
+			struct notifier_block *nb)
+{
+	int i;
+	int ret = 0;
+
+	memcpy(&node_rule->rule_ops, src,
+				sizeof(struct bus_rule_type));
+	node_rule->rule_ops.src_id = kzalloc(
+			(sizeof(int) * node_rule->rule_ops.num_src),
+							GFP_KERNEL);
+	if (!node_rule->rule_ops.src_id) {
+		pr_err("%s:Failed to allocate for src_id",
+					__func__);
+		return -ENOMEM;
+	}
+	memcpy(node_rule->rule_ops.src_id, src->src_id,
+				sizeof(int) * src->num_src);
+
+
+	if (!nb) {
+		node_rule->rule_ops.dst_node = kzalloc(
+			(sizeof(int) * node_rule->rule_ops.num_dst),
+						GFP_KERNEL);
+		if (!node_rule->rule_ops.dst_node) {
+			pr_err("%s:Failed to allocate for src_id",
+							__func__);
+			return -ENOMEM;
+		}
+		memcpy(node_rule->rule_ops.dst_node, src->dst_node,
+						sizeof(int) * src->num_dst);
+	}
+
+	node_rule->num_src = src->num_src;
+	node_rule->src_info = kzalloc(
+		(sizeof(struct node_vote_info) * node_rule->rule_ops.num_src),
+							GFP_KERNEL);
+	if (!node_rule->src_info) {
+		pr_err("%s:Failed to allocate for src_id",
+						__func__);
+		return -ENOMEM;
+	}
+	for (i = 0; i < src->num_src; i++)
+		node_rule->src_info[i].id = src->src_id[i];
+
+	return ret;
+}
+
+void msm_rule_register(int num_rules, struct bus_rule_type *rule,
+					struct notifier_block *nb)
+{
+	struct rule_node_info *node = NULL;
+	int i, j;
+	struct rules_def *node_rule = NULL;
+	int num_dst = 0;
+
+	if (!rule)
+		return;
+
+	mutex_lock(&msm_bus_rules_lock);
+	for (i = 0; i < num_rules; i++) {
+		if (nb)
+			num_dst = 1;
+		else
+			num_dst = rule[i].num_dst;
+
+		for (j = 0; j < num_dst; j++) {
+			int id = 0;
+
+			if (nb)
+				id = NB_ID;
+			else
+				id = rule[i].dst_node[j];
+
+			node = gen_node(id, nb);
+			if (!node) {
+				pr_info("Error getting rule");
+				goto exit_rule_register;
+			}
+			node_rule = kzalloc(sizeof(struct rules_def),
+						GFP_KERNEL);
+			if (!node_rule) {
+				pr_err("%s: Failed to allocate for rule",
+								__func__);
+				goto exit_rule_register;
+			}
+
+			if (copy_rule(&rule[i], node_rule, nb)) {
+				pr_err("Error copying rule");
+				goto exit_rule_register;
+			}
+
+			node_rule->rule_id = node->num_rules++;
+			if (nb)
+				node->data = nb;
+
+			list_add_tail(&node_rule->link, &node->node_rules);
+		}
+	}
+	list_sort(NULL, &node->node_rules, node_rules_compare);
+
+	if (nb)
+		raw_notifier_chain_register(&node->rule_notify_list, nb);
+exit_rule_register:
+	mutex_unlock(&msm_bus_rules_lock);
+	return;
+}
+
+static int comp_rules(struct bus_rule_type *rulea, struct bus_rule_type *ruleb)
+{
+	int ret = 1;
+
+	if (rulea->num_src == ruleb->num_src)
+		ret = memcmp(rulea->src_id, ruleb->src_id,
+				(sizeof(int) * rulea->num_src));
+	if (!ret && (rulea->num_dst == ruleb->num_dst))
+		ret = memcmp(rulea->dst_node, ruleb->dst_node,
+				(sizeof(int) * rulea->num_dst));
+	if (!ret && (rulea->dst_bw == ruleb->dst_bw) &&
+		(rulea->op == ruleb->op) && (rulea->thresh == ruleb->thresh))
+		ret = 0;
+
+	return ret;
+}
+
+void msm_rule_unregister(int num_rules, struct bus_rule_type *rule,
+					struct notifier_block *nb)
+{
+	int i;
+	struct rule_node_info *node = NULL;
+	struct rule_node_info *node_tmp = NULL;
+	struct rules_def *node_rule;
+	struct rules_def *node_rule_tmp;
+	bool match_found = false;
+
+	if (!rule)
+		return;
+
+	mutex_lock(&msm_bus_rules_lock);
+	if (nb) {
+		node = get_node(NB_ID, nb);
+		if (!node) {
+			pr_err("%s: Can't find node", __func__);
+			goto exit_unregister_rule;
+		}
+
+		list_for_each_entry_safe(node_rule, node_rule_tmp,
+					&node->node_rules, link) {
+			list_del(&node_rule->link);
+			kfree(node_rule);
+			node->num_rules--;
+		}
+		raw_notifier_chain_unregister(&node->rule_notify_list, nb);
+	} else {
+		for (i = 0; i < num_rules; i++) {
+			match_found = false;
+
+			list_for_each_entry(node, &node_list, link) {
+				list_for_each_entry_safe(node_rule,
+				node_rule_tmp, &node->node_rules, link) {
+					if (comp_rules(&node_rule->rule_ops,
+						&rule[i]) == 0) {
+						list_del(&node_rule->link);
+						kfree(node_rule);
+						match_found = true;
+						node->num_rules--;
+						list_sort(NULL,
+							&node->node_rules,
+							node_rules_compare);
+						break;
+					}
+				}
+			}
+		}
+	}
+
+	list_for_each_entry_safe(node, node_tmp,
+					&node_list, link) {
+		if (!node->num_rules) {
+			pr_debug("Deleting Rule node %d", node->id);
+			list_del(&node->link);
+			kfree(node);
+		}
+	}
+exit_unregister_rule:
+	mutex_unlock(&msm_bus_rules_lock);
+}
+
+bool msm_rule_are_rules_registered(void)
+{
+	bool ret = false;
+
+	if (list_empty(&node_list))
+		ret = false;
+	else
+		ret = true;
+
+	return ret;
+}
+
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_bus_rules.h
@@ -0,0 +1,77 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _ARCH_ARM_MACH_MSM_BUS_RULES_H
+#define _ARCH_ARM_MACH_MSM_BUS_RULES_H
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/notifier.h>
+#include <dt-bindings/msm/msm-bus-rule-ops.h>
+
+#define MAX_NODES		(5)
+
+struct rule_update_path_info {
+	u32 id;
+	u64 ab;
+	u64 ib;
+	u64 clk;
+	struct list_head link;
+};
+
+struct rule_apply_rcm_info {
+	u32 id;
+	u64 lim_bw;
+	int throttle;
+	bool after_clk_commit;
+	struct list_head link;
+};
+
+struct bus_rule_type {
+	int num_src;
+	int *src_id;
+	int src_field;
+	int op;
+	u64 thresh;
+	int num_dst;
+	int *dst_node;
+	u64 dst_bw;
+	int mode;
+	void *client_data;
+};
+
+#if (defined(CONFIG_BUS_TOPOLOGY_ADHOC))
+void msm_rule_register(int num_rules, struct bus_rule_type *rule,
+				struct notifier_block *nb);
+void msm_rule_unregister(int num_rules, struct bus_rule_type *rule,
+						struct notifier_block *nb);
+void print_rules_buf(char *buf, int count);
+bool msm_rule_are_rules_registered(void);
+#else
+static inline void msm_rule_register(int num_rules, struct bus_rule_type *rule,
+				struct notifier_block *nb)
+{
+}
+static inline void msm_rule_unregister(int num_rules,
+					struct bus_rule_type *rule,
+					struct notifier_block *nb)
+{
+}
+static inline void print_rules_buf(char *buf, int count)
+{
+}
+static inline bool msm_rule_are_rules_registered(void)
+{
+	return false;
+}
+#endif /* defined(CONFIG_BUS_TOPOLOGY_ADHOC) */
+#endif /* _ARCH_ARM_MACH_MSM_BUS_RULES_H */
--- /dev/null
+++ b/drivers/bus/msm_bus/msm_buspm_coresight_adhoc.c
@@ -0,0 +1,189 @@
+/* Copyright (c) 2014 The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/of_coresight.h>
+#include <linux/coresight.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/list.h>
+
+struct msmbus_coresight_adhoc_clock_drvdata {
+	int				 id;
+	struct clk			*clk;
+	struct list_head		 list;
+};
+
+struct msmbus_coresight_adhoc_drvdata {
+	struct device			*dev;
+	struct coresight_device		*csdev;
+	struct coresight_desc		*desc;
+	struct list_head		 clocks;
+};
+
+static int msmbus_coresight_enable_adhoc(struct coresight_device *csdev)
+{
+	struct msmbus_coresight_adhoc_clock_drvdata *clk;
+	struct msmbus_coresight_adhoc_drvdata *drvdata =
+		dev_get_drvdata(csdev->dev.parent);
+	long rate;
+
+	list_for_each_entry(clk, &drvdata->clocks, list) {
+		if (clk->id == csdev->id) {
+			rate = clk_round_rate(clk->clk, 1L);
+			clk_set_rate(clk->clk, rate);
+			return clk_prepare_enable(clk->clk);
+		}
+	}
+
+	return -ENOENT;
+}
+
+static void msmbus_coresight_disable_adhoc(struct coresight_device *csdev)
+{
+	struct msmbus_coresight_adhoc_clock_drvdata *clk;
+	struct msmbus_coresight_adhoc_drvdata *drvdata =
+		dev_get_drvdata(csdev->dev.parent);
+
+	list_for_each_entry(clk, &drvdata->clocks, list) {
+		if (clk->id == csdev->id)
+			clk_disable_unprepare(clk->clk);
+	}
+}
+
+static const struct coresight_ops_source msmbus_coresight_adhoc_source_ops = {
+	.enable		= msmbus_coresight_enable_adhoc,
+	.disable	= msmbus_coresight_disable_adhoc,
+};
+
+static const struct coresight_ops msmbus_coresight_cs_ops = {
+	.source_ops	= &msmbus_coresight_adhoc_source_ops,
+};
+
+void msmbus_coresight_remove_adhoc(struct platform_device *pdev)
+{
+	struct msmbus_coresight_adhoc_clock_drvdata *clk, *next_clk;
+	struct msmbus_coresight_adhoc_drvdata *drvdata =
+		platform_get_drvdata(pdev);
+
+	msmbus_coresight_disable_adhoc(drvdata->csdev);
+	coresight_unregister(drvdata->csdev);
+	list_for_each_entry_safe(clk, next_clk, &drvdata->clocks, list) {
+		list_del(&clk->list);
+		devm_kfree(&pdev->dev, clk);
+	}
+	devm_kfree(&pdev->dev, drvdata->desc);
+	devm_kfree(&pdev->dev, drvdata);
+	platform_set_drvdata(pdev, NULL);
+}
+EXPORT_SYMBOL(msmbus_coresight_remove_adhoc);
+
+static int buspm_of_get_clk_adhoc(struct device_node *of_node,
+	struct msmbus_coresight_adhoc_drvdata *drvdata, int id)
+{
+	struct msmbus_coresight_adhoc_clock_drvdata *clk;
+	clk = devm_kzalloc(drvdata->dev, sizeof(*clk), GFP_KERNEL);
+
+	if (!clk)
+		return -ENOMEM;
+
+	clk->id = id;
+
+	clk->clk = of_clk_get_by_name(of_node, "bus_clk");
+	if (IS_ERR(clk->clk)) {
+		pr_err("Error: unable to get clock for coresight node %d\n",
+			id);
+		goto err;
+	}
+
+	list_add(&clk->list, &drvdata->clocks);
+	return 0;
+
+err:
+	devm_kfree(drvdata->dev, clk);
+	return -EINVAL;
+}
+
+int msmbus_coresight_init_adhoc(struct platform_device *pdev,
+		struct device_node *of_node)
+{
+	int ret;
+	struct device *dev = &pdev->dev;
+	struct coresight_platform_data *pdata;
+	struct msmbus_coresight_adhoc_drvdata *drvdata;
+	struct coresight_desc *desc;
+
+	pdata = of_get_coresight_platform_data(dev, of_node);
+	if (IS_ERR(pdata))
+		return PTR_ERR(pdata);
+
+	drvdata = platform_get_drvdata(pdev);
+	if (IS_ERR_OR_NULL(drvdata)) {
+		drvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);
+		if (!drvdata) {
+			pr_err("coresight: Alloc for drvdata failed\n");
+			return -ENOMEM;
+		}
+		INIT_LIST_HEAD(&drvdata->clocks);
+		drvdata->dev = &pdev->dev;
+		platform_set_drvdata(pdev, drvdata);
+	}
+	ret = buspm_of_get_clk_adhoc(of_node, drvdata, pdata->id);
+	if (ret) {
+		pr_err("Error getting clocks\n");
+		ret = -ENXIO;
+		goto err1;
+	}
+
+	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
+	if (!desc) {
+		pr_err("coresight: Error allocating memory\n");
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	desc->type = CORESIGHT_DEV_TYPE_SOURCE;
+	desc->subtype.source_subtype = CORESIGHT_DEV_SUBTYPE_SOURCE_BUS;
+	desc->ops = &msmbus_coresight_cs_ops;
+	desc->pdata = pdata;
+	desc->dev = &pdev->dev;
+	desc->owner = THIS_MODULE;
+	drvdata->desc = desc;
+	drvdata->csdev = coresight_register(desc);
+	if (IS_ERR(drvdata->csdev)) {
+		pr_err("coresight: Coresight register failed\n");
+		ret = PTR_ERR(drvdata->csdev);
+		goto err0;
+	}
+
+	dev_info(dev, "msmbus_coresight initialized\n");
+
+	return 0;
+err0:
+	devm_kfree(dev, desc);
+err1:
+	devm_kfree(dev, drvdata);
+	platform_set_drvdata(pdev, NULL);
+	return ret;
+}
+EXPORT_SYMBOL(msmbus_coresight_init_adhoc);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("MSM BusPM Adhoc CoreSight Driver");
--- /dev/null
+++ b/drivers/bus/msm_bus/rpm-smd.h
@@ -0,0 +1,268 @@
+/* Copyright (c) 2012, 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __ARCH_ARM_MACH_MSM_RPM_SMD_H
+#define __ARCH_ARM_MACH_MSM_RPM_SMD_H
+
+/**
+ * enum msm_rpm_set - RPM enumerations for sleep/active set
+ * %MSM_RPM_CTX_SET_0: Set resource parameters for active mode.
+ * %MSM_RPM_CTX_SET_SLEEP: Set resource parameters for sleep.
+ */
+enum msm_rpm_set {
+	MSM_RPM_CTX_ACTIVE_SET,
+	MSM_RPM_CTX_SLEEP_SET,
+};
+
+struct msm_rpm_request;
+
+struct msm_rpm_kvp {
+	uint32_t key;
+	uint32_t length;
+	uint8_t *data;
+};
+#ifdef CONFIG_MSM_RPM_SMD
+/**
+ * msm_rpm_request() - Creates a parent element to identify the
+ * resource on the RPM, that stores the KVPs for different fields modified
+ * for a hardware resource
+ *
+ * @set: if the device is setting the active/sleep set parameter
+ * for the resource
+ * @rsc_type: unsigned 32 bit integer that identifies the type of the resource
+ * @rsc_id: unsigned 32 bit that uniquely identifies a resource within a type
+ * @num_elements: number of KVPs pairs associated with the resource
+ *
+ * returns pointer to a msm_rpm_request on success, NULL on error
+ */
+struct msm_rpm_request *msm_rpm_create_request(
+		enum msm_rpm_set set, uint32_t rsc_type,
+		uint32_t rsc_id, int num_elements);
+
+/**
+ * msm_rpm_request_noirq() - Creates a parent element to identify the
+ * resource on the RPM, that stores the KVPs for different fields modified
+ * for a hardware resource. This function is similar to msm_rpm_create_request
+ * except that it has to be called with interrupts masked.
+ *
+ * @set: if the device is setting the active/sleep set parameter
+ * for the resource
+ * @rsc_type: unsigned 32 bit integer that identifies the type of the resource
+ * @rsc_id: unsigned 32 bit that uniquely identifies a resource within a type
+ * @num_elements: number of KVPs pairs associated with the resource
+ *
+ * returns pointer to a msm_rpm_request on success, NULL on error
+ */
+struct msm_rpm_request *msm_rpm_create_request_noirq(
+		enum msm_rpm_set set, uint32_t rsc_type,
+		uint32_t rsc_id, int num_elements);
+
+/**
+ * msm_rpm_add_kvp_data() - Adds a Key value pair to a existing RPM resource.
+ *
+ * @handle: RPM resource handle to which the data should be appended
+ * @key:  unsigned integer identify the parameter modified
+ * @data: byte array that contains the value corresponding to key.
+ * @size:   size of data in bytes.
+ *
+ * returns 0 on success or errno
+ */
+int msm_rpm_add_kvp_data(struct msm_rpm_request *handle,
+		uint32_t key, const uint8_t *data, int size);
+
+/**
+ * msm_rpm_add_kvp_data_noirq() - Adds a Key value pair to a existing RPM
+ * resource. This function is similar to msm_rpm_add_kvp_data except that it
+ * has to be called with interrupts masked.
+ *
+ * @handle: RPM resource handle to which the data should be appended
+ * @key:  unsigned integer identify the parameter modified
+ * @data: byte array that contains the value corresponding to key.
+ * @size:   size of data in bytes.
+ *
+ * returns 0 on success or errno
+ */
+int msm_rpm_add_kvp_data_noirq(struct msm_rpm_request *handle,
+		uint32_t key, const uint8_t *data, int size);
+
+/** msm_rpm_free_request() - clean up the RPM request handle created with
+ * msm_rpm_create_request
+ *
+ * @handle: RPM resource handle to be cleared.
+ */
+
+void msm_rpm_free_request(struct msm_rpm_request *handle);
+
+/**
+ * msm_rpm_send_request() - Send the RPM messages using SMD. The function
+ * assigns a message id before sending the data out to the RPM. RPM hardware
+ * uses the message id to acknowledge the messages.
+ *
+ * @handle: pointer to the msm_rpm_request for the resource being modified.
+ *
+ * returns non-zero message id on success and zero on a failed transaction.
+ * The drivers use message id to wait for ACK from RPM.
+ */
+int msm_rpm_send_request(struct msm_rpm_request *handle);
+
+/**
+ * msm_rpm_send_request_noirq() - Send the RPM messages using SMD. The
+ * function assigns a message id before sending the data out to the RPM.
+ * RPM hardware uses the message id to acknowledge the messages. This function
+ * is similar to msm_rpm_send_request except that it has to be called with
+ * interrupts masked.
+ *
+ * @handle: pointer to the msm_rpm_request for the resource being modified.
+ *
+ * returns non-zero message id on success and zero on a failed transaction.
+ * The drivers use message id to wait for ACK from RPM.
+ */
+int msm_rpm_send_request_noirq(struct msm_rpm_request *handle);
+
+/**
+ * msm_rpm_wait_for_ack() - A blocking call that waits for acknowledgment of
+ * a message from RPM.
+ *
+ * @msg_id: the return from msm_rpm_send_requests
+ *
+ * returns 0 on success or errno
+ */
+int msm_rpm_wait_for_ack(uint32_t msg_id);
+
+/**
+ * msm_rpm_wait_for_ack_noirq() - A blocking call that waits for acknowledgment
+ * of a message from RPM. This function is similar to msm_rpm_wait_for_ack
+ * except that it has to be called with interrupts masked.
+ *
+ * @msg_id: the return from msm_rpm_send_request
+ *
+ * returns 0 on success or errno
+ */
+int msm_rpm_wait_for_ack_noirq(uint32_t msg_id);
+
+/**
+ * msm_rpm_send_message() -Wrapper function for clients to send data given an
+ * array of key value pairs.
+ *
+ * @set: if the device is setting the active/sleep set parameter
+ * for the resource
+ * @rsc_type: unsigned 32 bit integer that identifies the type of the resource
+ * @rsc_id: unsigned 32 bit that uniquely identifies a resource within a type
+ * @kvp: array of KVP data.
+ * @nelem: number of KVPs pairs associated with the message.
+ *
+ * returns  0 on success and errno on failure.
+ */
+int msm_rpm_send_message(enum msm_rpm_set set, uint32_t rsc_type,
+		uint32_t rsc_id, struct msm_rpm_kvp *kvp, int nelems);
+
+/**
+ * msm_rpm_send_message_noirq() -Wrapper function for clients to send data
+ * given an array of key value pairs. This function is similar to the
+ * msm_rpm_send_message() except that it has to be called with interrupts
+ * disabled. Clients should choose the irq version when possible for system
+ * performance.
+ *
+ * @set: if the device is setting the active/sleep set parameter
+ * for the resource
+ * @rsc_type: unsigned 32 bit integer that identifies the type of the resource
+ * @rsc_id: unsigned 32 bit that uniquely identifies a resource within a type
+ * @kvp: array of KVP data.
+ * @nelem: number of KVPs pairs associated with the message.
+ *
+ * returns  0 on success and errno on failure.
+ */
+int msm_rpm_send_message_noirq(enum msm_rpm_set set, uint32_t rsc_type,
+		uint32_t rsc_id, struct msm_rpm_kvp *kvp, int nelems);
+
+/**
+ * msm_rpm_driver_init() - Initialization function that registers for a
+ * rpm platform driver.
+ *
+ * returns 0 on success.
+ */
+int __init msm_rpm_driver_init(void);
+
+#else
+
+static inline struct msm_rpm_request *msm_rpm_create_request(
+		enum msm_rpm_set set, uint32_t rsc_type,
+		uint32_t rsc_id, int num_elements)
+{
+	return NULL;
+}
+
+static inline struct msm_rpm_request *msm_rpm_create_request_noirq(
+		enum msm_rpm_set set, uint32_t rsc_type,
+		uint32_t rsc_id, int num_elements)
+{
+	return NULL;
+
+}
+static inline uint32_t msm_rpm_add_kvp_data(struct msm_rpm_request *handle,
+		uint32_t key, const uint8_t *data, int count)
+{
+	return 0;
+}
+static inline uint32_t msm_rpm_add_kvp_data_noirq(
+		struct msm_rpm_request *handle, uint32_t key,
+		const uint8_t *data, int count)
+{
+	return 0;
+}
+
+static inline void msm_rpm_free_request(struct msm_rpm_request *handle)
+{
+	return;
+}
+
+static inline int msm_rpm_send_request(struct msm_rpm_request *handle)
+{
+	return 0;
+}
+
+static inline int msm_rpm_send_request_noirq(struct msm_rpm_request *handle)
+{
+	return 0;
+
+}
+
+static inline int msm_rpm_send_message(enum msm_rpm_set set, uint32_t rsc_type,
+		uint32_t rsc_id, struct msm_rpm_kvp *kvp, int nelems)
+{
+	return 0;
+}
+
+static inline int msm_rpm_send_message_noirq(enum msm_rpm_set set,
+		uint32_t rsc_type, uint32_t rsc_id, struct msm_rpm_kvp *kvp,
+		int nelems)
+{
+	return 0;
+}
+
+static inline int msm_rpm_wait_for_ack(uint32_t msg_id)
+{
+	return 0;
+
+}
+static inline int msm_rpm_wait_for_ack_noirq(uint32_t msg_id)
+{
+	return 0;
+}
+
+static inline int __init msm_rpm_driver_init(void)
+{
+	return 0;
+}
+#endif
+#endif /*__ARCH_ARM_MACH_MSM_RPM_SMD_H*/
--- /dev/null
+++ b/include/trace/events/trace_msm_bus.h
@@ -0,0 +1,163 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM msm_bus
+
+#if !defined(_TRACE_MSM_BUS_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_MSM_BUS_H
+
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(bus_update_request,
+
+	TP_PROTO(int sec, int nsec, const char *name, unsigned int index,
+		int src, int dest, unsigned long long ab,
+		unsigned long long ib),
+
+	TP_ARGS(sec, nsec, name, index, src, dest, ab, ib),
+
+	TP_STRUCT__entry(
+		__field(int, sec)
+		__field(int, nsec)
+		__string(name, name)
+		__field(u32, index)
+		__field(int, src)
+		__field(int, dest)
+		__field(u64, ab)
+		__field(u64, ib)
+	),
+
+	TP_fast_assign(
+		__entry->sec = sec;
+		__entry->nsec = nsec;
+		__assign_str(name, name);
+		__entry->index = index;
+		__entry->src = src;
+		__entry->dest = dest;
+		__entry->ab = ab;
+		__entry->ib = ib;
+	),
+
+	TP_printk("time= %d.%d name=%s index=%u src=%d dest=%d ab=%llu ib=%llu",
+		__entry->sec,
+		__entry->nsec,
+		__get_str(name),
+		(unsigned int)__entry->index,
+		__entry->src,
+		__entry->dest,
+		(unsigned long long)__entry->ab,
+		(unsigned long long)__entry->ib)
+);
+
+TRACE_EVENT(bus_bimc_config_limiter,
+
+	TP_PROTO(int mas_id, unsigned long long cur_lim_bw),
+
+	TP_ARGS(mas_id, cur_lim_bw),
+
+	TP_STRUCT__entry(
+		__field(int, mas_id)
+		__field(u64, cur_lim_bw)
+	),
+
+	TP_fast_assign(
+		__entry->mas_id = mas_id;
+		__entry->cur_lim_bw = cur_lim_bw;
+	),
+
+	TP_printk("Master=%d cur_lim_bw=%llu",
+		__entry->mas_id,
+		(unsigned long long)__entry->cur_lim_bw)
+);
+
+TRACE_EVENT(bus_avail_bw,
+
+	TP_PROTO(unsigned long long cur_bimc_bw, unsigned long long cur_mdp_bw),
+
+	TP_ARGS(cur_bimc_bw, cur_mdp_bw),
+
+	TP_STRUCT__entry(
+		__field(u64, cur_bimc_bw)
+		__field(u64, cur_mdp_bw)
+	),
+
+	TP_fast_assign(
+		__entry->cur_bimc_bw = cur_bimc_bw;
+		__entry->cur_mdp_bw = cur_mdp_bw;
+	),
+
+	TP_printk("cur_bimc_bw = %llu cur_mdp_bw = %llu",
+		(unsigned long long)__entry->cur_bimc_bw,
+		(unsigned long long)__entry->cur_mdp_bw)
+);
+
+TRACE_EVENT(bus_rules_matches,
+
+	TP_PROTO(int node_id, int rule_id, unsigned long long node_ab,
+		unsigned long long node_ib, unsigned long long node_clk),
+
+	TP_ARGS(node_id, rule_id, node_ab, node_ib, node_clk),
+
+	TP_STRUCT__entry(
+		__field(int, node_id)
+		__field(int, rule_id)
+		__field(u64, node_ab)
+		__field(u64, node_ib)
+		__field(u64, node_clk)
+	),
+
+	TP_fast_assign(
+		__entry->node_id = node_id;
+		__entry->rule_id = rule_id;
+		__entry->node_ab = node_ab;
+		__entry->node_ib = node_ib;
+		__entry->node_clk = node_clk;
+	),
+
+	TP_printk("Rule match node%d rule%d node-ab%llu:ib%llu:clk%llu",
+		__entry->node_id, __entry->rule_id,
+		(unsigned long long)__entry->node_ab,
+		(unsigned long long)__entry->node_ib,
+		(unsigned long long)__entry->node_clk)
+);
+
+TRACE_EVENT(bus_bke_params,
+
+	TP_PROTO(u32 gc, u32 gp, u32 thl, u32 thm, u32 thh),
+
+	TP_ARGS(gc, gp, thl, thm, thh),
+
+	TP_STRUCT__entry(
+		__field(u32, gc)
+		__field(u32, gp)
+		__field(u32, thl)
+		__field(u32, thm)
+		__field(u32, thh)
+	),
+
+	TP_fast_assign(
+		__entry->gc = gc;
+		__entry->gp = gp;
+		__entry->thl = thl;
+		__entry->thm = thm;
+		__entry->thh = thh;
+	),
+
+	TP_printk("BKE Params GC=0x%x GP=0x%x THL=0x%x THM=0x%x THH=0x%x",
+		__entry->gc, __entry->gp, __entry->thl, __entry->thm,
+			__entry->thh)
+);
+
+#endif
+#define TRACE_INCLUDE_FILE trace_msm_bus
+#include <trace/define_trace.h>

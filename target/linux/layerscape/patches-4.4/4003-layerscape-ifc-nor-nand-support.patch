diff --git a/drivers/memory/Kconfig b/drivers/memory/Kconfig
index 6f31546..e91ca04 100644
--- a/drivers/memory/Kconfig
+++ b/drivers/memory/Kconfig
@@ -103,7 +103,7 @@ config FSL_CORENET_CF
 
 config FSL_IFC
 	bool
-	depends on FSL_SOC
+	depends on FSL_SOC || ARCH_LAYERSCAPE || SOC_LS1021A
 
 config JZ4780_NEMC
 	bool "Ingenic JZ4780 SoC NEMC driver"
diff --git a/drivers/memory/fsl_ifc.c b/drivers/memory/fsl_ifc.c
index acd1460..10d2a5f 100644
--- a/drivers/memory/fsl_ifc.c
+++ b/drivers/memory/fsl_ifc.c
@@ -24,6 +24,7 @@
 #include <linux/compiler.h>
 #include <linux/sched.h>
 #include <linux/spinlock.h>
+#include <linux/delay.h>
 #include <linux/types.h>
 #include <linux/slab.h>
 #include <linux/io.h>
@@ -31,10 +32,14 @@
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/fsl_ifc.h>
-#include <asm/prom.h>
+#include <linux/irqdomain.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 
 struct fsl_ifc_ctrl *fsl_ifc_ctrl_dev;
 EXPORT_SYMBOL(fsl_ifc_ctrl_dev);
+#define FSL_IFC_V1_3_0	0x01030000
+#define IFC_TIMEOUT_MSECS	1000 /* 1000ms */
 
 /*
  * convert_ifc_address - convert the base address
@@ -59,11 +64,11 @@ int fsl_ifc_find(phys_addr_t addr_base)
 {
 	int i = 0;
 
-	if (!fsl_ifc_ctrl_dev || !fsl_ifc_ctrl_dev->regs)
+	if (!fsl_ifc_ctrl_dev || !fsl_ifc_ctrl_dev->gregs)
 		return -ENODEV;
 
 	for (i = 0; i < fsl_ifc_ctrl_dev->banks; i++) {
-		u32 cspr = ifc_in32(&fsl_ifc_ctrl_dev->regs->cspr_cs[i].cspr);
+		u32 cspr = ifc_in32(&fsl_ifc_ctrl_dev->gregs->cspr_cs[i].cspr);
 		if (cspr & CSPR_V && (cspr & CSPR_BA) ==
 				convert_ifc_address(addr_base))
 			return i;
@@ -75,7 +80,7 @@ EXPORT_SYMBOL(fsl_ifc_find);
 
 static int fsl_ifc_ctrl_init(struct fsl_ifc_ctrl *ctrl)
 {
-	struct fsl_ifc_regs __iomem *ifc = ctrl->regs;
+	struct fsl_ifc_global __iomem *ifc = ctrl->gregs;
 
 	/*
 	 * Clear all the common status and event registers
@@ -104,7 +109,7 @@ static int fsl_ifc_ctrl_remove(struct platform_device *dev)
 	irq_dispose_mapping(ctrl->nand_irq);
 	irq_dispose_mapping(ctrl->irq);
 
-	iounmap(ctrl->regs);
+	iounmap(ctrl->gregs);
 
 	dev_set_drvdata(&dev->dev, NULL);
 	kfree(ctrl);
@@ -122,7 +127,7 @@ static DEFINE_SPINLOCK(nand_irq_lock);
 
 static u32 check_nand_stat(struct fsl_ifc_ctrl *ctrl)
 {
-	struct fsl_ifc_regs __iomem *ifc = ctrl->regs;
+	struct fsl_ifc_runtime __iomem *ifc = ctrl->rregs;
 	unsigned long flags;
 	u32 stat;
 
@@ -157,7 +162,7 @@ static irqreturn_t fsl_ifc_nand_irq(int irqno, void *data)
 static irqreturn_t fsl_ifc_ctrl_irq(int irqno, void *data)
 {
 	struct fsl_ifc_ctrl *ctrl = data;
-	struct fsl_ifc_regs __iomem *ifc = ctrl->regs;
+	struct fsl_ifc_global __iomem *ifc = ctrl->gregs;
 	u32 err_axiid, err_srcid, status, cs_err, err_addr;
 	irqreturn_t ret = IRQ_NONE;
 
@@ -215,6 +220,7 @@ static int fsl_ifc_ctrl_probe(struct platform_device *dev)
 {
 	int ret = 0;
 	int version, banks;
+	void __iomem *addr;
 
 	dev_info(&dev->dev, "Freescale Integrated Flash Controller\n");
 
@@ -225,22 +231,13 @@ static int fsl_ifc_ctrl_probe(struct platform_device *dev)
 	dev_set_drvdata(&dev->dev, fsl_ifc_ctrl_dev);
 
 	/* IOMAP the entire IFC region */
-	fsl_ifc_ctrl_dev->regs = of_iomap(dev->dev.of_node, 0);
-	if (!fsl_ifc_ctrl_dev->regs) {
+	fsl_ifc_ctrl_dev->gregs = of_iomap(dev->dev.of_node, 0);
+	if (!fsl_ifc_ctrl_dev->gregs) {
 		dev_err(&dev->dev, "failed to get memory region\n");
 		ret = -ENODEV;
 		goto err;
 	}
 
-	version = ifc_in32(&fsl_ifc_ctrl_dev->regs->ifc_rev) &
-			FSL_IFC_VERSION_MASK;
-	banks = (version == FSL_IFC_VERSION_1_0_0) ? 4 : 8;
-	dev_info(&dev->dev, "IFC version %d.%d, %d banks\n",
-		version >> 24, (version >> 16) & 0xf, banks);
-
-	fsl_ifc_ctrl_dev->version = version;
-	fsl_ifc_ctrl_dev->banks = banks;
-
 	if (of_property_read_bool(dev->dev.of_node, "little-endian")) {
 		fsl_ifc_ctrl_dev->little_endian = true;
 		dev_dbg(&dev->dev, "IFC REGISTERS are LITTLE endian\n");
@@ -249,8 +246,9 @@ static int fsl_ifc_ctrl_probe(struct platform_device *dev)
 		dev_dbg(&dev->dev, "IFC REGISTERS are BIG endian\n");
 	}
 
-	version = ioread32be(&fsl_ifc_ctrl_dev->regs->ifc_rev) &
+	version = ifc_in32(&fsl_ifc_ctrl_dev->gregs->ifc_rev) &
 			FSL_IFC_VERSION_MASK;
+
 	banks = (version == FSL_IFC_VERSION_1_0_0) ? 4 : 8;
 	dev_info(&dev->dev, "IFC version %d.%d, %d banks\n",
 		version >> 24, (version >> 16) & 0xf, banks);
@@ -258,9 +256,16 @@ static int fsl_ifc_ctrl_probe(struct platform_device *dev)
 	fsl_ifc_ctrl_dev->version = version;
 	fsl_ifc_ctrl_dev->banks = banks;
 
+	addr = fsl_ifc_ctrl_dev->gregs;
+	if (version >= FSL_IFC_VERSION_2_0_0)
+		addr += PGOFFSET_64K;
+	else
+		addr += PGOFFSET_4K;
+	fsl_ifc_ctrl_dev->rregs = addr;
+
 	/* get the Controller level irq */
 	fsl_ifc_ctrl_dev->irq = irq_of_parse_and_map(dev->dev.of_node, 0);
-	if (fsl_ifc_ctrl_dev->irq == NO_IRQ) {
+	if (fsl_ifc_ctrl_dev->irq == 0) {
 		dev_err(&dev->dev, "failed to get irq resource "
 							"for IFC\n");
 		ret = -ENODEV;
@@ -309,6 +314,261 @@ err:
 	return ret;
 }
 
+#ifdef CONFIG_PM_SLEEP
+/* save ifc registers */
+static int fsl_ifc_suspend(struct device *dev)
+{
+	struct fsl_ifc_ctrl *ctrl = dev_get_drvdata(dev);
+	struct fsl_ifc_global __iomem *fcm = ctrl->gregs;
+	struct fsl_ifc_runtime __iomem *runtime = ctrl->rregs;
+	__be32 nand_evter_intr_en, cm_evter_intr_en, nor_evter_intr_en,
+							 gpcm_evter_intr_en;
+	uint32_t ifc_bank, i;
+
+	ctrl->saved_gregs = kzalloc(sizeof(struct fsl_ifc_global), GFP_KERNEL);
+	if (!ctrl->saved_gregs)
+		return -ENOMEM;
+	ctrl->saved_rregs = kzalloc(sizeof(struct fsl_ifc_runtime), GFP_KERNEL);
+	if (!ctrl->saved_rregs)
+		return -ENOMEM;
+
+	cm_evter_intr_en = ifc_in32(&fcm->cm_evter_intr_en);
+	nand_evter_intr_en = ifc_in32(&runtime->ifc_nand.nand_evter_intr_en);
+	nor_evter_intr_en = ifc_in32(&runtime->ifc_nor.nor_evter_intr_en);
+	gpcm_evter_intr_en = ifc_in32(&runtime->ifc_gpcm.gpcm_evter_intr_en);
+
+/* IFC interrupts disabled */
+
+	ifc_out32(0x0, &fcm->cm_evter_intr_en);
+	ifc_out32(0x0, &runtime->ifc_nand.nand_evter_intr_en);
+	ifc_out32(0x0, &runtime->ifc_nor.nor_evter_intr_en);
+	ifc_out32(0x0, &runtime->ifc_gpcm.gpcm_evter_intr_en);
+
+	if (ctrl->saved_gregs) {
+		for (ifc_bank = 0; ifc_bank < FSL_IFC_BANK_COUNT; ifc_bank++) {
+			ctrl->saved_gregs->cspr_cs[ifc_bank].cspr_ext =
+				ifc_in32(&fcm->cspr_cs[ifc_bank].cspr_ext);
+			ctrl->saved_gregs->cspr_cs[ifc_bank].cspr =
+				ifc_in32(&fcm->cspr_cs[ifc_bank].cspr);
+			ctrl->saved_gregs->amask_cs[ifc_bank].amask =
+				ifc_in32(&fcm->amask_cs[ifc_bank].amask);
+			ctrl->saved_gregs->csor_cs[ifc_bank].csor_ext =
+				ifc_in32(&fcm->csor_cs[ifc_bank].csor_ext);
+			ctrl->saved_gregs->csor_cs[ifc_bank].csor =
+				ifc_in32(&fcm->csor_cs[ifc_bank].csor);
+			for (i = 0; i < 4; i++) {
+				ctrl->saved_gregs->ftim_cs[ifc_bank].ftim[i] =
+					ifc_in32(
+					&fcm->ftim_cs[ifc_bank].ftim[i]);
+			}
+		}
+
+		ctrl->saved_gregs->rb_map = ifc_in32(&fcm->rb_map);
+		ctrl->saved_gregs->wb_map = ifc_in32(&fcm->wb_map);
+		ctrl->saved_gregs->ifc_gcr = ifc_in32(&fcm->ifc_gcr);
+		ctrl->saved_gregs->ddr_ccr_low = ifc_in32(&fcm->ddr_ccr_low);
+		ctrl->saved_gregs->cm_evter_en = ifc_in32(&fcm->cm_evter_en);
+	}
+
+	if (ctrl->saved_rregs) {
+		/* IFC controller NAND machine registers */
+		ctrl->saved_rregs->ifc_nand.ncfgr =
+					ifc_in32(&runtime->ifc_nand.ncfgr);
+		ctrl->saved_rregs->ifc_nand.nand_fcr0 =
+					ifc_in32(&runtime->ifc_nand.nand_fcr0);
+		ctrl->saved_rregs->ifc_nand.nand_fcr1 =
+					ifc_in32(&runtime->ifc_nand.nand_fcr1);
+		ctrl->saved_rregs->ifc_nand.row0 =
+					ifc_in32(&runtime->ifc_nand.row0);
+		ctrl->saved_rregs->ifc_nand.row1 =
+					ifc_in32(&runtime->ifc_nand.row1);
+		ctrl->saved_rregs->ifc_nand.col0 =
+					ifc_in32(&runtime->ifc_nand.col0);
+		ctrl->saved_rregs->ifc_nand.col1 =
+					ifc_in32(&runtime->ifc_nand.col1);
+		ctrl->saved_rregs->ifc_nand.row2 =
+					ifc_in32(&runtime->ifc_nand.row2);
+		ctrl->saved_rregs->ifc_nand.col2 =
+					ifc_in32(&runtime->ifc_nand.col2);
+		ctrl->saved_rregs->ifc_nand.row3 =
+					ifc_in32(&runtime->ifc_nand.row3);
+		ctrl->saved_rregs->ifc_nand.col3 =
+					ifc_in32(&runtime->ifc_nand.col3);
+
+		ctrl->saved_rregs->ifc_nand.nand_fbcr =
+					ifc_in32(&runtime->ifc_nand.nand_fbcr);
+		ctrl->saved_rregs->ifc_nand.nand_fir0 =
+					ifc_in32(&runtime->ifc_nand.nand_fir0);
+		ctrl->saved_rregs->ifc_nand.nand_fir1 =
+					ifc_in32(&runtime->ifc_nand.nand_fir1);
+		ctrl->saved_rregs->ifc_nand.nand_fir2 =
+					ifc_in32(&runtime->ifc_nand.nand_fir2);
+		ctrl->saved_rregs->ifc_nand.nand_csel =
+					ifc_in32(&runtime->ifc_nand.nand_csel);
+		ctrl->saved_rregs->ifc_nand.nandseq_strt =
+					ifc_in32(
+					&runtime->ifc_nand.nandseq_strt);
+		ctrl->saved_rregs->ifc_nand.nand_evter_en =
+					ifc_in32(
+					&runtime->ifc_nand.nand_evter_en);
+		ctrl->saved_rregs->ifc_nand.nanndcr =
+					ifc_in32(&runtime->ifc_nand.nanndcr);
+		ctrl->saved_rregs->ifc_nand.nand_dll_lowcfg0 =
+					ifc_in32(
+					&runtime->ifc_nand.nand_dll_lowcfg0);
+		ctrl->saved_rregs->ifc_nand.nand_dll_lowcfg1 =
+					ifc_in32(
+					&runtime->ifc_nand.nand_dll_lowcfg1);
+
+		/* IFC controller NOR machine registers */
+		ctrl->saved_rregs->ifc_nor.nor_evter_en =
+					ifc_in32(
+					&runtime->ifc_nor.nor_evter_en);
+		ctrl->saved_rregs->ifc_nor.norcr =
+					ifc_in32(&runtime->ifc_nor.norcr);
+
+		/* IFC controller GPCM Machine registers */
+		ctrl->saved_rregs->ifc_gpcm.gpcm_evter_en =
+					ifc_in32(
+					&runtime->ifc_gpcm.gpcm_evter_en);
+	}
+
+/* save the interrupt values */
+	ctrl->saved_gregs->cm_evter_intr_en = cm_evter_intr_en;
+	ctrl->saved_rregs->ifc_nand.nand_evter_intr_en = nand_evter_intr_en;
+	ctrl->saved_rregs->ifc_nor.nor_evter_intr_en = nor_evter_intr_en;
+	ctrl->saved_rregs->ifc_gpcm.gpcm_evter_intr_en = gpcm_evter_intr_en;
+
+	return 0;
+}
+
+/* restore ifc registers */
+static int fsl_ifc_resume(struct device *dev)
+{
+	struct fsl_ifc_ctrl *ctrl = dev_get_drvdata(dev);
+	struct fsl_ifc_global __iomem *fcm = ctrl->gregs;
+	struct fsl_ifc_runtime __iomem *runtime = ctrl->rregs;
+	struct fsl_ifc_global *savd_gregs = ctrl->saved_gregs;
+	struct fsl_ifc_runtime *savd_rregs = ctrl->saved_rregs;
+	uint32_t ver = 0, ncfgr, timeout, ifc_bank, i;
+
+/*
+ * IFC interrupts disabled
+ */
+	ifc_out32(0x0, &fcm->cm_evter_intr_en);
+	ifc_out32(0x0, &runtime->ifc_nand.nand_evter_intr_en);
+	ifc_out32(0x0, &runtime->ifc_nor.nor_evter_intr_en);
+	ifc_out32(0x0, &runtime->ifc_gpcm.gpcm_evter_intr_en);
+
+
+	if (ctrl->saved_gregs) {
+		for (ifc_bank = 0; ifc_bank < FSL_IFC_BANK_COUNT; ifc_bank++) {
+			ifc_out32(savd_gregs->cspr_cs[ifc_bank].cspr_ext,
+					&fcm->cspr_cs[ifc_bank].cspr_ext);
+			ifc_out32(savd_gregs->cspr_cs[ifc_bank].cspr,
+					&fcm->cspr_cs[ifc_bank].cspr);
+			ifc_out32(savd_gregs->amask_cs[ifc_bank].amask,
+					&fcm->amask_cs[ifc_bank].amask);
+			ifc_out32(savd_gregs->csor_cs[ifc_bank].csor_ext,
+					&fcm->csor_cs[ifc_bank].csor_ext);
+			ifc_out32(savd_gregs->csor_cs[ifc_bank].csor,
+					&fcm->csor_cs[ifc_bank].csor);
+			for (i = 0; i < 4; i++) {
+				ifc_out32(savd_gregs->ftim_cs[ifc_bank].ftim[i],
+					&fcm->ftim_cs[ifc_bank].ftim[i]);
+			}
+		}
+		ifc_out32(savd_gregs->rb_map, &fcm->rb_map);
+		ifc_out32(savd_gregs->wb_map, &fcm->wb_map);
+		ifc_out32(savd_gregs->ifc_gcr, &fcm->ifc_gcr);
+		ifc_out32(savd_gregs->ddr_ccr_low, &fcm->ddr_ccr_low);
+		ifc_out32(savd_gregs->cm_evter_en, &fcm->cm_evter_en);
+	}
+
+	if (ctrl->saved_rregs) {
+		/* IFC controller NAND machine registers */
+		ifc_out32(savd_rregs->ifc_nand.ncfgr,
+						&runtime->ifc_nand.ncfgr);
+		ifc_out32(savd_rregs->ifc_nand.nand_fcr0,
+						&runtime->ifc_nand.nand_fcr0);
+		ifc_out32(savd_rregs->ifc_nand.nand_fcr1,
+						&runtime->ifc_nand.nand_fcr1);
+		ifc_out32(savd_rregs->ifc_nand.row0, &runtime->ifc_nand.row0);
+		ifc_out32(savd_rregs->ifc_nand.row1, &runtime->ifc_nand.row1);
+		ifc_out32(savd_rregs->ifc_nand.col0, &runtime->ifc_nand.col0);
+		ifc_out32(savd_rregs->ifc_nand.col1, &runtime->ifc_nand.col1);
+		ifc_out32(savd_rregs->ifc_nand.row2, &runtime->ifc_nand.row2);
+		ifc_out32(savd_rregs->ifc_nand.col2, &runtime->ifc_nand.col2);
+		ifc_out32(savd_rregs->ifc_nand.row3, &runtime->ifc_nand.row3);
+		ifc_out32(savd_rregs->ifc_nand.col3, &runtime->ifc_nand.col3);
+		ifc_out32(savd_rregs->ifc_nand.nand_fbcr,
+						&runtime->ifc_nand.nand_fbcr);
+		ifc_out32(savd_rregs->ifc_nand.nand_fir0,
+						&runtime->ifc_nand.nand_fir0);
+		ifc_out32(savd_rregs->ifc_nand.nand_fir1,
+						&runtime->ifc_nand.nand_fir1);
+		ifc_out32(savd_rregs->ifc_nand.nand_fir2,
+						&runtime->ifc_nand.nand_fir2);
+		ifc_out32(savd_rregs->ifc_nand.nand_csel,
+						&runtime->ifc_nand.nand_csel);
+		ifc_out32(savd_rregs->ifc_nand.nandseq_strt,
+					&runtime->ifc_nand.nandseq_strt);
+		ifc_out32(savd_rregs->ifc_nand.nand_evter_en,
+					&runtime->ifc_nand.nand_evter_en);
+		ifc_out32(savd_rregs->ifc_nand.nanndcr,
+					&runtime->ifc_nand.nanndcr);
+		ifc_out32(savd_rregs->ifc_nand.nand_dll_lowcfg0,
+					&runtime->ifc_nand.nand_dll_lowcfg0);
+		ifc_out32(savd_rregs->ifc_nand.nand_dll_lowcfg1,
+					&runtime->ifc_nand.nand_dll_lowcfg1);
+
+		/* IFC controller NOR machine registers */
+		ifc_out32(savd_rregs->ifc_nor.nor_evter_en,
+					&runtime->ifc_nor.nor_evter_en);
+		ifc_out32(savd_rregs->ifc_nor.norcr, &runtime->ifc_nor.norcr);
+
+		/* IFC controller GPCM Machine registers */
+		ifc_out32(savd_rregs->ifc_gpcm.gpcm_evter_en,
+					&runtime->ifc_gpcm.gpcm_evter_en);
+
+		/* IFC interrupts enabled */
+		ifc_out32(ctrl->saved_gregs->cm_evter_intr_en,
+					&fcm->cm_evter_intr_en);
+		ifc_out32(ctrl->saved_rregs->ifc_nand.nand_evter_intr_en,
+					&runtime->ifc_nand.nand_evter_intr_en);
+		ifc_out32(ctrl->saved_rregs->ifc_nor.nor_evter_intr_en,
+					&runtime->ifc_nor.nor_evter_intr_en);
+		ifc_out32(ctrl->saved_rregs->ifc_gpcm.gpcm_evter_intr_en,
+					&runtime->ifc_gpcm.gpcm_evter_intr_en);
+
+		kfree(ctrl->saved_gregs);
+		kfree(ctrl->saved_rregs);
+		ctrl->saved_gregs = NULL;
+		ctrl->saved_rregs = NULL;
+	}
+
+	ver = ifc_in32(&fcm->ifc_rev);
+	ncfgr = ifc_in32(&runtime->ifc_nand.ncfgr);
+	if (ver >= FSL_IFC_V1_3_0) {
+
+		ifc_out32(ncfgr | IFC_NAND_SRAM_INIT_EN,
+					&runtime->ifc_nand.ncfgr);
+		/* wait for  SRAM_INIT bit to be clear or timeout */
+		timeout = 10;
+		while ((ifc_in32(&runtime->ifc_nand.ncfgr) &
+			IFC_NAND_SRAM_INIT_EN) && timeout) {
+			mdelay(IFC_TIMEOUT_MSECS);
+			timeout--;
+		}
+
+		if (!timeout)
+			dev_err(ctrl->dev, "Timeout waiting for IFC SRAM INIT");
+	}
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
 static const struct of_device_id fsl_ifc_match[] = {
 	{
 		.compatible = "fsl,ifc",
@@ -316,10 +576,15 @@ static const struct of_device_id fsl_ifc_match[] = {
 	{},
 };
 
+static const struct dev_pm_ops ifc_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(fsl_ifc_suspend, fsl_ifc_resume)
+};
+
 static struct platform_driver fsl_ifc_ctrl_driver = {
 	.driver = {
 		.name	= "fsl-ifc",
 		.of_match_table = fsl_ifc_match,
+		.pm = &ifc_pm_ops,
 	},
 	.probe       = fsl_ifc_ctrl_probe,
 	.remove      = fsl_ifc_ctrl_remove,
diff --git a/drivers/mtd/maps/physmap_of.c b/drivers/mtd/maps/physmap_of.c
index fef1d1b..2624cc4 100644
--- a/drivers/mtd/maps/physmap_of.c
+++ b/drivers/mtd/maps/physmap_of.c
@@ -20,6 +20,7 @@
 #include <linux/mtd/map.h>
 #include <linux/mtd/partitions.h>
 #include <linux/mtd/concat.h>
+#include <linux/mtd/cfi_endian.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
@@ -204,6 +205,9 @@ static int of_flash_probe(struct platform_device *dev)
 		info->list[i].map.bankwidth = be32_to_cpup(width);
 		info->list[i].map.device_node = dp;
 
+		if (of_property_read_bool(dp->parent, "big-endian"))
+			info->list[i].map.swap = CFI_BIG_ENDIAN;
+
 		err = -ENOMEM;
 		info->list[i].map.virt = ioremap(info->list[i].map.phys,
 						 info->list[i].map.size);
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 8f49f8a..353b247 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -436,7 +436,7 @@ config MTD_NAND_FSL_ELBC
 
 config MTD_NAND_FSL_IFC
 	tristate "NAND support for Freescale IFC controller"
-	depends on MTD_NAND && FSL_SOC
+	depends on FSL_SOC || ARCH_LAYERSCAPE || SOC_LS1021A
 	select FSL_IFC
 	select MEMORY
 	help
diff --git a/drivers/mtd/nand/fsl_ifc_nand.c b/drivers/mtd/nand/fsl_ifc_nand.c
index 7f4ac8c..5e722b7 100644
--- a/drivers/mtd/nand/fsl_ifc_nand.c
+++ b/drivers/mtd/nand/fsl_ifc_nand.c
@@ -233,7 +233,7 @@ static void set_addr(struct mtd_info *mtd, int column, int page_addr, int oob)
 	struct nand_chip *chip = mtd->priv;
 	struct fsl_ifc_mtd *priv = chip->priv;
 	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
-	struct fsl_ifc_regs __iomem *ifc = ctrl->regs;
+	struct fsl_ifc_runtime __iomem *ifc = ctrl->rregs;
 	int buf_num;
 
 	ifc_nand_ctrl->page = page_addr;
@@ -296,7 +296,7 @@ static void fsl_ifc_run_command(struct mtd_info *mtd)
 	struct fsl_ifc_mtd *priv = chip->priv;
 	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
 	struct fsl_ifc_nand_ctrl *nctrl = ifc_nand_ctrl;
-	struct fsl_ifc_regs __iomem *ifc = ctrl->regs;
+	struct fsl_ifc_runtime __iomem *ifc = ctrl->rregs;
 	u32 eccstat[4];
 	int i;
 
@@ -334,9 +334,15 @@ static void fsl_ifc_run_command(struct mtd_info *mtd)
 		int bufnum = nctrl->page & priv->bufnum_mask;
 		int sector = bufnum * chip->ecc.steps;
 		int sector_end = sector + chip->ecc.steps - 1;
+		__be32 *eccstat_regs;
+
+		if (ctrl->version >= FSL_IFC_VERSION_2_0_0)
+			eccstat_regs = ifc->ifc_nand.v2_nand_eccstat;
+		else
+			eccstat_regs = ifc->ifc_nand.v1_nand_eccstat;
 
 		for (i = sector / 4; i <= sector_end / 4; i++)
-			eccstat[i] = ifc_in32(&ifc->ifc_nand.nand_eccstat[i]);
+			eccstat[i] = ifc_in32(&eccstat_regs[i]);
 
 		for (i = sector; i <= sector_end; i++) {
 			errors = check_read_ecc(mtd, ctrl, eccstat, i);
@@ -372,7 +378,7 @@ static void fsl_ifc_do_read(struct nand_chip *chip,
 {
 	struct fsl_ifc_mtd *priv = chip->priv;
 	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
-	struct fsl_ifc_regs __iomem *ifc = ctrl->regs;
+	struct fsl_ifc_runtime __iomem *ifc = ctrl->rregs;
 
 	/* Program FIR/IFC_NAND_FCR0 for Small/Large page */
 	if (mtd->writesize > 512) {
@@ -412,7 +418,7 @@ static void fsl_ifc_cmdfunc(struct mtd_info *mtd, unsigned int command,
 	struct nand_chip *chip = mtd->priv;
 	struct fsl_ifc_mtd *priv = chip->priv;
 	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
-	struct fsl_ifc_regs __iomem *ifc = ctrl->regs;
+	struct fsl_ifc_runtime __iomem *ifc = ctrl->rregs;
 
 	/* clear the read buffer */
 	ifc_nand_ctrl->read_bytes = 0;
@@ -724,7 +730,7 @@ static int fsl_ifc_wait(struct mtd_info *mtd, struct nand_chip *chip)
 {
 	struct fsl_ifc_mtd *priv = chip->priv;
 	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
-	struct fsl_ifc_regs __iomem *ifc = ctrl->regs;
+	struct fsl_ifc_runtime __iomem *ifc = ctrl->rregs;
 	u32 nand_fsr;
 
 	/* Use READ_STATUS command, but wait for the device to be ready */
@@ -826,39 +832,42 @@ static int fsl_ifc_chip_init_tail(struct mtd_info *mtd)
 static void fsl_ifc_sram_init(struct fsl_ifc_mtd *priv)
 {
 	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
-	struct fsl_ifc_regs __iomem *ifc = ctrl->regs;
+	struct fsl_ifc_runtime __iomem *ifc_runtime = ctrl->rregs;
+	struct fsl_ifc_global __iomem *ifc_global = ctrl->gregs;
 	uint32_t csor = 0, csor_8k = 0, csor_ext = 0;
 	uint32_t cs = priv->bank;
 
 	/* Save CSOR and CSOR_ext */
-	csor = ifc_in32(&ifc->csor_cs[cs].csor);
-	csor_ext = ifc_in32(&ifc->csor_cs[cs].csor_ext);
+	csor = ifc_in32(&ifc_global->csor_cs[cs].csor);
+	csor_ext = ifc_in32(&ifc_global->csor_cs[cs].csor_ext);
 
 	/* chage PageSize 8K and SpareSize 1K*/
 	csor_8k = (csor & ~(CSOR_NAND_PGS_MASK)) | 0x0018C000;
-	ifc_out32(csor_8k, &ifc->csor_cs[cs].csor);
-	ifc_out32(0x0000400, &ifc->csor_cs[cs].csor_ext);
+	ifc_out32(csor_8k, &ifc_global->csor_cs[cs].csor);
+	ifc_out32(0x0000400, &ifc_global->csor_cs[cs].csor_ext);
 
 	/* READID */
 	ifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |
-		  (IFC_FIR_OP_UA  << IFC_NAND_FIR0_OP1_SHIFT) |
-		  (IFC_FIR_OP_RB << IFC_NAND_FIR0_OP2_SHIFT),
-		  &ifc->ifc_nand.nand_fir0);
+		    (IFC_FIR_OP_UA  << IFC_NAND_FIR0_OP1_SHIFT) |
+		    (IFC_FIR_OP_RB << IFC_NAND_FIR0_OP2_SHIFT),
+		    &ifc_runtime->ifc_nand.nand_fir0);
 	ifc_out32(NAND_CMD_READID << IFC_NAND_FCR0_CMD0_SHIFT,
-		  &ifc->ifc_nand.nand_fcr0);
-	ifc_out32(0x0, &ifc->ifc_nand.row3);
+		    &ifc_runtime->ifc_nand.nand_fcr0);
+	ifc_out32(0x0, &ifc_runtime->ifc_nand.row3);
 
-	ifc_out32(0x0, &ifc->ifc_nand.nand_fbcr);
+	ifc_out32(0x0, &ifc_runtime->ifc_nand.nand_fbcr);
 
 	/* Program ROW0/COL0 */
-	ifc_out32(0x0, &ifc->ifc_nand.row0);
-	ifc_out32(0x0, &ifc->ifc_nand.col0);
+	ifc_out32(0x0, &ifc_runtime->ifc_nand.row0);
+	ifc_out32(0x0, &ifc_runtime->ifc_nand.col0);
 
 	/* set the chip select for NAND Transaction */
-	ifc_out32(cs << IFC_NAND_CSEL_SHIFT, &ifc->ifc_nand.nand_csel);
+	ifc_out32(cs << IFC_NAND_CSEL_SHIFT,
+		&ifc_runtime->ifc_nand.nand_csel);
 
 	/* start read seq */
-	ifc_out32(IFC_NAND_SEQ_STRT_FIR_STRT, &ifc->ifc_nand.nandseq_strt);
+	ifc_out32(IFC_NAND_SEQ_STRT_FIR_STRT,
+		&ifc_runtime->ifc_nand.nandseq_strt);
 
 	/* wait for command complete flag or timeout */
 	wait_event_timeout(ctrl->nand_wait, ctrl->nand_stat,
@@ -868,14 +877,15 @@ static void fsl_ifc_sram_init(struct fsl_ifc_mtd *priv)
 		printk(KERN_ERR "fsl-ifc: Failed to Initialise SRAM\n");
 
 	/* Restore CSOR and CSOR_ext */
-	ifc_out32(csor, &ifc->csor_cs[cs].csor);
-	ifc_out32(csor_ext, &ifc->csor_cs[cs].csor_ext);
+	ifc_out32(csor, &ifc_global->csor_cs[cs].csor);
+	ifc_out32(csor_ext, &ifc_global->csor_cs[cs].csor_ext);
 }
 
 static int fsl_ifc_chip_init(struct fsl_ifc_mtd *priv)
 {
 	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
-	struct fsl_ifc_regs __iomem *ifc = ctrl->regs;
+	struct fsl_ifc_global __iomem *ifc_global = ctrl->gregs;
+	struct fsl_ifc_runtime __iomem *ifc_runtime = ctrl->rregs;
 	struct nand_chip *chip = &priv->chip;
 	struct nand_ecclayout *layout;
 	u32 csor;
@@ -886,7 +896,8 @@ static int fsl_ifc_chip_init(struct fsl_ifc_mtd *priv)
 
 	/* fill in nand_chip structure */
 	/* set up function call table */
-	if ((ifc_in32(&ifc->cspr_cs[priv->bank].cspr)) & CSPR_PORT_SIZE_16)
+	if ((ifc_in32(&ifc_global->cspr_cs[priv->bank].cspr))
+		& CSPR_PORT_SIZE_16)
 		chip->read_byte = fsl_ifc_read_byte16;
 	else
 		chip->read_byte = fsl_ifc_read_byte;
@@ -900,13 +911,14 @@ static int fsl_ifc_chip_init(struct fsl_ifc_mtd *priv)
 	chip->bbt_td = &bbt_main_descr;
 	chip->bbt_md = &bbt_mirror_descr;
 
-	ifc_out32(0x0, &ifc->ifc_nand.ncfgr);
+	ifc_out32(0x0, &ifc_runtime->ifc_nand.ncfgr);
 
 	/* set up nand options */
 	chip->bbt_options = NAND_BBT_USE_FLASH;
 	chip->options = NAND_NO_SUBPAGE_WRITE;
 
-	if (ifc_in32(&ifc->cspr_cs[priv->bank].cspr) & CSPR_PORT_SIZE_16) {
+	if (ifc_in32(&ifc_global->cspr_cs[priv->bank].cspr)
+		& CSPR_PORT_SIZE_16) {
 		chip->read_byte = fsl_ifc_read_byte16;
 		chip->options |= NAND_BUSWIDTH_16;
 	} else {
@@ -919,7 +931,7 @@ static int fsl_ifc_chip_init(struct fsl_ifc_mtd *priv)
 	chip->ecc.read_page = fsl_ifc_read_page;
 	chip->ecc.write_page = fsl_ifc_write_page;
 
-	csor = ifc_in32(&ifc->csor_cs[priv->bank].csor);
+	csor = ifc_in32(&ifc_global->csor_cs[priv->bank].csor);
 
 	/* Hardware generates ECC per 512 Bytes */
 	chip->ecc.size = 512;
@@ -985,9 +997,12 @@ static int fsl_ifc_chip_init(struct fsl_ifc_mtd *priv)
 		chip->ecc.mode = NAND_ECC_SOFT;
 	}
 
-	if (ctrl->version == FSL_IFC_VERSION_1_1_0)
+	if (ctrl->version >= FSL_IFC_VERSION_1_1_0)
 		fsl_ifc_sram_init(priv);
 
+	if (ctrl->version >= FSL_IFC_VERSION_2_0_0)
+		priv->bufnum_mask = (priv->bufnum_mask * 2) + 1;
+
 	return 0;
 }
 
@@ -1005,10 +1020,10 @@ static int fsl_ifc_chip_remove(struct fsl_ifc_mtd *priv)
 	return 0;
 }
 
-static int match_bank(struct fsl_ifc_regs __iomem *ifc, int bank,
+static int match_bank(struct fsl_ifc_global __iomem *ifc_global, int bank,
 		      phys_addr_t addr)
 {
-	u32 cspr = ifc_in32(&ifc->cspr_cs[bank].cspr);
+	u32 cspr = ifc_in32(&ifc_global->cspr_cs[bank].cspr);
 
 	if (!(cspr & CSPR_V))
 		return 0;
@@ -1022,7 +1037,7 @@ static DEFINE_MUTEX(fsl_ifc_nand_mutex);
 
 static int fsl_ifc_nand_probe(struct platform_device *dev)
 {
-	struct fsl_ifc_regs __iomem *ifc;
+	struct fsl_ifc_runtime __iomem *ifc;
 	struct fsl_ifc_mtd *priv;
 	struct resource res;
 	static const char *part_probe_types[]
@@ -1033,9 +1048,9 @@ static int fsl_ifc_nand_probe(struct platform_device *dev)
 	struct mtd_part_parser_data ppdata;
 
 	ppdata.of_node = dev->dev.of_node;
-	if (!fsl_ifc_ctrl_dev || !fsl_ifc_ctrl_dev->regs)
+	if (!fsl_ifc_ctrl_dev || !fsl_ifc_ctrl_dev->rregs)
 		return -ENODEV;
-	ifc = fsl_ifc_ctrl_dev->regs;
+	ifc = fsl_ifc_ctrl_dev->rregs;
 
 	/* get, allocate and map the memory resource */
 	ret = of_address_to_resource(node, 0, &res);
@@ -1046,7 +1061,7 @@ static int fsl_ifc_nand_probe(struct platform_device *dev)
 
 	/* find which chip select it is connected to */
 	for (bank = 0; bank < fsl_ifc_ctrl_dev->banks; bank++) {
-		if (match_bank(ifc, bank, res.start))
+		if (match_bank(fsl_ifc_ctrl_dev->gregs, bank, res.start))
 			break;
 	}
 
diff --git a/include/linux/fsl_ifc.h b/include/linux/fsl_ifc.h
index 0023088..a41d21b 100644
--- a/include/linux/fsl_ifc.h
+++ b/include/linux/fsl_ifc.h
@@ -39,6 +39,10 @@
 #define FSL_IFC_VERSION_MASK	0x0F0F0000
 #define FSL_IFC_VERSION_1_0_0	0x01000000
 #define FSL_IFC_VERSION_1_1_0	0x01010000
+#define FSL_IFC_VERSION_2_0_0	0x02000000
+
+#define PGOFFSET_64K	(64*1024)
+#define PGOFFSET_4K	(4*1024)
 
 /*
  * CSPR - Chip Select Property Register
@@ -270,6 +274,8 @@
  */
 /* Auto Boot Mode */
 #define IFC_NAND_NCFGR_BOOT		0x80000000
+/* SRAM INIT EN */
+#define IFC_NAND_SRAM_INIT_EN		0x20000000
 /* Addressing Mode-ROW0+n/COL0 */
 #define IFC_NAND_NCFGR_ADDR_MODE_RC0	0x00000000
 /* Addressing Mode-ROW0+n/COL0+n */
@@ -723,20 +729,30 @@ struct fsl_ifc_nand {
 	__be32 nand_evter_en;
 	u32 res17[0x2];
 	__be32 nand_evter_intr_en;
-	u32 res18[0x2];
+	__be32 nand_vol_addr_stat;
+	u32 res18;
 	__be32 nand_erattr0;
 	__be32 nand_erattr1;
 	u32 res19[0x10];
 	__be32 nand_fsr;
 	u32 res20;
-	__be32 nand_eccstat[4];
-	u32 res21[0x20];
+	/* The V1 nand_eccstat is actually 4 words that overlaps the
+	 * V2 nand_eccstat.
+	 */
+	__be32 v1_nand_eccstat[2];
+	__be32 v2_nand_eccstat[6];
+	u32 res21[0x1c];
 	__be32 nanndcr;
 	u32 res22[0x2];
 	__be32 nand_autoboot_trgr;
 	u32 res23;
 	__be32 nand_mdr;
-	u32 res24[0x5C];
+	u32 res24[0x1C];
+	__be32 nand_dll_lowcfg0;
+	__be32 nand_dll_lowcfg1;
+	u32 res25;
+	__be32 nand_dll_lowstat;
+	u32 res26[0x3c];
 };
 
 /*
@@ -771,13 +787,12 @@ struct fsl_ifc_gpcm {
 	__be32 gpcm_erattr1;
 	__be32 gpcm_erattr2;
 	__be32 gpcm_stat;
-	u32 res4[0x1F3];
 };
 
 /*
  * IFC Controller Registers
  */
-struct fsl_ifc_regs {
+struct fsl_ifc_global {
 	__be32 ifc_rev;
 	u32 res1[0x2];
 	struct {
@@ -803,21 +818,26 @@ struct fsl_ifc_regs {
 	} ftim_cs[FSL_IFC_BANK_COUNT];
 	u32 res9[0x30];
 	__be32 rb_stat;
-	u32 res10[0x2];
+	__be32 rb_map;
+	__be32 wb_map;
 	__be32 ifc_gcr;
-	u32 res11[0x2];
+	u32 res10[0x2];
 	__be32 cm_evter_stat;
-	u32 res12[0x2];
+	u32 res11[0x2];
 	__be32 cm_evter_en;
-	u32 res13[0x2];
+	u32 res12[0x2];
 	__be32 cm_evter_intr_en;
-	u32 res14[0x2];
+	u32 res13[0x2];
 	__be32 cm_erattr0;
 	__be32 cm_erattr1;
-	u32 res15[0x2];
+	u32 res14[0x2];
 	__be32 ifc_ccr;
 	__be32 ifc_csr;
-	u32 res16[0x2EB];
+	__be32 ddr_ccr_low;
+};
+
+
+struct fsl_ifc_runtime {
 	struct fsl_ifc_nand ifc_nand;
 	struct fsl_ifc_nor ifc_nor;
 	struct fsl_ifc_gpcm ifc_gpcm;
@@ -831,7 +851,8 @@ extern int fsl_ifc_find(phys_addr_t addr_base);
 struct fsl_ifc_ctrl {
 	/* device info */
 	struct device			*dev;
-	struct fsl_ifc_regs __iomem	*regs;
+	struct fsl_ifc_global __iomem	*gregs;
+	struct fsl_ifc_runtime __iomem	*rregs;
 	int				irq;
 	int				nand_irq;
 	spinlock_t			lock;
@@ -842,6 +863,11 @@ struct fsl_ifc_ctrl {
 	u32 nand_stat;
 	wait_queue_head_t nand_wait;
 	bool little_endian;
+#ifdef CONFIG_PM_SLEEP
+	/*save regs when system goes to deep sleep*/
+	struct fsl_ifc_global		*saved_gregs;
+	struct fsl_ifc_runtime		*saved_rregs;
+#endif
 };
 
 extern struct fsl_ifc_ctrl *fsl_ifc_ctrl_dev;
-- 
2.7.4


From 4f19619552b78bfa13b481b5463d48847dae6d9d Mon Sep 17 00:00:00 2001
From: "Marty E. Plummer" <hanetzer@startmail.com>
Date: Mon, 30 Oct 2017 02:55:27 -0500
Subject: [PATCH 4/4] rtc: hisi: Add Hisilicon RTC driver.

This rtc is unusual as it is accessed via one 32 bit io register.

Signed-off-by: Marty E. Plummer <hanetzer@startmail.com>
---
 arch/arm/boot/dts/hi3521a.dtsi |   9 +
 drivers/rtc/Kconfig            |  11 ++
 drivers/rtc/Makefile           |   1 +
 drivers/rtc/rtc-hisi.c         | 417 +++++++++++++++++++++++++++++++++++++++++
 4 files changed, 438 insertions(+)
 create mode 100644 drivers/rtc/rtc-hisi.c

--- a/arch/arm/boot/dts/hi3521a.dtsi
+++ b/arch/arm/boot/dts/hi3521a.dtsi
@@ -158,6 +158,15 @@
 			status = "disabled";
 		};
 
+		rtc: rtc@120b0000 {
+			compatible = "hisilicon,hisi-rtc", "hisilicon,hi3521a-rtc";
+			reg = <0x120b0000 0x1000>;
+			interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+			#clock-cells = <0>;
+			clock-frequency = <32768>;
+			clock-output-names = "rtc_xin32k";
+		};
+
 		gpio0: gpio@12150000 {
 			compatible = "arm,pl061", "arm,primecell";
 			reg = <0x12150000 0x1000>;
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -275,6 +275,17 @@ config RTC_DRV_DS1672
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-ds1672.
 
+config RTC_DRV_HISI
+	tristate "Hisilicon RTC Driver"
+	depends on ARCH_HISI || COMPILE_TEST
+	help
+	  Build the rtc driver for various hisilicon chipsets.
+	  Supported chipsets include the Hi3519v100, Hi3520Dv100, and
+	  the Hi3521Av100/Hi3520Dv300
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-hisi.
+
 config RTC_DRV_HYM8563
 	tristate "Haoyu Microelectronics HYM8563"
 	depends on OF
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -69,6 +69,7 @@ obj-$(CONFIG_RTC_DRV_FM3130)	+= rtc-fm31
 obj-$(CONFIG_RTC_DRV_GEMINI)	+= rtc-gemini.o
 obj-$(CONFIG_RTC_DRV_GENERIC)	+= rtc-generic.o
 obj-$(CONFIG_RTC_DRV_HID_SENSOR_TIME) += rtc-hid-sensor-time.o
+obj-$(CONFIG_RTC_DRV_HISI)	+= rtc-hisi.o
 obj-$(CONFIG_RTC_DRV_HYM8563)	+= rtc-hym8563.o
 obj-$(CONFIG_RTC_DRV_IMXDI)	+= rtc-imxdi.o
 obj-$(CONFIG_RTC_DRV_ISL12022)	+= rtc-isl12022.o
--- /dev/null
+++ b/drivers/rtc/rtc-hisi.c
@@ -0,0 +1,417 @@
+/*
+ * Copyright (C) Marty E. Plummer <hanetzer@startmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+
+#define SPI_CLK_DIV	0x00
+#define SPI_RW		0x04
+
+#define HISI_RTC_10MS_COUNT	0x00
+#define HISI_RTC_S_COUNT	0x01
+#define HISI_RTC_M_COUNT	0x02
+#define HISI_RTC_H_COUNT	0x03
+#define HISI_RTC_D_COUNT_L	0x04
+#define HISI_RTC_D_COUNT_H	0x05
+#define HISI_RTC_MR_10MS	0x06
+#define HISI_RTC_MR_S		0x07
+#define HISI_RTC_MR_M		0x08
+#define HISI_RTC_MR_H		0x09
+#define HISI_RTC_MR_D_L		0x0a
+#define HISI_RTC_MR_D_H		0x0b
+#define HISI_RTC_LR_10MS	0x0c
+#define HISI_RTC_LR_S		0x0d
+#define HISI_RTC_LR_M		0x0e
+#define HISI_RTC_LR_H		0x0f
+#define HISI_RTC_LR_D_L		0x10
+#define HISI_RTC_LR_D_H		0x11
+#define HISI_RTC_LORD		0x12
+#define HISI_RTC_IMSC		0x13
+#define HISI_RTC_INT_CLR	0x14
+#define HISI_RTC_MSC_INT	0x15
+#define HISI_RTC_RAW_INT	0x16
+#define HISI_RTC_POR_N		0x18
+
+struct hisi_rtc_info {
+	struct platform_device	*pdev;
+	struct rtc_device	*rtc_dev;
+	void __iomem		*base;
+	struct clk		*clk;
+	int			hisi_rtc_irq;
+	spinlock_t		hisi_rtc_lock;
+};
+
+static inline u32 hisi_rtc_check_busy(struct hisi_rtc_info *info)
+{
+	return (readl(info->base + SPI_RW) >> 31) & 1;
+}
+
+static int hisi_rtc_wait_while_busy(struct device *dev)
+{
+	struct hisi_rtc_info *info = dev_get_drvdata(dev);
+
+	while(hisi_rtc_check_busy(info)) {
+		udelay(1);
+	}
+
+	return 0;
+}
+
+static inline int hisi_rtc_read(struct device *dev, int addr)
+{
+	struct hisi_rtc_info *info = dev_get_drvdata(dev);
+
+	hisi_rtc_wait_while_busy(dev);
+
+	writel((0x180 | addr) << 16, info->base + SPI_RW);
+
+	hisi_rtc_wait_while_busy(dev);
+
+	return (readl(info->base + SPI_RW) & 0xff00) >> 8;
+}
+
+static inline void hisi_rtc_write(struct device *dev, int addr, int data)
+{
+	struct hisi_rtc_info *info = dev_get_drvdata(dev);
+
+	hisi_rtc_wait_while_busy(dev);
+
+	writel(((0x100 | addr) << 16) + data, info->base);
+}
+
+static int hisi_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned long sec, second, minute, hour, dayl, dayh, day;
+	int rtc_lord;
+	/* tm->tm_sec  = hisi_rtc_read(dev, HISI_RTC_S_COUNT); */
+	/* tm->tm_min  = hisi_rtc_read(dev, HISI_RTC_M_COUNT); */
+	/* tm->tm_hour = hisi_rtc_read(dev, HISI_RTC_H_COUNT); */
+	rtc_lord = hisi_rtc_read(dev, HISI_RTC_LORD);
+	if (rtc_lord & 4)
+		hisi_rtc_write(dev, HISI_RTC_LORD, (~(1 << 2)) & rtc_lord);
+
+	while (rtc_lord & 2) {
+		rtc_lord = hisi_rtc_read(dev, HISI_RTC_LORD);
+	}
+
+	second	= hisi_rtc_read(dev, HISI_RTC_S_COUNT);
+	minute	= hisi_rtc_read(dev, HISI_RTC_M_COUNT);
+	hour	= hisi_rtc_read(dev, HISI_RTC_H_COUNT);
+	dayl	= hisi_rtc_read(dev, HISI_RTC_D_COUNT_L);
+	dayh	= hisi_rtc_read(dev, HISI_RTC_D_COUNT_H);
+
+	day = (dayl | (dayh << 8));
+
+	sec = second + minute * 60 + hour * 60 * 60 + day * 24 * 60 * 60;
+
+	rtc_time_to_tm(sec, tm);
+
+	dev_vdbg(dev, "time read as %lu. %d/%d/%d %d:%02u:%02u\n",
+		 sec,
+		 tm->tm_mon + 1,
+		 tm->tm_mday,
+		 tm->tm_year + 1900,
+		 tm->tm_hour,
+		 tm->tm_min,
+		 tm->tm_sec
+	);
+
+	return 0;
+}
+
+static int hisi_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned long sec;
+	int days, ret;
+	int retries = 100;
+	int rtc_lord;
+
+	while (hisi_rtc_read(dev, HISI_RTC_LORD) & 1) {
+		if (!retries--)
+			goto retry_failed;
+	}
+
+	rtc_lord = hisi_rtc_read(dev, HISI_RTC_LORD);
+
+	ret = rtc_valid_tm(tm);
+	if (ret)
+		return ret;
+
+	rtc_tm_to_time(tm, &sec);
+	days = sec / (60 * 60 * 24);
+
+	dev_vdbg(dev, "time set to %lu. %d/%d/%d %d:%02u:%02u\n",
+		 sec,
+		 tm->tm_mon + 1,
+		 tm->tm_mday,
+		 tm->tm_year + 1900,
+		 tm->tm_hour,
+		 tm->tm_min,
+		 tm->tm_sec
+	);
+
+	hisi_rtc_write(dev, HISI_RTC_LR_10MS, 0);
+	hisi_rtc_write(dev, HISI_RTC_LR_S, tm->tm_sec);
+	hisi_rtc_write(dev, HISI_RTC_LR_M, tm->tm_min);
+	hisi_rtc_write(dev, HISI_RTC_LR_H, tm->tm_hour);
+	hisi_rtc_write(dev, HISI_RTC_LR_D_L, (days & 0xff));
+	hisi_rtc_write(dev, HISI_RTC_LR_D_H, (days >> 8));
+
+	hisi_rtc_write(dev, HISI_RTC_LORD, rtc_lord | 1);
+	return 0;
+
+retry_failed:
+	dev_err(dev, "write failed: retry count exceeded.\n");
+	return -ETIMEDOUT;
+}
+
+static int hisi_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
+{
+	unsigned long sec, second, minute, hour, dayl, dayh, day, tmp;
+
+	second	= hisi_rtc_read(dev, HISI_RTC_MR_S);
+	minute	= hisi_rtc_read(dev, HISI_RTC_MR_M);
+	hour	= hisi_rtc_read(dev, HISI_RTC_MR_H);
+	dayl	= hisi_rtc_read(dev, HISI_RTC_MR_D_L);
+	dayh	= hisi_rtc_read(dev, HISI_RTC_MR_D_H);
+
+	day = (dayl | (dayh << 8));
+
+	sec = second + minute * 60 + hour * 60 * 60 + day * 24 * 60 * 60;
+
+	if ((hisi_rtc_read(dev, HISI_RTC_IMSC) & 1) == 0) {
+		/* alarm is disabled */
+		alarm->enabled = 0;
+	} else {
+		alarm->enabled = 1;
+		rtc_time_to_tm(sec, &alarm->time);
+	}
+
+	tmp = hisi_rtc_read(dev, HISI_RTC_RAW_INT);
+	alarm->pending = (tmp & 1) != 0;
+
+	return 0;
+}
+
+static int hisi_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)
+{
+	struct hisi_rtc_info *info = dev_get_drvdata(dev);
+	unsigned status;
+	unsigned long sl_irq_flags;
+
+	hisi_rtc_wait_while_busy(dev);
+	spin_lock_irqsave(&info->hisi_rtc_lock, sl_irq_flags);
+
+	status = hisi_rtc_read(dev, HISI_RTC_IMSC);
+	if (enabled)
+		status |= 1;
+	else
+		status &= 1;
+
+	hisi_rtc_write(dev, HISI_RTC_IMSC, status);
+
+	spin_unlock_irqrestore(&info->hisi_rtc_lock, sl_irq_flags);
+
+	return 0;
+}
+
+static int hisi_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
+{
+	struct hisi_rtc_info *info = dev_get_drvdata(dev);
+	unsigned long sec, days;
+
+	if (alarm->enabled)
+		rtc_tm_to_time(&alarm->time, &sec);
+	else
+		sec = 0;
+
+	days = sec / (60 * 60 * 24);
+
+	hisi_rtc_write(dev, HISI_RTC_MR_10MS, 0);
+	hisi_rtc_write(dev, HISI_RTC_MR_S, alarm->time.tm_sec);
+	hisi_rtc_write(dev, HISI_RTC_MR_M, alarm->time.tm_min);
+	hisi_rtc_write(dev, HISI_RTC_MR_H, alarm->time.tm_hour);
+	hisi_rtc_write(dev, HISI_RTC_MR_D_L, (days && 0xff));
+	hisi_rtc_write(dev, HISI_RTC_MR_D_H, (days >> 8));
+
+	if (sec) {
+		hisi_rtc_alarm_irq_enable(dev, 1);
+
+		dev_vdbg(dev, "alarm set as %lu. %d/%d/%d %d:%02u:%02u\n",
+			 sec,
+			 alarm->time.tm_mon + 1,
+			 alarm->time.tm_mday,
+			 alarm->time.tm_year + 1900,
+			 alarm->time.tm_hour,
+			 alarm->time.tm_min,
+			 alarm->time.tm_sec);
+	} else {
+		dev_vdbg(dev, "alarm disabled\n");
+		hisi_rtc_alarm_irq_enable(dev, 0);
+	}
+
+	return 0;
+}
+
+static int hisi_rtc_proc(struct device *dev, struct seq_file *seq)
+{
+	if (!dev || !dev->driver)
+		return 0;
+
+	seq_printf(seq, "name\t\t: %s\n", dev_name(dev));
+
+	return 0;
+
+}
+
+static irqreturn_t hisi_rtc_irq_handler(int irq, void *data)
+{
+	struct device *dev = data;
+	struct hisi_rtc_info *info = dev_get_drvdata(dev);
+	unsigned long events = 0;
+	unsigned status;
+	unsigned long sl_irq_flags;
+
+	status = hisi_rtc_read(dev, HISI_RTC_MSC_INT);
+	if (status) {
+		spin_lock_irqsave(&info->hisi_rtc_lock, sl_irq_flags);
+		hisi_rtc_write(dev, HISI_RTC_INT_CLR, 1);
+		spin_unlock_irqrestore(&info->hisi_rtc_lock, sl_irq_flags);
+	}
+
+	if ((status & 1))
+		events |= RTC_IRQF | RTC_AF;
+
+	rtc_update_irq(info->rtc_dev, 1, events);
+
+	return IRQ_HANDLED;
+}
+
+static const struct rtc_class_ops hisi_rtc_ops = {
+	.read_time	= hisi_rtc_read_time,
+	.set_time	= hisi_rtc_set_time,
+	.read_alarm	= hisi_rtc_read_alarm,
+	.set_alarm	= hisi_rtc_set_alarm,
+	.proc		= hisi_rtc_proc,
+	.alarm_irq_enable = hisi_rtc_alarm_irq_enable,
+};
+
+static const struct of_device_id hisi_rtc_dt_match[] = {
+	{ .compatible = "hisilicon,hisi-rtc", },
+	{ .compatible = "hisilicon,hi3521a-rtc", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, hisi_rtc_dt_match);
+
+static int __init hisi_rtc_probe(struct platform_device *pdev)
+{
+	struct hisi_rtc_info *info;
+	struct resource *res;
+	int ret;
+
+	info = devm_kzalloc(&pdev->dev, sizeof(struct hisi_rtc_info),
+			    GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	info->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(info->base))
+		return PTR_ERR(info->base);
+
+	info->hisi_rtc_irq = platform_get_irq(pdev, 0);
+	if (info->hisi_rtc_irq <= 0)
+		return -EBUSY;
+
+	info->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(info->clk))
+		return PTR_ERR(info->clk);
+
+	ret = clk_prepare_enable(info->clk);
+	if (ret < 0)
+		return ret;
+
+	info->pdev = pdev;
+	spin_lock_init(&info->hisi_rtc_lock);
+
+	platform_set_drvdata(pdev, info);
+
+	hisi_rtc_write(&pdev->dev, HISI_RTC_POR_N, 0);
+	msleep(30);
+
+	device_init_wakeup(&pdev->dev, 1);
+
+	info->rtc_dev = devm_rtc_device_register(&pdev->dev,
+				dev_name(&pdev->dev), &hisi_rtc_ops,
+				THIS_MODULE);
+	if (IS_ERR(info->rtc_dev)) {
+		ret = PTR_ERR(info->rtc_dev);
+		dev_err(&pdev->dev, "Unable to register device (err=%d).\n",
+			ret);
+		goto disable_clk;
+	}
+
+	ret = devm_request_irq(&pdev->dev, info->hisi_rtc_irq,
+			hisi_rtc_irq_handler, IRQF_TRIGGER_HIGH,
+			dev_name(&pdev->dev), &pdev->dev);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"Unable to request interrupt for device (err=%d).\n",
+			ret);
+		goto disable_clk;
+	}
+
+	dev_notice(&pdev->dev, "Hi3521a internal Real Time Clock\n");
+
+	return 0;
+
+disable_clk:
+	clk_disable_unprepare(info->clk);
+	return ret;
+}
+
+static int hisi_rtc_remove(struct platform_device *pdev)
+{
+	struct hisi_rtc_info *info = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(info->clk);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int hisi_rtc_suspend(struct device *dev) {}
+static int hisi_rtc_resume(struct device *dev) {}
+#endif
+
+static SIMPLE_DEV_PM_OPS(hisi_rtc_pm_ops, hisi_rtc_suspend, hisi_rtc_resume);
+
+static void hisi_rtc_shutdown(struct platform_device *pdev)
+{
+	dev_vdbg(&pdev->dev, "disabling interrupts.\n");
+	hisi_rtc_alarm_irq_enable(&pdev->dev, 0);
+}
+
+MODULE_ALIAS("platform:hisi_rtc");
+static struct platform_driver hisi_rtc_driver = {
+	.remove		= hisi_rtc_remove,
+	.shutdown	= hisi_rtc_shutdown,
+	.driver		= {
+		.name	= "hisi_rtc",
+		.of_match_table = hisi_rtc_dt_match,
+		.pm	= &hisi_rtc_pm_ops,
+	},
+};
+
+module_platform_driver_probe(hisi_rtc_driver, hisi_rtc_probe);
+
+MODULE_AUTHOR("Marty E. Plummer <hanetzer@startmail.com>");
+MODULE_DESCRIPTION("driver for the Hisilicon internal RTC");
+MODULE_LICENSE("GPL v2");

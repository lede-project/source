From: Russell King <rmk+kernel@armlinux.org.uk>
Date: Sat, 24 Dec 2016 10:27:08 +0000
Subject: [PATCH] net: mvneta: disable MVNETA_CAUSE_PSC_SYNC_CHANGE
 interrupt

The PSC sync change interrupt can fire multiple times while the link is
down.  As this isn't information we make use of, it's pointless having
the interrupt enabled, so let's disable this interrupt.

Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
---

--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -2629,9 +2629,11 @@ static int mvneta_poll(struct napi_struc
 		mvreg_write(pp, MVNETA_INTR_MISC_CAUSE, 0);
 
 		if (cause_misc & (MVNETA_CAUSE_PHY_STATUS_CHANGE |
-				  MVNETA_CAUSE_LINK_CHANGE |
-				  MVNETA_CAUSE_PSC_SYNC_CHANGE))
+				  MVNETA_CAUSE_LINK_CHANGE)) {
+			printk(KERN_DEBUG "%s: cause 0x%08x:0x%08x\n",
+				__func__, cause_rx_tx, cause_misc);
 			mvneta_link_change(pp);
+		}
 	}
 
 	/* Release Tx descriptors */
@@ -2948,8 +2950,7 @@ static void mvneta_start_dev(struct mvne
 
 	mvreg_write(pp, MVNETA_INTR_MISC_MASK,
 		    MVNETA_CAUSE_PHY_STATUS_CHANGE |
-		    MVNETA_CAUSE_LINK_CHANGE |
-		    MVNETA_CAUSE_PSC_SYNC_CHANGE);
+		    MVNETA_CAUSE_LINK_CHANGE);
 
 	phylink_start(pp->phylink);
 	netif_tx_start_all_queues(pp->dev);
@@ -3440,8 +3441,7 @@ static int mvneta_cpu_online(unsigned in
 	on_each_cpu(mvneta_percpu_unmask_interrupt, pp, true);
 	mvreg_write(pp, MVNETA_INTR_MISC_MASK,
 		    MVNETA_CAUSE_PHY_STATUS_CHANGE |
-		    MVNETA_CAUSE_LINK_CHANGE |
-		    MVNETA_CAUSE_PSC_SYNC_CHANGE);
+		    MVNETA_CAUSE_LINK_CHANGE);
 	netif_tx_start_all_queues(pp->dev);
 	spin_unlock(&pp->lock);
 	return 0;
@@ -3482,8 +3482,7 @@ static int mvneta_cpu_dead(unsigned int
 	on_each_cpu(mvneta_percpu_unmask_interrupt, pp, true);
 	mvreg_write(pp, MVNETA_INTR_MISC_MASK,
 		    MVNETA_CAUSE_PHY_STATUS_CHANGE |
-		    MVNETA_CAUSE_LINK_CHANGE |
-		    MVNETA_CAUSE_PSC_SYNC_CHANGE);
+		    MVNETA_CAUSE_LINK_CHANGE);
 	netif_tx_start_all_queues(pp->dev);
 	return 0;
 }

From 487b9b2e5c767ee2110cce57539f0ebeb5a74872 Mon Sep 17 00:00:00 2001
From: Prabhakar Kushwaha <prabhakar.kushwaha@nxp.com>
Date: Tue, 24 May 2016 14:05:18 +0530
Subject: [PATCH 41/93] DNCPE-4: LS1012A PPFE driver

[context adjustment]

- Ported PFE driver from LS1024
- Did changes for GEMAC/MDIO/PHY
- LS1012A address translation changes
- Added pfe command  to the U-boot.
- Added gemac_stat command
- Added config PFE_START to conditionally start pfe on bootup time.
- Change Rx packet ack model
- Class firmware changes to ignore Rx error status

- SCFG changes for pfe
- Configure CCI-400 QoS settings
- Configure transaction attributes
- Configure RGMII port config

Testing status on board

RGMII - Works fine, can download file through tftp.
SGMII - CRC errors are seen, but basic rx/tx works.

Signed-off-by: Anjaneyulu Jagarlmudi <anji.jagarlmudi@nxp.com>>
Signed-off-by: Prabhakar Kushwaha <prabhakar.kushwaha@nxp.com>
Integrated-by: Jiang Yutang <yutang.jiang@nxp.com>
---
 arch/arm/cpu/armv8/fsl-layerscape/cpu.c            |    5 +
 .../include/asm/arch-fsl-layerscape/immap_lsch2.h  |   42 +-
 board/freescale/ls1012aqds/Makefile                |    1 +
 board/freescale/ls1012aqds/eth.c                   |  199 +++
 board/freescale/ls1012aqds/ls1012aqds.c            |    5 -
 board/freescale/ls1012aqds/ls1012aqds.h            |  149 ++
 board/freescale/ls1012aqds/ls1012aqds_qixis.h      |    2 +-
 board/freescale/ls1012ardb/Makefile                |    1 +
 board/freescale/ls1012ardb/eth.c                   |   68 +
 board/freescale/ls1012ardb/ls1012ardb.c            |    4 -
 common/Makefile                                    |    2 +
 common/cmd_gemac_stat.c                            |  147 ++
 common/cmd_pfe_commands.c                          |  983 ++++++++++++
 drivers/net/Makefile                               |    1 +
 drivers/net/pfe_eth/Makefile                       |    1 +
 drivers/net/pfe_eth/class_sbl_elf.fw               |    1 +
 drivers/net/pfe_eth/hal.h                          |   64 +
 drivers/net/pfe_eth/pfe.c                          | 1677 ++++++++++++++++++++
 drivers/net/pfe_eth/pfe/cbus.h                     |   74 +
 drivers/net/pfe_eth/pfe/cbus/bmu.h                 |   37 +
 drivers/net/pfe_eth/pfe/cbus/class_csr.h           |  206 +++
 drivers/net/pfe_eth/pfe/cbus/emac.h                |  232 +++
 drivers/net/pfe_eth/pfe/cbus/gpi.h                 |   60 +
 drivers/net/pfe_eth/pfe/cbus/gpt.h                 |   11 +
 drivers/net/pfe_eth/pfe/cbus/hif.h                 |   62 +
 drivers/net/pfe_eth/pfe/cbus/hif_nocpy.h           |   33 +
 drivers/net/pfe_eth/pfe/cbus/tmu_csr.h             |  102 ++
 drivers/net/pfe_eth/pfe/cbus/util_csr.h            |   43 +
 drivers/net/pfe_eth/pfe/class.h                    |  142 ++
 drivers/net/pfe_eth/pfe/class/ccu.h                |   10 +
 drivers/net/pfe_eth/pfe/class/efet.h               |   21 +
 drivers/net/pfe_eth/pfe/class/mac_hash.h           |   28 +
 drivers/net/pfe_eth/pfe/class/perg.h               |   21 +
 drivers/net/pfe_eth/pfe/class/vlan_hash.h          |   28 +
 drivers/net/pfe_eth/pfe/gpt.h                      |   11 +
 drivers/net/pfe_eth/pfe/pe.h                       |  147 ++
 drivers/net/pfe_eth/pfe/pfe.h                      |  250 +++
 drivers/net/pfe_eth/pfe/tmu.h                      |   48 +
 drivers/net/pfe_eth/pfe/tmu/phy_queue.h            |   31 +
 drivers/net/pfe_eth/pfe/tmu/sched.h                |   47 +
 drivers/net/pfe_eth/pfe/tmu/shaper.h               |   19 +
 drivers/net/pfe_eth/pfe/uart.h                     |   13 +
 drivers/net/pfe_eth/pfe/util.h                     |   30 +
 drivers/net/pfe_eth/pfe/util/eape.h                |   10 +
 drivers/net/pfe_eth/pfe/util/efet.h                |   20 +
 drivers/net/pfe_eth/pfe/util/inq.h                 |   10 +
 drivers/net/pfe_eth/pfe_driver.c                   |  710 +++++++++
 drivers/net/pfe_eth/pfe_driver.h                   |  141 ++
 drivers/net/pfe_eth/pfe_eth.c                      |  521 ++++++
 drivers/net/pfe_eth/pfe_eth.h                      |  161 ++
 drivers/net/pfe_eth/pfe_firmware.c                 |  193 +++
 drivers/net/pfe_eth/pfe_firmware.h                 |   20 +
 drivers/net/pfe_eth/pfe_mod.h                      |  140 ++
 drivers/net/pfe_eth/tmu_sbl_elf.fw                 |    1 +
 drivers/net/pfe_eth/util_sbl_elf.fw                |    1 +
 include/configs/ls1012a_common.h                   |   10 +
 include/configs/ls1012aqds.h                       |   13 +-
 include/configs/ls1012ardb.h                       |    6 +-
 58 files changed, 6994 insertions(+), 21 deletions(-)
 create mode 100644 board/freescale/ls1012aqds/eth.c
 create mode 100644 board/freescale/ls1012aqds/ls1012aqds.h
 create mode 100644 board/freescale/ls1012ardb/eth.c
 create mode 100644 common/cmd_gemac_stat.c
 create mode 100644 common/cmd_pfe_commands.c
 create mode 100644 drivers/net/pfe_eth/Makefile
 create mode 100644 drivers/net/pfe_eth/class_sbl_elf.fw
 create mode 100644 drivers/net/pfe_eth/hal.h
 create mode 100644 drivers/net/pfe_eth/pfe.c
 create mode 100644 drivers/net/pfe_eth/pfe/cbus.h
 create mode 100644 drivers/net/pfe_eth/pfe/cbus/bmu.h
 create mode 100644 drivers/net/pfe_eth/pfe/cbus/class_csr.h
 create mode 100644 drivers/net/pfe_eth/pfe/cbus/emac.h
 create mode 100644 drivers/net/pfe_eth/pfe/cbus/gpi.h
 create mode 100644 drivers/net/pfe_eth/pfe/cbus/gpt.h
 create mode 100644 drivers/net/pfe_eth/pfe/cbus/hif.h
 create mode 100644 drivers/net/pfe_eth/pfe/cbus/hif_nocpy.h
 create mode 100644 drivers/net/pfe_eth/pfe/cbus/tmu_csr.h
 create mode 100644 drivers/net/pfe_eth/pfe/cbus/util_csr.h
 create mode 100644 drivers/net/pfe_eth/pfe/class.h
 create mode 100644 drivers/net/pfe_eth/pfe/class/ccu.h
 create mode 100644 drivers/net/pfe_eth/pfe/class/efet.h
 create mode 100644 drivers/net/pfe_eth/pfe/class/mac_hash.h
 create mode 100644 drivers/net/pfe_eth/pfe/class/perg.h
 create mode 100644 drivers/net/pfe_eth/pfe/class/vlan_hash.h
 create mode 100644 drivers/net/pfe_eth/pfe/gpt.h
 create mode 100644 drivers/net/pfe_eth/pfe/pe.h
 create mode 100644 drivers/net/pfe_eth/pfe/pfe.h
 create mode 100644 drivers/net/pfe_eth/pfe/tmu.h
 create mode 100644 drivers/net/pfe_eth/pfe/tmu/phy_queue.h
 create mode 100644 drivers/net/pfe_eth/pfe/tmu/sched.h
 create mode 100644 drivers/net/pfe_eth/pfe/tmu/shaper.h
 create mode 100644 drivers/net/pfe_eth/pfe/uart.h
 create mode 100644 drivers/net/pfe_eth/pfe/util.h
 create mode 100644 drivers/net/pfe_eth/pfe/util/eape.h
 create mode 100644 drivers/net/pfe_eth/pfe/util/efet.h
 create mode 100644 drivers/net/pfe_eth/pfe/util/inq.h
 create mode 100644 drivers/net/pfe_eth/pfe_driver.c
 create mode 100644 drivers/net/pfe_eth/pfe_driver.h
 create mode 100644 drivers/net/pfe_eth/pfe_eth.c
 create mode 100644 drivers/net/pfe_eth/pfe_eth.h
 create mode 100644 drivers/net/pfe_eth/pfe_firmware.c
 create mode 100644 drivers/net/pfe_eth/pfe_firmware.h
 create mode 100644 drivers/net/pfe_eth/pfe_mod.h
 create mode 100644 drivers/net/pfe_eth/tmu_sbl_elf.fw
 create mode 100644 drivers/net/pfe_eth/util_sbl_elf.fw

diff --git a/arch/arm/cpu/armv8/fsl-layerscape/cpu.c b/arch/arm/cpu/armv8/fsl-layerscape/cpu.c
index 340d9f9..8f59577 100644
--- a/arch/arm/cpu/armv8/fsl-layerscape/cpu.c
+++ b/arch/arm/cpu/armv8/fsl-layerscape/cpu.c
@@ -573,6 +573,11 @@ int cpu_eth_init(bd_t *bis)
 {
 	int error = 0;
 
+#if defined(CONFIG_FSL_PPFE) && !defined(CONFIG_CMD_PFE_START)
+	ls1012a_gemac_initialize(bis, 0 , "pfe_eth0");
+	ls1012a_gemac_initialize(bis, 1 , "pfe_eth1");
+#endif
+
 #ifdef CONFIG_FSL_MC_ENET
 	error = fsl_mc_ldpaa_init(bis);
 #endif
diff --git a/arch/arm/include/asm/arch-fsl-layerscape/immap_lsch2.h b/arch/arm/include/asm/arch-fsl-layerscape/immap_lsch2.h
index 6918757..a264f9a 100644
--- a/arch/arm/include/asm/arch-fsl-layerscape/immap_lsch2.h
+++ b/arch/arm/include/asm/arch-fsl-layerscape/immap_lsch2.h
@@ -41,6 +41,7 @@
 #define CONFIG_SYS_PCIE1_ADDR			(CONFIG_SYS_IMMR + 0x2400000)
 #define CONFIG_SYS_PCIE2_ADDR			(CONFIG_SYS_IMMR + 0x2500000)
 #define CONFIG_SYS_PCIE3_ADDR			(CONFIG_SYS_IMMR + 0x2600000)
+#define CONFIG_SYS_PPFE_ADDR			(CONFIG_SYS_IMMR + 0x3000000)
 #define CONFIG_SYS_SEC_MON_ADDR			(CONFIG_SYS_IMMR + 0xe90000)
 #define CONFIG_SYS_SFP_ADDR			(CONFIG_SYS_IMMR + 0xe80200)
 
@@ -364,6 +365,24 @@ struct ccsr_gur {
 #define SCFG_SNPCNFGCR_USB3RDSNP	0x00002000
 #define SCFG_SNPCNFGCR_USB3WRSNP	0x00004000
 
+/* RGMIIPCR bit definitions*/
+#define SCFG_RGMIIPCR_EN_AUTO		(0x00000008)
+#define SCFG_RGMIIPCR_SETSP_1000M	(0x00000004)
+#define SCFG_RGMIIPCR_SETSP_100M	(0x00000000)
+#define SCFG_RGMIIPCR_SETSP_10M		(0x00000002)
+#define SCFG_RGMIIPCR_SETFD		(0x00000001)
+
+/*PFEASBCR bit definitions */
+#define SCFG_PPFEASBCR_ARCACHE0		(0x80000000)
+#define SCFG_PPFEASBCR_AWCACHE0		(0x40000000)
+#define SCFG_PPFEASBCR_ARCACHE1		(0x20000000)
+#define SCFG_PPFEASBCR_AWCACHE1		(0x10000000)
+#define SCFG_PPFEASBCR_ARSNP		(0x08000000)
+#define SCFG_PPFEASBCR_AWSNP		(0x04000000)
+
+
+
+
 /* Supplemental Configuration Unit */
 struct ccsr_scfg {
 	u8 res_000[0x100-0x000];
@@ -381,7 +400,12 @@ struct ccsr_scfg {
 	u8 res_140[0x158-0x140];
 	u32 altcbar;
 	u32 qspi_cfg;
-	u8 res_160[0x180-0x160];
+	u8 res_160[0x164-0x160];
+	u32 wr_qos1;
+	u32 wr_qos2;
+	u32 rd_qos1;
+	u32 rd_qos2;
+	u8 res_174[0x180-0x174];
 	u32 dmamcr;
 	u8 res_184[0x18c-0x184];
 	u32 debug_icid;
@@ -411,7 +435,21 @@ struct ccsr_scfg {
 	u32 usb_refclk_selcr1;
 	u32 usb_refclk_selcr2;
 	u32 usb_refclk_selcr3;
-	u8 res_424[0x600-0x424];
+	u8 res_424[0x434-0x424];
+	u32 rgmiipcr;
+	u32 res_438;
+	u32 rgmiipsr;
+	u32 pfepfcssr1;
+	u32 pfeintencr1;
+	u32 pfepfcssr2;
+	u32 pfeintencr2;
+	u32 pfeerrcr;
+	u32 pfeeerrintencr;
+	u32 pfeasbcr;
+	u32 pfebsbcr;
+	u8 res_460[0x484-0x460];
+	u32 mdioselcr;
+	u8 res_468[0x600-0x468];
 	u32 scratchrw[4];
 	u8 res_610[0x680-0x610];
 	u32 corebcr;
diff --git a/board/freescale/ls1012aqds/Makefile b/board/freescale/ls1012aqds/Makefile
index 0b813f9..b18494a 100644
--- a/board/freescale/ls1012aqds/Makefile
+++ b/board/freescale/ls1012aqds/Makefile
@@ -5,3 +5,4 @@
 #
 
 obj-y += ls1012aqds.o
+obj-y += eth.o
diff --git a/board/freescale/ls1012aqds/eth.c b/board/freescale/ls1012aqds/eth.c
new file mode 100644
index 0000000..1bd7c9d
--- /dev/null
+++ b/board/freescale/ls1012aqds/eth.c
@@ -0,0 +1,199 @@
+/*
+ * Copyright 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <netdev.h>
+#include <fm_eth.h>
+#include <fsl_mdio.h>
+#include <malloc.h>
+#include <fsl_dtsec.h>
+#include <asm/arch/soc.h>
+#include <asm/arch-fsl-layerscape/config.h>
+#include <asm/arch/fsl_serdes.h>
+
+#include "../common/qixis.h"
+#include "../../../drivers/net/pfe_eth/pfe_eth.h"
+#include "ls1012aqds_qixis.h"
+#include <asm/arch-fsl-layerscape/immap_lsch2.h>
+
+#define EMI_NONE	0xFF
+#define EMI1_RGMII	1
+#define EMI1_SLOT1	2
+#define EMI1_SLOT2	3
+
+#define DEFAULT_PFE_MDIO_NAME "PFE_MDIO"
+
+static int mdio_mux[NUM_FM_PORTS];
+
+static const char * const mdio_names[] = {
+	"NULL",
+	"LS1012AQDS_MDIO_RGMII",
+	"LS1012AQDS_MDIO_SLOT1",
+	"LS1012AQDS_MDIO_SLOT2",
+	"NULL",
+};
+
+static const char *ls1012aqds_mdio_name_for_muxval(u8 muxval)
+{
+	return mdio_names[muxval];
+}
+
+struct ls1012aqds_mdio {
+	u8 muxval;
+	struct mii_dev *realbus;
+};
+
+static void ls1012aqds_mux_mdio(u8 muxval)
+{
+	u8 brdcfg4;
+
+	if (muxval < 7) {
+		brdcfg4 = QIXIS_READ(brdcfg[4]);
+		brdcfg4 &= ~BRDCFG4_EMISEL_MASK;
+		brdcfg4 |= (muxval << BRDCFG4_EMISEL_SHIFT);
+		QIXIS_WRITE(brdcfg[4], brdcfg4);
+	}
+}
+
+static int ls1012aqds_mdio_read(struct mii_dev *bus, int addr, int devad,
+			      int regnum)
+{
+	struct ls1012aqds_mdio *priv = bus->priv;
+
+	ls1012aqds_mux_mdio(priv->muxval);
+
+	return priv->realbus->read(priv->realbus, addr, devad, regnum);
+}
+
+static int ls1012aqds_mdio_write(struct mii_dev *bus, int addr, int devad,
+			       int regnum, u16 value)
+{
+	struct ls1012aqds_mdio *priv = bus->priv;
+
+	ls1012aqds_mux_mdio(priv->muxval);
+
+	return priv->realbus->write(priv->realbus, addr, devad, regnum, value);
+}
+
+static int ls1012aqds_mdio_reset(struct mii_dev *bus)
+{
+	struct ls1012aqds_mdio *priv = bus->priv;
+
+	if(priv->realbus->reset)
+		return priv->realbus->reset(priv->realbus);
+}
+
+static int ls1012aqds_mdio_init(char *realbusname, u8 muxval)
+{
+	struct ls1012aqds_mdio *pmdio;
+	struct mii_dev *bus = mdio_alloc();
+
+	if (!bus) {
+		printf("Failed to allocate ls1012aqds MDIO bus\n");
+		return -1;
+	}
+
+	pmdio = malloc(sizeof(*pmdio));
+	if (!pmdio) {
+		printf("Failed to allocate ls1012aqds private data\n");
+		free(bus);
+		return -1;
+	}
+
+	bus->read = ls1012aqds_mdio_read;
+	bus->write = ls1012aqds_mdio_write;
+	bus->reset = ls1012aqds_mdio_reset;
+	sprintf(bus->name, ls1012aqds_mdio_name_for_muxval(muxval));
+
+	pmdio->realbus = miiphy_get_dev_by_name(realbusname);
+
+	if (!pmdio->realbus) {
+		printf("No bus with name %s\n", realbusname);
+		free(bus);
+		free(pmdio);
+		return -1;
+	}
+
+	pmdio->muxval = muxval;
+	bus->priv = pmdio;
+	return mdio_register(bus);
+}
+
+int board_eth_init(bd_t *bis)
+{
+#ifdef CONFIG_FSL_PPFE
+        struct mii_dev *bus;
+	struct mdio_info mac1_mdio_info;
+	struct ccsr_scfg *scfg = (struct ccsr_scfg *)CONFIG_SYS_FSL_SCFG_ADDR;
+	u8 data8;
+
+
+	/*TODO Following config should be done for all boards, where is the right place to put this */
+	out_be32(&scfg->pfeasbcr, in_be32(&scfg->pfeasbcr) | SCFG_PPFEASBCR_AWCACHE0);
+	out_be32(&scfg->pfebsbcr, in_be32(&scfg->pfebsbcr) | SCFG_PPFEASBCR_AWCACHE0);
+
+	/*CCI-400 QoS settings for PFE */
+	out_be32(&scfg->wr_qos1, 0x0ff00000);
+	out_be32(&scfg->rd_qos1, 0x0ff00000);
+
+	/* Set RGMII into 1G + Full duplex mode */
+	out_be32(&scfg->rgmiipcr, in_be32(&scfg->rgmiipcr) | (SCFG_RGMIIPCR_SETSP_1000M | SCFG_RGMIIPCR_SETFD));
+
+	out_be32((CONFIG_SYS_DCSR_DCFG_ADDR + 0x520), 0xFFFFFFFF);
+	out_be32((CONFIG_SYS_DCSR_DCFG_ADDR + 0x524), 0xFFFFFFFF);
+
+	ls1012aqds_mux_mdio(2);
+
+#ifdef RGMII_RESET_WA
+	/* Work around for FPGA registers initialization
+	 * This is needed for RGMII to work */
+	printf("Reset RGMII WA....\n");
+	data8 = QIXIS_READ(rst_frc[0]);
+	data8 |= 0x2;
+	QIXIS_WRITE(rst_frc[0], data8);
+	data8 = QIXIS_READ(rst_frc[0]);
+
+	data8 = QIXIS_READ(res8[6]);
+	data8 |= 0xff;
+	QIXIS_WRITE(res8[6], data8);
+	data8 = QIXIS_READ(res8[6]);
+
+#endif
+
+	mac1_mdio_info.reg_base = (void *)0x04200000; /*EMAC1_BASE_ADDR*/
+	mac1_mdio_info.name = DEFAULT_PFE_MDIO_NAME;
+
+	bus = ls1012a_mdio_init(&mac1_mdio_info);
+	if(!bus)
+	{
+		printf("Failed to register mdio \n");
+		return -1;
+	}
+
+	/*Based on RCW config initialize correctly */
+	/*MAC2 */
+	if(ls1012aqds_mdio_init(DEFAULT_PFE_MDIO_NAME, EMI1_RGMII) < 0)
+	{
+		printf("Failed to register mdio for %s\n", ls1012aqds_mdio_name_for_muxval(EMI1_RGMII));
+		return -1;
+	}
+	ls1012a_set_mdio(1, miiphy_get_dev_by_name(ls1012aqds_mdio_name_for_muxval(EMI1_RGMII)));
+	ls1012a_set_phy_address_mode(1,  EMAC2_PHY_ADDR, PHY_INTERFACE_MODE_RGMII);
+
+	/*MAC1 */
+	if(ls1012aqds_mdio_init(DEFAULT_PFE_MDIO_NAME, EMI1_SLOT1) < 0)
+	{
+		printf("Failed to register mdio for %s\n", ls1012aqds_mdio_name_for_muxval(EMI1_SLOT1));
+		return -1;
+	}
+	ls1012a_set_mdio(0, miiphy_get_dev_by_name(ls1012aqds_mdio_name_for_muxval(EMI1_SLOT1)));
+	ls1012a_set_phy_address_mode(0,  EMAC1_PHY_ADDR, PHY_INTERFACE_MODE_SGMII);
+
+	cpu_eth_init(bis);
+#endif
+	return pci_eth_init(bis);
+}
diff --git a/board/freescale/ls1012aqds/ls1012aqds.c b/board/freescale/ls1012aqds/ls1012aqds.c
index 446989b..b7365e8 100644
--- a/board/freescale/ls1012aqds/ls1012aqds.c
+++ b/board/freescale/ls1012aqds/ls1012aqds.c
@@ -211,11 +211,6 @@ int board_init(void)
 	return 0;
 }
 
-int board_eth_init(bd_t *bis)
-{
-	return pci_eth_init(bis);
-}
-
 #ifdef CONFIG_OF_BOARD_SETUP
 int ft_board_setup(void *blob, bd_t *bd)
 {
diff --git a/board/freescale/ls1012aqds/ls1012aqds.h b/board/freescale/ls1012aqds/ls1012aqds.h
new file mode 100644
index 0000000..42e10f5
--- /dev/null
+++ b/board/freescale/ls1012aqds/ls1012aqds.h
@@ -0,0 +1,149 @@
+/*
+ * Copyright 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __LS1012AQDS_H__
+#define __LS1012AQDS_H__
+
+#include "ls1012a_common.h"
+
+
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	1
+#define CONFIG_NR_DRAM_BANKS		2
+
+#ifdef CONFIG_FSL_PPFE
+/*#define CONFIG_CMD_PFE_START */
+#define EMAC1_PHY_ADDR          0x1e
+#define EMAC2_PHY_ADDR          0x1
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_VITESSE
+#define CONFIG_PHY_REALTEK
+#endif
+
+#define CONFIG_QIXIS_I2C_ACCESS
+#define CONFIG_SYS_I2C_FPGA_ADDR	0x66
+
+/*
+ * I2C bus multiplexer
+ */
+#define I2C_MUX_PCA_ADDR_PRI		0x77
+#define I2C_MUX_PCA_ADDR_SEC		0x76 /* Secondary multiplexer */
+#define I2C_RETIMER_ADDR		0x18
+#define I2C_MUX_CH_DEFAULT		0x8
+#define I2C_MUX_CH_CH7301		0xC
+#define I2C_MUX_CH5			0xD
+#define I2C_MUX_CH7			0xF
+
+#define I2C_MUX_CH_VOL_MONITOR 0xa
+
+/*
+* RTC configuration
+*/
+#define RTC
+#define CONFIG_RTC_PCF8563 1
+#define CONFIG_SYS_I2C_RTC_ADDR         0x51  /* Channel 3*/
+#define CONFIG_CMD_DATE
+
+/* EEPROM */
+#define CONFIG_ID_EEPROM
+#define CONFIG_CMD_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM    0
+#define CONFIG_SYS_I2C_EEPROM_ADDR   0x57
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN     1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 5
+
+
+/* Voltage monitor on channel 2*/
+#define I2C_VOL_MONITOR_ADDR           0x40
+#define I2C_VOL_MONITOR_BUS_V_OFFSET   0x2
+#define I2C_VOL_MONITOR_BUS_V_OVF      0x1
+#define I2C_VOL_MONITOR_BUS_V_SHIFT    3
+
+
+/* DSPI */
+#define CONFIG_FSL_DSPI
+#define CONFIG_FSL_DSPI1
+#define CONFIG_DEFAULT_SPI_BUS 1
+
+#define CONFIG_CMD_SPI
+#define MMAP_DSPI          DSPI1_BASE_ADDR
+
+#define CONFIG_SYS_DSPI_CTAR0   1
+
+#define CONFIG_SYS_DSPI_CTAR1	(DSPI_CTAR_TRSZ(7) | DSPI_CTAR_PCSSCK_1CLK |\
+				DSPI_CTAR_PASC(0) | DSPI_CTAR_PDT(0) | \
+				DSPI_CTAR_CSSCK(2) | DSPI_CTAR_ASC(0) | \
+				DSPI_CTAR_DT(0))
+#define CONFIG_SPI_FLASH_SST /* cs1 */
+
+#define CONFIG_SYS_DSPI_CTAR2	(DSPI_CTAR_TRSZ(7) | DSPI_CTAR_PCSSCK_1CLK |\
+				DSPI_CTAR_PASC(0) | DSPI_CTAR_PDT(0) | \
+				DSPI_CTAR_CSSCK(0) | DSPI_CTAR_ASC(0) | \
+				DSPI_CTAR_DT(0))
+#define CONFIG_SPI_FLASH_STMICRO /* cs2 */
+
+#define CONFIG_SYS_DSPI_CTAR3	(DSPI_CTAR_TRSZ(7) | DSPI_CTAR_PCSSCK_1CLK |\
+				DSPI_CTAR_PASC(0) | DSPI_CTAR_PDT(0) | \
+				DSPI_CTAR_CSSCK(2) | DSPI_CTAR_ASC(0) | \
+				DSPI_CTAR_DT(0))
+#define CONFIG_SPI_FLASH_EON /* cs3 */
+
+#define CONFIG_SF_DEFAULT_SPEED      10000000
+#define CONFIG_SF_DEFAULT_MODE       SPI_MODE_0
+#define CONFIG_SF_DEFAULT_BUS        1
+#define CONFIG_SF_DEFAULT_CS         0
+
+/*
+* USB
+*/
+/* EHCI Support - disbaled by default */
+/*#define CONFIG_HAS_FSL_DR_USB*/
+
+#ifdef CONFIG_HAS_FSL_DR_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#endif
+
+/*XHCI Support - enabled by default*/
+#define CONFIG_HAS_FSL_XHCI_USB
+
+#ifdef CONFIG_HAS_FSL_XHCI_USB
+#define CONFIG_USB_XHCI
+#define CONFIG_USB_XHCI_FSL
+#define CONFIG_USB_XHCI_DWC3
+#define CONFIG_USB_MAX_CONTROLLER_COUNT         1
+#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS      2
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_CMD_EXT2
+
+#define CONFIG_USB_DWC3
+#define CONFIG_USB_DWC3_GADGET
+
+#define CONFIG_USB_GADGET
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_USB_GADGET_VBUS_DRAW 2
+#define CONFIG_G_DNL_MANUFACTURER "NXP Semiconductor"
+#define CONFIG_G_DNL_VENDOR_NUM 0x1234
+#define CONFIG_G_DNL_PRODUCT_NUM 0x1234
+#define CONFIG_USB_GADGET_DUALSPEED
+
+/* USB Gadget ums command */
+#define CONFIG_CMD_USB_MASS_STORAGE
+#endif
+
+#define CONFIG_CMD_MEMINFO
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		0x9fffffff
+
+#define CONFIG_MISC_INIT_R
+
+#endif /* __LS1012AQDS_H__ */
diff --git a/board/freescale/ls1012aqds/ls1012aqds_qixis.h b/board/freescale/ls1012aqds/ls1012aqds_qixis.h
index 584f604..7a1ba3d 100644
--- a/board/freescale/ls1012aqds/ls1012aqds_qixis.h
+++ b/board/freescale/ls1012aqds/ls1012aqds_qixis.h
@@ -11,7 +11,7 @@
 
 /* BRDCFG4[4:7] select EC1 and EC2 as a pair */
 #define BRDCFG4_EMISEL_MASK		0xe0
-#define BRDCFG4_EMISEL_SHIFT		5
+#define BRDCFG4_EMISEL_SHIFT		6
 
 /* SYSCLK */
 #define QIXIS_SYSCLK_66			0x0
diff --git a/board/freescale/ls1012ardb/Makefile b/board/freescale/ls1012ardb/Makefile
index 05fa9d9..bd80ce5 100644
--- a/board/freescale/ls1012ardb/Makefile
+++ b/board/freescale/ls1012ardb/Makefile
@@ -5,3 +5,4 @@
 #
 
 obj-y += ls1012ardb.o
+obj-y += eth.o
diff --git a/board/freescale/ls1012ardb/eth.c b/board/freescale/ls1012ardb/eth.c
new file mode 100644
index 0000000..29830e8
--- /dev/null
+++ b/board/freescale/ls1012ardb/eth.c
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <netdev.h>
+#include <fm_eth.h>
+#include <fsl_mdio.h>
+#include <malloc.h>
+#include <fsl_dtsec.h>
+#include <asm/arch/soc.h>
+#include <asm/arch-fsl-layerscape/config.h>
+#include <asm/arch/fsl_serdes.h>
+
+#include "../../../drivers/net/pfe_eth/pfe_eth.h"
+#include <asm/arch-fsl-layerscape/immap_lsch2.h>
+
+#define DEFAULT_PFE_MDIO_NAME "PFE_MDIO"
+
+int board_eth_init(bd_t *bis)
+{
+#ifdef CONFIG_FSL_PPFE
+        struct mii_dev *bus;
+	struct mdio_info mac1_mdio_info;
+	struct ccsr_scfg *scfg = (struct ccsr_scfg *)CONFIG_SYS_FSL_SCFG_ADDR;
+
+
+	/*TODO Following config should be done for all boards, where is the right place to put this */
+	out_be32(&scfg->pfeasbcr, in_be32(&scfg->pfeasbcr) | SCFG_PPFEASBCR_AWCACHE0);
+	out_be32(&scfg->pfebsbcr, in_be32(&scfg->pfebsbcr) | SCFG_PPFEASBCR_AWCACHE0);
+
+	/*CCI-400 QoS settings for PFE */
+	out_be32(&scfg->wr_qos1, 0x0ff00000);
+	out_be32(&scfg->rd_qos1, 0x0ff00000);
+
+	/* Set RGMII into 1G + Full duplex mode */
+	out_be32(&scfg->rgmiipcr, in_be32(&scfg->rgmiipcr) | (SCFG_RGMIIPCR_SETSP_1000M | SCFG_RGMIIPCR_SETFD));
+
+
+	out_be32((CONFIG_SYS_DCSR_DCFG_ADDR + 0x520), 0xFFFFFFFF);
+	out_be32((CONFIG_SYS_DCSR_DCFG_ADDR + 0x524), 0xFFFFFFFF);
+
+	mac1_mdio_info.reg_base = (void *)0x04200000; /*EMAC1_BASE_ADDR*/
+	mac1_mdio_info.name = DEFAULT_PFE_MDIO_NAME;
+
+	bus = ls1012a_mdio_init(&mac1_mdio_info);
+	if(!bus)
+	{
+		printf("Failed to register mdio \n");
+		return -1;
+	}
+
+	/*MAC1 */
+	ls1012a_set_mdio(0, miiphy_get_dev_by_name(DEFAULT_PFE_MDIO_NAME));
+	ls1012a_set_phy_address_mode(0,  EMAC1_PHY_ADDR, PHY_INTERFACE_MODE_SGMII);
+
+	/*MAC2 */
+	ls1012a_set_mdio(1, miiphy_get_dev_by_name(DEFAULT_PFE_MDIO_NAME));
+	ls1012a_set_phy_address_mode(1,  EMAC2_PHY_ADDR, PHY_INTERFACE_MODE_RGMII);
+
+
+	cpu_eth_init(bis);
+#endif
+	return pci_eth_init(bis);
+}
diff --git a/board/freescale/ls1012ardb/ls1012ardb.c b/board/freescale/ls1012ardb/ls1012ardb.c
index 347b8c8..90cbd5e 100644
--- a/board/freescale/ls1012ardb/ls1012ardb.c
+++ b/board/freescale/ls1012ardb/ls1012ardb.c
@@ -163,10 +163,6 @@ int dram_init(void)
 	return 0;
 }
 
-int board_eth_init(bd_t *bis)
-{
-	return pci_eth_init(bis);
-}
 
 int board_early_init_f(void)
 {
diff --git a/common/Makefile b/common/Makefile
index 2a1d9f8..f5db77e 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -136,6 +136,8 @@ obj-$(CONFIG_CMD_MII) += cmd_mii.o
 ifdef CONFIG_PHYLIB
 obj-$(CONFIG_CMD_MII) += cmd_mdio.o
 endif
+obj-$(CONFIG_CMD_PFE_COMMANDS) += cmd_pfe_commands.o
+obj-$(CONFIG_CMD_PFE_COMMANDS) += cmd_gemac_stat.o
 obj-$(CONFIG_CMD_MISC) += cmd_misc.o
 obj-$(CONFIG_CMD_MMC) += cmd_mmc.o
 obj-$(CONFIG_CMD_MMC_SPI) += cmd_mmc_spi.o
diff --git a/common/cmd_gemac_stat.c b/common/cmd_gemac_stat.c
new file mode 100644
index 0000000..49bb1aa
--- /dev/null
+++ b/common/cmd_gemac_stat.c
@@ -0,0 +1,147 @@
+/*
+ * (C) Copyright 2003
+ *  Author : Laurent Brando (Mindspeed Technologies)
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/**
+ * @file
+ * @brief Retrieve GEMAC Statistics
+ */
+
+#include <common.h>
+#include <command.h>
+#include "../drivers/net/pfe_eth/pfe_eth.h"
+#include "../drivers/net/pfe_eth/pfe/pfe.h"
+#include "../drivers/net/pfe_eth/pfe_firmware.h"
+#include "../drivers/net/pfe_eth/pfe/cbus.h"
+#include "../drivers/net/pfe_eth/pfe/cbus/class_csr.h"
+#include "../drivers/net/pfe_eth/pfe/cbus/emac.h"
+
+#define ETH_GSTRING_LEN         32 /* from linux/include/ethtool.h */
+
+static const struct fec_stat {
+	char name[ETH_GSTRING_LEN];
+	u16 offset;
+} fec_stats[] = {
+	/* RMON TX */
+	{ "tx_dropped", RMON_T_DROP },
+	{ "tx_packets", RMON_T_PACKETS },
+	{ "tx_broadcast", RMON_T_BC_PKT },
+	{ "tx_multicast", RMON_T_MC_PKT },
+	{ "tx_crc_errors", RMON_T_CRC_ALIGN },
+	{ "tx_undersize", RMON_T_UNDERSIZE },
+	{ "tx_oversize", RMON_T_OVERSIZE },
+	{ "tx_fragment", RMON_T_FRAG },
+	{ "tx_jabber", RMON_T_JAB },
+	{ "tx_collision", RMON_T_COL },
+	{ "tx_64byte", RMON_T_P64 },
+	{ "tx_65to127byte", RMON_T_P65TO127 },
+	{ "tx_128to255byte", RMON_T_P128TO255 },
+	{ "tx_256to511byte", RMON_T_P256TO511 },
+	{ "tx_512to1023byte", RMON_T_P512TO1023 },
+	{ "tx_1024to2047byte", RMON_T_P1024TO2047 },
+	{ "tx_GTE2048byte", RMON_T_P_GTE2048 },
+	{ "tx_octets", RMON_T_OCTETS },
+
+	/* IEEE TX */
+	{ "IEEE_tx_drop", IEEE_T_DROP },
+	{ "IEEE_tx_frame_ok", IEEE_T_FRAME_OK },
+	{ "IEEE_tx_1col", IEEE_T_1COL },
+	{ "IEEE_tx_mcol", IEEE_T_MCOL },
+	{ "IEEE_tx_def", IEEE_T_DEF },
+	{ "IEEE_tx_lcol", IEEE_T_LCOL },
+	{ "IEEE_tx_excol", IEEE_T_EXCOL },
+	{ "IEEE_tx_macerr", IEEE_T_MACERR },
+	{ "IEEE_tx_cserr", IEEE_T_CSERR },
+	{ "IEEE_tx_sqe", IEEE_T_SQE },
+	{ "IEEE_tx_fdxfc", IEEE_T_FDXFC },
+	{ "IEEE_tx_octets_ok", IEEE_T_OCTETS_OK },
+
+	/* RMON RX */
+	{ "rx_packets", RMON_R_PACKETS },
+	{ "rx_broadcast", RMON_R_BC_PKT },
+	{ "rx_multicast", RMON_R_MC_PKT },
+	{ "rx_crc_errors", RMON_R_CRC_ALIGN },
+	{ "rx_undersize", RMON_R_UNDERSIZE },
+	{ "rx_oversize", RMON_R_OVERSIZE },
+	{ "rx_fragment", RMON_R_FRAG },
+	{ "rx_jabber", RMON_R_JAB },
+	{ "rx_64byte", RMON_R_P64 },
+	{ "rx_65to127byte", RMON_R_P65TO127 },
+	{ "rx_128to255byte", RMON_R_P128TO255 },
+	{ "rx_256to511byte", RMON_R_P256TO511 },
+	{ "rx_512to1023byte", RMON_R_P512TO1023 },
+	{ "rx_1024to2047byte", RMON_R_P1024TO2047 },
+	{ "rx_GTE2048byte", RMON_R_P_GTE2048 },
+	{ "rx_octets", RMON_R_OCTETS },
+
+	/* IEEE RX */
+	{ "IEEE_rx_drop", IEEE_R_DROP },
+	{ "IEEE_rx_frame_ok", IEEE_R_FRAME_OK },
+	{ "IEEE_rx_crc", IEEE_R_CRC },
+	{ "IEEE_rx_align", IEEE_R_ALIGN },
+	{ "IEEE_rx_macerr", IEEE_R_MACERR },
+	{ "IEEE_rx_fdxfc", IEEE_R_FDXFC },
+	{ "IEEE_rx_octets_ok", IEEE_R_OCTETS_OK },
+};
+
+static void ls1012a_emac_print_stats(void *base)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fec_stats); i++)
+		printf("%s: %d\n", fec_stats[i].name, readl(base + fec_stats[i].offset));
+}
+
+static int gemac_stats(cmd_tbl_t *cmdtp, int flag, int argc,
+		       char * const argv[])
+{
+	void *gemac_base = NULL;
+
+	if (argc != 2) {
+		printf("Usage: \n" "gemac_stat [ethx]\n");
+		return CMD_RET_SUCCESS;
+	}
+
+	if ( strcmp(argv[1], "eth0") == 0)
+		gemac_base = (void *)EMAC1_BASE_ADDR;
+	else if ( strcmp(argv[1], "eth1") == 0)
+		gemac_base = (void *)EMAC2_BASE_ADDR;
+
+	if (gemac_base)
+	{
+		ls1012a_emac_print_stats(gemac_base);
+	}
+	else
+	{
+		printf("no such net device: %s\n", argv[1]);
+		return 1;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	gemac_stat,	2,	1,	gemac_stats,
+	"retrieve GEMAC statistics",
+	"Usage: \n"
+	"gemac_stat [ethx]\n"
+);
diff --git a/common/cmd_pfe_commands.c b/common/cmd_pfe_commands.c
new file mode 100644
index 0000000..f9f92c7
--- /dev/null
+++ b/common/cmd_pfe_commands.c
@@ -0,0 +1,983 @@
+/*
+ * (C) Copyright 2012
+ *  Author : Bill Westland (Mindspeed Technologies)
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/**
+ * @file
+ * @brief PFE utility commands
+ */
+
+#include <common.h>
+#include <command.h>
+#include "../drivers/net/pfe_eth/pfe_eth.h"
+#include "../drivers/net/pfe_eth/pfe/pfe.h"
+#include "../drivers/net/pfe_eth/pfe_firmware.h"
+#include "../drivers/net/pfe_eth/pfe/cbus/class_csr.h"
+#include "../drivers/net/pfe_eth/pfe/cbus/gpi.h"
+DECLARE_GLOBAL_DATA_PTR;
+
+int pfe_load_elf(int pe_mask, const struct firmware *fw);
+int ls1012a_gemac_initialize(bd_t * bis, int dev_id, char *devname);
+
+static void pfe_command_help(void)
+{
+	printf("Usage: pfe [start | firmware | load | lib | pe | gemac | gem | gpi | class | tmu | util | hif | status | expt | fftest] <options>\n");
+}
+
+static void pfe_command_firmware(int argc, char * const argv[])
+{
+	if (argc == 3 && strcmp(argv[2], "init") == 0)
+	{
+		pfe_firmware_init((u8 *)0x80100000, (u8 *)0x80180000, (u8 *)0x80200000);
+	}
+	else if (argc == 3 && strcmp(argv[2], "exit") == 0)
+	{
+		pfe_firmware_exit();
+	}
+	else
+	{
+		if (argc >= 3 && strcmp(argv[2], "help") != 0)
+		{
+			printf("Unknown option: %s\n", argv[2]);
+		}
+		printf("Usage: pfe firmware [init | exit]\n");
+	}
+}
+
+static void pfe_command_load(int argc, char * const argv[])
+{
+	if (argc >= 3 && strcmp(argv[2], "elf") == 0)
+	{
+		if (argc == 5)
+		{
+			u32 mask;
+			unsigned long image_start;
+			struct firmware fw;
+			mask = simple_strtoul(argv[3], NULL, 0);
+			image_start = simple_strtoul(argv[4], NULL, 16);
+			fw.data = (u8 *)image_start;
+			pfe_load_elf(mask, &fw);
+		}
+		else
+		{
+			printf("Usage: pfe load elf <pe_mask> <image_start>\n");
+		}
+	}
+	else
+	{
+		if (argc >= 3 && strcmp(argv[2], "help") != 0)
+		{
+			printf("Unknown option: %s\n", argv[2]);
+		}
+		printf("Usage: pfe load elf <parameters>\n");
+	}
+}
+#if 0
+static void pfe_command_lib(int argc, char *argv[])
+{
+	if (argc >= 3 && strcmp(argv[2], "init") == 0)
+	{
+		if (argc == 3)
+			pfe_lib_init((void *)COMCERTO_AXI_HFE_CFG_BASE, (void *)CONFIG_DDR_BASEADDR, CONFIG_DDR_PHYS_BASEADDR);
+		else if (argc == 6)
+		{
+			u32 cbus_base;
+			u32 ddr_base;
+			u32 ddr_phys_base;
+			cbus_base = simple_strtoul(argv[3], NULL, 16);
+			ddr_base = simple_strtoul(argv[4], NULL, 16);
+			ddr_phys_base = simple_strtoul(argv[5], NULL, 16);
+			pfe_lib_init((void *)cbus_base, (void *)ddr_base, ddr_phys_base);
+		}
+		else
+		{
+			printf("Usage: pfe lib init [<cbus_base> <ddr_base> <ddr_phys_base>]\n");
+		}
+	}
+	else
+	{
+		if (argc >= 3 && strcmp(argv[2], "help") != 0)
+		{
+			printf("Unknown option: %s\n", argv[2]);
+		}
+		printf("Usage: pfe lib init <parameters>\n");
+	}
+}
+#endif
+static void pfe_command_pe(int argc, char * const argv[])
+{
+	if (argc >= 3 && strcmp(argv[2], "pmem") == 0)
+	{
+		if (argc >= 4 && strcmp(argv[3], "read") == 0)
+		{
+			int i;
+			int num;
+			int id;
+			u32 addr;
+			u32 size;
+			u32 val;
+			if (argc == 7)
+				num = simple_strtoul(argv[6], NULL, 0);
+			else if (argc == 6)
+				num = 1;
+			else
+			{
+				printf("Usage: pfe pe pmem read <id> <addr> [<num>]\n");
+				return;
+			}
+			id = simple_strtoul(argv[4], NULL, 0);
+			addr = simple_strtoul(argv[5], NULL, 16);
+			size = 4;
+			for (i = 0; i < num; i++, addr += 4)
+			{
+				val = pe_pmem_read(id, addr, size);
+				val = be32_to_cpu(val);
+				if(!(i&3)) printf("%08x: ", addr);
+				printf("%08x%s", val, i == num - 1 || (i & 3) == 3 ? "\n" : " ");
+			}
+		}
+		else
+		{
+			printf("Usage: pfe pe pmem read <parameters>\n");
+		}
+	}
+	else if (argc >= 3 && strcmp(argv[2], "dmem") == 0)
+	{
+		if (argc >= 4 && strcmp(argv[3], "read") == 0)
+		{
+			int i;
+			int num;
+			int id;
+			u32 addr;
+			u32 size;
+			u32 val;
+			if (argc == 7)
+				num = simple_strtoul(argv[6], NULL, 0);
+			else if (argc == 6)
+				num = 1;
+			else
+			{
+				printf("Usage: pfe pe dmem read <id> <addr> [<num>]\n");
+				return;
+			}
+			id = simple_strtoul(argv[4], NULL, 0);
+			addr = simple_strtoul(argv[5], NULL, 16);
+			size = 4;
+			for (i = 0; i < num; i++, addr += 4)
+			{
+				val = pe_dmem_read(id, addr, size);
+				val = be32_to_cpu(val);
+				if(!(i&3)) printf("%08x: ", addr);
+				printf("%08x%s", val, i == num - 1 || (i & 3) == 3 ? "\n" : " ");
+			}
+		}
+		else if (argc >= 4 && strcmp(argv[3], "write") == 0)
+		{
+			int id;
+			u32 val;
+			u32 addr;
+			u32 size;
+			if (argc != 7)
+			{
+				printf("Usage: pfe pe dmem write <id> <val> <addr>\n");
+				return;
+			}
+			id = simple_strtoul(argv[4], NULL, 0);
+			val = simple_strtoul(argv[5], NULL, 16);
+			val = cpu_to_be32(val);
+			addr = simple_strtoul(argv[6], NULL, 16);
+			size = 4;
+			pe_dmem_write(id, val, addr, size);
+		}
+		else
+		{
+			printf("Usage: pfe pe dmem [read | write] <parameters>\n");
+		}
+	}
+	else if (argc >= 3 && strcmp(argv[2], "lmem") == 0)
+	{
+		if (argc >= 4 && strcmp(argv[3], "read") == 0)
+		{
+			int i;
+			int num;
+			u32 val;
+			u32 offset;
+			if (argc == 6)
+				num = simple_strtoul(argv[5], NULL, 0);
+			else if (argc == 5)
+				num = 1;
+			else
+			{
+				printf("Usage: pfe pe lmem read <offset> [<num>]\n");
+				return;
+			}
+			offset = simple_strtoul(argv[4], NULL, 16);
+			for (i = 0; i < num; i++, offset += 4)
+			{
+				pe_lmem_read(&val, 4, offset);
+				val = be32_to_cpu(val);
+				printf("%08x%s", val, i == num - 1 || (i & 7) == 7 ? "\n" : " ");
+			}
+		}
+		else if (argc >= 4 && strcmp(argv[3], "write") == 0)
+		{
+			u32 val;
+			u32 offset;
+			if (argc != 6)
+			{
+				printf("Usage: pfe pe lmem write <val> <offset>\n");
+				return;
+			}
+			val = simple_strtoul(argv[4], NULL, 16);
+			val = cpu_to_be32(val);
+			offset = simple_strtoul(argv[5], NULL, 16);
+			pe_lmem_write(&val, 4, offset);
+		}
+		else
+		{
+			printf("Usage: pfe pe lmem [read | write] <parameters>\n");
+		}
+	}
+	else
+	{
+		if (strcmp(argv[2], "help") != 0)
+		{
+			printf("Unknown option: %s\n", argv[2]);
+		}
+		printf("Usage: pfe pe <parameters>\n");
+	}
+	//void pe_mem_memcpy_to32(int id, u32 mem_access_addr, const void *src, unsigned int len)
+	//void pe_dmem_memcpy_to32(int id, u32 dst, const void *src, unsigned int len)
+	//void pe_pmem_memcpy_to32(int id, u32 dst, const void *src, unsigned int len)
+	//int pe_load_elf_section(int id, const void *data, Elf32_Shdr *shdr)
+}
+
+#if 0
+static void pfe_command_gemac(int argc, char *argv[])
+{
+void gemac_init(void *base, void *cfg)
+void gemac_set_speed(void *base, MAC_SPEED gem_speed)
+void gemac_set_duplex(void *base, int duplex)
+void gemac_set_mode(void *base, int mode)
+void gemac_reset(void *base)
+void gemac_enable(void *base)
+void gemac_disable(void *base)
+void gemac_set_address(void *base, SPEC_ADDR *addr)
+SPEC_ADDR gemac_get_address(void *base)
+void gemac_set_laddr1(void *base, MAC_ADDR *address)
+void gemac_set_laddr2(void *base, MAC_ADDR *address)
+void gemac_set_laddr3(void *base, MAC_ADDR *address)
+void gemac_set_laddr4(void *base, MAC_ADDR *address)
+void gemac_set_laddrN(void *base, MAC_ADDR *address, unsigned int entry_index)
+void gemac_allow_broadcast(void *base)
+void gemac_no_broadcast(void *base)
+void gemac_enable_unicast(void *base)
+void gemac_disable_unicast(void *base)
+void gemac_enable_multicast(void *base)
+void gemac_disable_multicast(void *base)
+void gemac_enable_fcs_rx(void *base)
+void gemac_disable_fcs_rx(void *base)
+void gemac_enable_1536_rx(void *base)
+void gemac_disable_1536_rx(void *base)
+void gemac_enable_pause_rx(void *base)
+void gemac_disable_pause_rx(void *base)
+void gemac_set_config(void *base, GEMAC_CFG *cfg)
+unsigned int * gemac_get_stats(void *base)
+}
+#endif
+
+#if 0
+static void pfe_command_gem(int argc, char *argv[])
+{
+MAC_ADDR gem_get_laddr1(void *base)
+MAC_ADDR gem_get_laddr2(void *base)
+MAC_ADDR gem_get_laddr3(void *base)
+MAC_ADDR gem_get_laddr4(void *base)
+MAC_ADDR gem_get_laddrN(void *base, unsigned int entry_index)
+}
+#endif
+
+#if 0
+static void pfe_command_gpi(int argc, char *argv[])
+{
+void gpi_init(void *base, GPI_CFG *cfg)
+void gpi_reset(void *base)
+void gpi_enable(void *base)
+void gpi_disable(void *base)
+void gpi_set_config(void *base, GPI_CFG *cfg)
+}
+#endif
+
+#if 1
+static void pfe_command_class(int argc, char * const argv[])
+{
+	if (argc >= 3 && strcmp(argv[2], "init") == 0)
+	{
+		CLASS_CFG cfg;
+		if (argc == 3)
+		{
+#define CONFIG_DDR_PHYS_BASEADDR	0x03800000
+			cfg.route_table_hash_bits = ROUTE_TABLE_HASH_BITS;
+			cfg.route_table_baseaddr = CONFIG_DDR_PHYS_BASEADDR + ROUTE_TABLE_BASEADDR;
+		}
+		else if (argc == 5)
+		{
+			cfg.route_table_hash_bits = simple_strtoul(argv[3], NULL, 16);
+			cfg.route_table_baseaddr = simple_strtoul(argv[4], NULL, 16);
+		}
+		else
+		{
+			printf("Usage: pfe class init <route_table_hash_bits> <route_table_baseaddr>\n");
+		}
+		class_init(&cfg);
+	}
+	else if (argc == 3 && strcmp(argv[2], "reset") == 0)
+	{
+		class_reset();
+	}
+	else if (argc == 3 && strcmp(argv[2], "enable") == 0)
+	{
+		class_enable();
+	}
+	else if (argc == 3 && strcmp(argv[2], "disable") == 0)
+	{
+		class_disable();
+	}
+	else if (argc >= 3 && strcmp(argv[2], "config") == 0)
+	{
+		CLASS_CFG cfg;
+		if (argc == 3)
+		{
+			cfg.route_table_hash_bits = ROUTE_TABLE_HASH_BITS;
+			cfg.route_table_baseaddr = CONFIG_DDR_PHYS_BASEADDR + ROUTE_TABLE_BASEADDR;
+		}
+		else if (argc == 5)
+		{
+			cfg.route_table_hash_bits = simple_strtoul(argv[3], NULL, 16);
+			cfg.route_table_baseaddr = simple_strtoul(argv[4], NULL, 16);
+		}
+		else
+		{
+			printf("Usage: pfe class config <route_table_hash_bits> <route_table_baseaddr>\n");
+		}
+		class_set_config(&cfg);
+	}
+	else if (argc >= 3 && strcmp(argv[2], "bus") == 0)
+	{
+		if (argc >= 4 && strcmp(argv[3], "read") == 0)
+		{
+			u32 addr;
+			u32 size;
+			u32 val;
+			if (argc != 6)
+			{
+				printf("Usage: pfe class bus read <addr> <size>\n");
+				return;
+			}
+			addr = simple_strtoul(argv[4], NULL, 16);
+			size = simple_strtoul(argv[5], NULL, 16);
+			val = class_bus_read(addr, size);
+			printf("%08x\n", val);
+		}
+		else if (argc >= 4 && strcmp(argv[3], "write") == 0)
+		{
+			u32 val;
+			u32 addr;
+			u32 size;
+			if (argc != 7)
+			{
+				printf("Usage: pfe class bus write <val> <addr> <size>\n");
+				return;
+			}
+			val = simple_strtoul(argv[4], NULL, 16);
+			addr = simple_strtoul(argv[5], NULL, 16);
+			size = simple_strtoul(argv[6], NULL, 16);
+			class_bus_write(val, addr, size);
+		}
+		else
+		{
+			printf("Usage: pfe class bus [read | write] <parameters>\n");
+		}
+	}
+	else
+	{
+		if (argc >= 3 && strcmp(argv[2], "help") != 0)
+		{
+			printf("Unknown option: %s\n", argv[2]);
+		}
+		printf("Usage: pfe class [init | reset | enable | disable | config | bus] <parameters>\n");
+	}
+}
+
+static void pfe_command_tmu(int argc, char * const argv[])
+{
+	if (argc >= 3 && strcmp(argv[2], "init") == 0)
+	{
+		if (argc == 5)
+		{
+			TMU_CFG cfg;
+			cfg.llm_base_addr = simple_strtoul(argv[3], NULL, 16);
+			cfg.llm_queue_len = simple_strtoul(argv[4], NULL, 16);
+			tmu_init(&cfg);
+		}
+		else
+		{
+			printf("Usage: pfe tmu init <llm_base_addr> <llm_queue_len>\n");
+		}
+	}
+	else if (argc >= 3 && strcmp(argv[2], "enable") == 0)
+	{
+		if (argc == 4)
+		{
+			u32 mask;
+			mask = simple_strtoul(argv[3], NULL, 16);
+			tmu_enable(mask);
+		}
+		else
+		{
+			printf("Usage: pfe tmu enable <pe_mask>\n");
+		}
+	}
+	else if (argc >= 3 && strcmp(argv[2], "disable") == 0)
+	{
+		if (argc == 4)
+		{
+			u32 mask;
+			mask = simple_strtoul(argv[3], NULL, 16);
+			tmu_disable(mask);
+		}
+		else
+		{
+			printf("Usage: pfe tmu disable <pe_mask>\n");
+		}
+	}
+	else
+	{
+		if (argc >= 3 && strcmp(argv[2], "help") != 0)
+		{
+			printf("Unknown option: %s\n", argv[2]);
+		}
+		printf("Usage: pfe tmu [init | enable | disable] <parameters>\n");
+	}
+}
+#endif
+
+/** qm_read_drop_stat
+ * This function is used to read the drop statistics from the TMU
+ * hw drop counter.  Since the hw counter is always cleared afer
+ * reading, this function maintains the previous drop count, and
+ * adds the new value to it.  That value can be retrieved by
+ * passing a pointer to it with the total_drops arg.
+ *
+ * @param tmu           TMU number (0 - 3)
+ * @param queue         queue number (0 - 15)
+ * @param total_drops   pointer to location to store total drops (or NULL)
+ * @param do_reset      if TRUE, clear total drops after updating
+ *
+ */
+
+u32 qm_read_drop_stat(u32 tmu, u32 queue, u32 *total_drops, int do_reset)
+{
+#define NUM_QUEUES		16
+	static u32 qtotal[TMU_MAX_ID + 1][NUM_QUEUES];
+	u32 val;
+	writel((tmu << 8) | queue, TMU_TEQ_CTRL);
+	writel((tmu << 8) | queue, TMU_LLM_CTRL);
+	val = readl(TMU_TEQ_DROP_STAT);
+	qtotal[tmu][queue] += val;
+	if (total_drops)
+		*total_drops = qtotal[tmu][queue];
+	if (do_reset)
+		qtotal[tmu][queue] = 0;
+	return val;
+}
+
+static ssize_t tmu_queue_stats(char *buf, int tmu, int queue)
+{
+	ssize_t len = 0;
+	u32 drops;
+
+	printf("%d-%02d, ", tmu, queue);
+
+	drops = qm_read_drop_stat(tmu, queue, NULL, 0);
+
+	/* Select queue */
+	writel((tmu << 8) | queue, TMU_TEQ_CTRL);
+	writel((tmu << 8) | queue, TMU_LLM_CTRL);
+
+	printf("(teq) drop: %10u, tx: %10u (llm) head: %08x, tail: %08x, drop: %10u\n",
+			drops, readl(TMU_TEQ_TRANS_STAT),
+			readl(TMU_LLM_QUE_HEADPTR), readl(TMU_LLM_QUE_TAILPTR),
+			readl(TMU_LLM_QUE_DROPCNT));
+
+	return len;
+}
+
+
+static ssize_t tmu_queues(char *buf, int tmu)
+{
+	ssize_t len = 0;
+	int queue;
+
+	for (queue = 0; queue < 16; queue++)
+		len += tmu_queue_stats(buf + len, tmu, queue);
+
+	return len;
+}
+
+void hif_status(void)
+{
+	printf("hif:\n");
+
+	printf("  tx curr bd:    %x\n", readl(HIF_TX_CURR_BD_ADDR));
+	printf("  tx status:     %x\n", readl(HIF_TX_STATUS));
+	printf("  tx dma status: %x\n", readl(HIF_TX_DMA_STATUS));
+
+	printf("  rx curr bd:    %x\n", readl(HIF_RX_CURR_BD_ADDR));
+	printf("  rx status:     %x\n", readl(HIF_RX_STATUS));
+	printf("  rx dma status: %x\n", readl(HIF_RX_DMA_STATUS));
+
+	printf("hif nocopy:\n");
+
+	printf("  tx curr bd:    %x\n", readl(HIF_NOCPY_TX_CURR_BD_ADDR));
+	printf("  tx status:     %x\n", readl(HIF_NOCPY_TX_STATUS));
+	printf("  tx dma status: %x\n", readl(HIF_NOCPY_TX_DMA_STATUS));
+
+	printf("  rx curr bd:    %x\n", readl(HIF_NOCPY_RX_CURR_BD_ADDR));
+	printf("  rx status:     %x\n", readl(HIF_NOCPY_RX_STATUS));
+	printf("  rx dma status: %x\n", readl(HIF_NOCPY_RX_DMA_STATUS));
+}
+
+static void  gpi(int id, void *base)
+{
+        u32 val;
+
+        printf("gpi%d:\n  ", id);
+
+        printf("  tx under stick: %x\n", readl(base + GPI_FIFO_STATUS));
+        val = readl(base + GPI_FIFO_DEBUG);
+        printf("  tx pkts:        %x\n", (val >> 23) & 0x3f);
+        printf("  rx pkts:        %x\n", (val >> 18) & 0x3f);
+        printf("  tx bytes:       %x\n", (val >> 9) & 0x1ff);
+        printf("  rx bytes:       %x\n", (val >> 0) & 0x1ff);
+        printf("  overrun:        %x\n", readl(base + GPI_OVERRUN_DROPCNT));
+}
+
+void  bmu(int id, void *base)
+{
+	printf("bmu: %d\n", id);
+	printf("  buf size:  %x\n", (1 << readl(base + BMU_BUF_SIZE)));
+	printf("  buf count: %x\n", readl(base + BMU_BUF_CNT));
+	printf("  buf rem:   %x\n", readl(base + BMU_REM_BUF_CNT));
+	printf("  buf curr:  %x\n", readl(base + BMU_CURR_BUF_CNT));
+	printf("  free err:  %x\n", readl(base + BMU_FREE_ERR_ADDR));
+}
+
+#define	PESTATUS_ADDR_CLASS	0x800
+#define	PESTATUS_ADDR_TMU	0x80
+#define	PESTATUS_ADDR_UTIL	0x0
+
+static void pfe_pe_status(int argc, char * const argv[])
+{
+	int do_clear = 0;
+	int j;
+	u32 id;
+	u32 dmem_addr;
+	u32 cpu_state;
+	u32 activity_counter;
+	u32 rx;
+	u32 tx;
+	u32 drop;
+	char statebuf[5];
+	u32 class_debug_reg = 0;
+	u32 debug_indicator;
+	u32 debug[16];
+
+	if (argc == 4 && strcmp(argv[3], "clear") == 0)
+		do_clear = 1;
+
+	for (id = CLASS0_ID; id < MAX_PE; id++)
+	{
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+		if (id == UTIL_ID)
+		{
+			printf("util:\n");
+			dmem_addr = PESTATUS_ADDR_UTIL;
+		}
+		else if (id >= TMU0_ID)
+#else
+		if (id >= TMU0_ID)
+#endif
+		{
+			if (id == TMU2_ID)
+				continue;
+			if (id == TMU0_ID)
+				printf("tmu:\n");
+			dmem_addr = PESTATUS_ADDR_TMU;
+		}
+		else
+		{
+			if (id == CLASS0_ID)
+				printf("class:\n");
+			dmem_addr = PESTATUS_ADDR_CLASS;
+			class_debug_reg = readl(CLASS_PE0_DEBUG + id * 4);
+		}
+		cpu_state = pe_dmem_read(id, dmem_addr, 4);
+		dmem_addr += 4;
+		memcpy(statebuf, (char *)&cpu_state, 4);
+		statebuf[4] = '\0';
+		activity_counter = pe_dmem_read(id, dmem_addr, 4);
+		dmem_addr += 4;
+		rx = pe_dmem_read(id, dmem_addr, 4);
+		if (do_clear)
+			pe_dmem_write(id, 0, dmem_addr, 4);
+		dmem_addr += 4;
+		tx = pe_dmem_read(id, dmem_addr, 4);
+		if (do_clear)
+			pe_dmem_write(id, 0, dmem_addr, 4);
+		dmem_addr += 4;
+		drop = pe_dmem_read(id, dmem_addr, 4);
+		if (do_clear)
+			pe_dmem_write(id, 0, dmem_addr, 4);
+		dmem_addr += 4;
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+		if (id == UTIL_ID)
+		{
+			printf("state=%4s ctr=%08x rx=%x tx=%x\n",
+					statebuf, cpu_to_be32(activity_counter),
+					cpu_to_be32(rx), cpu_to_be32(tx));
+		}
+		else
+#endif
+		if (id >= TMU0_ID)
+		{
+			printf("%d: state=%4s ctr=%08x rx=%x qstatus=%x\n",
+					id - TMU0_ID, statebuf, cpu_to_be32(activity_counter),
+					cpu_to_be32(rx), cpu_to_be32(tx));
+		}
+		else
+		{
+			printf("%d: pc=1%04x ldst=%04x state=%4s ctr=%08x rx=%x tx=%x drop=%x\n",
+					id - CLASS0_ID, class_debug_reg & 0xFFFF, class_debug_reg >> 16,
+					statebuf, cpu_to_be32(activity_counter),
+					cpu_to_be32(rx), cpu_to_be32(tx), cpu_to_be32(drop));
+		}
+		debug_indicator = pe_dmem_read(id, dmem_addr, 4);
+		dmem_addr += 4;
+		if (debug_indicator == cpu_to_be32('DBUG'))
+		{
+			int last = 0;
+			for (j = 0; j < 16; j++)
+			{
+				debug[j] = pe_dmem_read(id, dmem_addr, 4);
+				if (debug[j])
+				{
+					last = j + 1;
+					if (do_clear)
+						pe_dmem_write(id, 0, dmem_addr, 4);
+				}
+				dmem_addr += 4;
+			}
+			for (j = 0; j < last; j++)
+			{
+				printf("%08x%s", cpu_to_be32(debug[j]), (j & 0x7) == 0x7 || j == last - 1 ? "\n" : " ");
+			}
+		}
+	}
+
+}
+
+static void pfe_command_status(int argc, char * const argv[])
+{
+
+	if (argc >= 3 && strcmp(argv[2], "pe") == 0)
+	{
+		pfe_pe_status(argc, argv);
+	}
+	else if (argc == 3 && strcmp(argv[2], "bmu") == 0)
+	{
+		bmu(1, BMU1_BASE_ADDR);
+		bmu(2, BMU2_BASE_ADDR);
+	}
+	else if (argc == 3 && strcmp(argv[2], "hif") == 0)
+	{
+		hif_status();
+	}
+	else if (argc == 3 && strcmp(argv[2], "gpi") == 0)
+	{
+		gpi(0, EGPI1_BASE_ADDR);
+		gpi(1, EGPI2_BASE_ADDR);
+		gpi(3, HGPI_BASE_ADDR);
+	}
+	else if (argc == 3 && strcmp(argv[2], "tmu0_queues") == 0)
+	{
+		tmu_queues(NULL, 0);
+	}
+	else if (argc == 3 && strcmp(argv[2], "tmu1_queues") == 0)
+	{
+		tmu_queues(NULL, 1);
+	}
+	else if (argc == 3 && strcmp(argv[2], "tmu3_queues") == 0)
+	{
+		tmu_queues(NULL, 3);
+	}
+	else
+		printf("Usage: pfe status [pe <clear> | bmu | gpi | hif | tmuX_queues ]\n");
+
+	return;
+}
+
+
+#define EXPT_DUMP_ADDR 0x1fa8
+#define EXPT_REG_COUNT 20
+static const char *register_names[EXPT_REG_COUNT] = {
+		"  pc", "ECAS", " EID", "  ED",
+		"  sp", "  r1", "  r2", "  r3",
+		"  r4", "  r5", "  r6", "  r7",
+		"  r8", "  r9", " r10", " r11",
+		" r12", " r13", " r14", " r15"
+};
+
+static void pfe_command_expt(int argc, char * const argv[])
+{
+	unsigned int id, i, val, addr;
+
+	if (argc == 3)
+	{
+		id = simple_strtoul(argv[2], NULL, 0);
+		addr = EXPT_DUMP_ADDR;
+		printf("Exception information for PE %d:\n", id);
+		for (i = 0; i < EXPT_REG_COUNT; i++)
+		{
+			val = pe_dmem_read(id, addr, 4);
+			val = be32_to_cpu(val);
+			printf("%s:%08x%s", register_names[i], val, (i & 3) == 3 ? "\n" : " ");
+			addr += 4;
+		}
+	}
+	else
+	{
+		printf("Usage: pfe expt <id>\n");
+	}
+}
+
+static void pfe_command_util(int argc, char * const argv[])
+{
+	if (argc == 3 && strcmp(argv[2], "init") == 0)
+	{
+		UTIL_CFG cfg;
+		util_init(&cfg);
+	}
+	else if (argc == 3 && strcmp(argv[2], "reset") == 0)
+	{
+		util_reset();
+	}
+	else if (argc == 3 && strcmp(argv[2], "enable") == 0)
+	{
+		util_enable();
+	}
+	else if (argc == 3 && strcmp(argv[2], "disable") == 0)
+	{
+		util_disable();
+	}
+	else if (argc >= 3 && strcmp(argv[2], "bus") == 0)
+		{
+			if (argc >= 4 && strcmp(argv[3], "read") == 0)
+			{
+				u32 addr;
+				u32 size;
+				u32 val;
+				if (argc != 6)
+				{
+					printf("Usage: pfe util bus read <addr> <size>\n");
+					return;
+				}
+				addr = simple_strtoul(argv[4], NULL, 16);
+				size = simple_strtoul(argv[5], NULL, 16);
+				val = util_bus_read(addr, size);
+				printf("%08x\n", val);
+			}
+			else if (argc >= 4 && strcmp(argv[3], "write") == 0)
+			{
+				u32 val;
+				u32 addr;
+				u32 size;
+				if (argc != 7)
+				{
+					printf("Usage: pfe util bus write <val> <addr> <size>\n");
+					return;
+				}
+				val = simple_strtoul(argv[4], NULL, 16);
+				addr = simple_strtoul(argv[5], NULL, 16);
+				size = simple_strtoul(argv[6], NULL, 16);
+				util_bus_write(val, addr, size);
+			}
+			else
+			{
+				printf("Usage: pfe util bus [read | write] <parameters>\n");
+			}
+		}
+	else
+	{
+		if (argc >= 3 && strcmp(argv[2], "help") != 0)
+		{
+			printf("Unknown option: %s\n", argv[2]);
+		}
+		printf("Usage: pfe util [init | reset | enable | disable | bus] <parameters>\n");
+	}
+}
+
+#if 0
+static void pfe_command_hif(int argc, char *argv[])
+{
+void hif_nocpy_init(void)
+void hif_init(void)
+void hif_tx_enable(void)
+void hif_tx_disable(void)
+void hif_rx_enable(void)
+void hif_rx_disable(void)
+}
+#endif
+
+#define ROUTE_TABLE_START	(CONFIG_DDR_PHYS_BASEADDR+ROUTE_TABLE_BASEADDR)
+static void pfe_command_fftest(int argc, char * const argv[])
+{
+	bd_t *bd = gd->bd;
+	struct eth_device *edev_eth0;
+	struct eth_device *edev_eth1;
+
+
+	// open eth0 and eth1 
+	edev_eth0 = eth_get_dev_by_name("pfe_eth0");
+	if (!edev_eth0)
+	{
+		printf("Cannot access eth0\n");
+		return;
+	}
+
+	if (eth_write_hwaddr(edev_eth0, "eth", edev_eth0->index))
+		puts("\nWarning: failed to set MAC address for c2000_gemac0\n");
+
+	if (edev_eth0->state != ETH_STATE_ACTIVE)
+	{
+		if (edev_eth0->init(edev_eth0, bd) < 0) {
+			printf("eth0 init failed\n");
+			return;
+		}
+		edev_eth0->state = ETH_STATE_ACTIVE;
+	}
+
+	edev_eth1 = eth_get_dev_by_name("pfe_eth1");
+	if (!edev_eth1)
+	{
+		printf("Cannot access eth1\n");
+		return;
+	}
+
+	if (eth_write_hwaddr(edev_eth1, "eth", edev_eth1->index))
+		puts("\nWarning: failed to set MAC address for c2000_gemac1\n");
+
+	if (edev_eth1->state != ETH_STATE_ACTIVE)
+	{
+		if (edev_eth1->init(edev_eth1, bd) < 0) {
+			printf("eth1 init failed\n");
+			return;
+		}
+		edev_eth1->state = ETH_STATE_ACTIVE;
+	}
+
+}
+
+#ifdef CONFIG_CMD_PFE_START
+static void pfe_command_start(int argc, char * const argv[])
+{
+	printf("Starting PFE \n");
+	ls1012a_gemac_initialize(gd->bd, 0 , "pfe_eth0");
+	ls1012a_gemac_initialize(gd->bd, 1 , "pfe_eth1");
+}
+#endif
+
+
+static int pfe_command(cmd_tbl_t *cmdtp, int flag, int argc,
+		       char * const argv[])
+{
+	if (argc == 1 || strcmp(argv[1], "help") == 0)
+	{
+		pfe_command_help();
+		return CMD_RET_SUCCESS;
+	}
+	if (strcmp(argv[1], "firmware") == 0)
+		pfe_command_firmware(argc, argv);
+	else if (strcmp(argv[1], "load") == 0)
+		pfe_command_load(argc, argv);
+#if 0
+	else if (strcmp(argv[1], "lib") == 0)
+		pfe_command_lib(argc, argv);
+#endif
+	else if (strcmp(argv[1], "pe") == 0)
+		pfe_command_pe(argc, argv);
+#if 0
+	else if (strcmp(argv[1], "gemac") == 0)
+		pfe_command_gemac(argc, argv);
+	else if (strcmp(argv[1], "gem") == 0)
+		pfe_command_gem(argc, argv);
+	else if (strcmp(argv[1], "gpi") == 0)
+		pfe_command_gpi(argc, argv);
+#endif
+#if 1
+	else if (strcmp(argv[1], "class") == 0)
+		pfe_command_class(argc, argv);
+	else if (strcmp(argv[1], "tmu") == 0)
+		pfe_command_tmu(argc, argv);
+#endif
+	else if (strcmp(argv[1], "status") == 0)
+		pfe_command_status(argc, argv);
+	else if (strcmp(argv[1], "expt") == 0)
+		pfe_command_expt(argc, argv);
+	else if (strcmp(argv[1], "util") == 0)
+		pfe_command_util(argc, argv);
+#if 0
+	else if (strcmp(argv[1], "hif") == 0)
+		pfe_command_hif(argc, argv);
+#endif
+	else if (strcmp(argv[1], "fftest") == 0)
+		pfe_command_fftest(argc, argv);
+#ifdef CONFIG_CMD_PFE_START
+	else if (strcmp(argv[1], "start") == 0)
+		pfe_command_start(argc, argv);
+#endif
+	else
+	{
+		printf("Unknown option: %s\n", argv[1]);
+		pfe_command_help();
+		return CMD_RET_FAILURE;
+	}
+	return CMD_RET_SUCCESS;
+}
+
+
+U_BOOT_CMD(
+	pfe,	7,	1,	pfe_command,
+	"Performs PFE lib utility functions",
+	"Usage: \n"
+	"pfe <options>"
+);
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 150470c..c683b8f 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -72,3 +72,4 @@ obj-$(CONFIG_FSL_MC_ENET) += fsl-mc/
 obj-$(CONFIG_FSL_MC_ENET) += ldpaa_eth/
 obj-$(CONFIG_FSL_MEMAC) += fm/memac_phy.o
 obj-$(CONFIG_VSC9953) += vsc9953.o
+obj-$(CONFIG_FSL_PPFE) += pfe_eth/
diff --git a/drivers/net/pfe_eth/Makefile b/drivers/net/pfe_eth/Makefile
new file mode 100644
index 0000000..1af837d
--- /dev/null
+++ b/drivers/net/pfe_eth/Makefile
@@ -0,0 +1 @@
+obj-y += pfe_eth.o pfe_firmware.o pfe.o pfe_driver.o
diff --git a/drivers/net/pfe_eth/class_sbl_elf.fw b/drivers/net/pfe_eth/class_sbl_elf.fw
new file mode 100644
index 0000000..3745d9a
--- /dev/null
+++ b/drivers/net/pfe_eth/class_sbl_elf.fw
@@ -0,0 +1 @@
+0x7f,0x45,0x4c,0x46,0x01,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x6f,0x00,0x00,0x00,0x01,0x00,0x01,0x02,0x4c,0x00,0x00,0x00,0x34,0x00,0x00,0x13,0x14,0x00,0x04,0x00,0x05,0x00,0x34,0x00,0x20,0x00,0x04,0x00,0x28,0x00,0x0d,0x00,0x0c,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x90,0x00,0x00,0x08,0x98,0x00,0x00,0x00,0x06,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x08,0x98,0x00,0x00,0x08,0x98,0x00,0x00,0x08,0x98,0x00,0x00,0x01,0x80,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x06,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x0f,0x80,0x00,0x00,0x1f,0x80,0x00,0x00,0x1f,0x80,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x04,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x10,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x02,0x8c,0x00,0x00,0x02,0x8c,0x00,0x00,0x00,0x05,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2a,0x2a,0x2a,0x2a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x40,0x00,0x00,0x08,0x00,0x00,0x00,0x08,0x60,0x00,0x00,0x08,0x50,0x00,0x00,0x08,0x90,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x01,0x80,0x00,0x00,0x02,0x80,0x00,0x00,0x03,0x80,0x44,0x45,0x41,0x44,0xc0,0x25,0x00,0x34,0xc1,0x02,0x00,0x10,0xc1,0x02,0x00,0x08,0xc1,0x02,0x00,0x0c,0x73,0x74,0x6f,0x70,0x69,0x6e,0x69,0x74,0x72,0x75,0x6e,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x4c,0x00,0x01,0x01,0xe4,0x00,0x01,0x01,0xe4,0x00,0x01,0x01,0xe4,0x00,0x01,0x01,0xe4,0x00,0x01,0x01,0xe4,0x00,0x01,0x01,0xe4,0x00,0x01,0x01,0xe4,0x00,0x01,0x01,0xe4,0x00,0x01,0x01,0xe4,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa7,0x08,0xe0,0x00,0x1f,0x95,0xbf,0x0f,0x00,0x00,0xe0,0x00,0x1f,0x83,0xe0,0x29,0xa7,0x7f,0xe0,0x00,0x1f,0x96,0xbf,0x0f,0x00,0x00,0xe0,0x00,0x1f,0x04,0xa7,0xce,0xc7,0x81,0xbf,0xce,0x38,0x82,0xc4,0xfc,0x3f,0xe8,0x00,0x85,0xe0,0x80,0xa7,0x19,0xe1,0x80,0xbf,0x1f,0xe0,0x0e,0x3f,0xa8,0x3f,0x7a,0x04,0xf9,0x38,0x82,0xc0,0x58,0x78,0x86,0x79,0x05,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0xe0,0x00,0x19,0x87,0xe0,0x00,0x19,0x17,0xe0,0x00,0x1a,0x98,0x13,0x00,0xeb,0x82,0xca,0x02,0xa7,0x03,0xe0,0x00,0x1f,0x84,0x27,0x0a,0xe0,0x00,0x1f,0x07,0x16,0x81,0xbe,0x9e,0xe0,0x00,0x1f,0x19,0xbf,0x0f,0x00,0x00,0x00,0xff,0xa7,0x1f,0xc7,0x01,0xbf,0x1f,0xe0,0x00,0x1f,0x03,0xa6,0x84,0xe0,0x26,0xa7,0x7e,0xe0,0x0e,0x3e,0xde,0x27,0x69,0xa7,0x2f,0xc7,0x01,0xbf,0x2f,0xe0,0x00,0x1f,0x85,0xe0,0x26,0xa4,0x7f,0x9f,0x38,0xe2,0x00,0xcf,0x03,0x01,0x85,0x9f,0xa8,0xe2,0x00,0xcf,0xb7,0x05,0x85,0xa7,0xa8,0xeb,0xe0,0xc7,0x80,0x27,0x85,0x3c,0xe6,0xdf,0xa5,0xe0,0x00,0x00,0xf5,0xe2,0x00,0xcf,0x03,0x01,0x04,0x97,0xa8,0xc7,0xfc,0xb7,0xa8,0x9e,0x28,0x3d,0x68,0xe0,0x00,0x17,0xf0,0xe2,0x00,0xce,0x6f,0xc5,0x10,0xe0,0x6f,0x3d,0xac,0xe0,0x0a,0x3f,0x9a,0xa5,0x88,0xe2,0x00,0xcf,0x03,0x01,0x8f,0xe0,0x02,0x8e,0x88,0x17,0x80,0xe2,0x00,0xce,0x83,0xe0,0x6f,0x3c,0xad,0x3e,0xef,0xc6,0x7a,0x3f,0xe8,0xc7,0x96,0xe3,0xff,0xc6,0x7f,0x00,0x90,0x3f,0xe8,0xc7,0x8a,0xe0,0x01,0xaf,0x28,0x17,0x00,0xaf,0x1f,0x17,0x00,0xaf,0x2f,0xc6,0x06,0xaf,0x3f,0xe3,0xff,0xc6,0x7f,0xaf,0x4f,0x16,0x83,0xaf,0x5f,0xe0,0x00,0x1f,0x06,0x14,0x81,0xe0,0x26,0xa7,0x7e,0xac,0x8e,0x3c,0xef,0xe3,0xff,0xc4,0xf8,0xc4,0xf8,0xe3,0xff,0xc4,0xf8,0x3c,0x69,0x3d,0x29,0xe2,0x01,0xc4,0x78,0xe2,0x01,0xc5,0x7f,0x3c,0x1b,0xb4,0x9e,0xe2,0x01,0xcd,0x00,0xad,0x1e,0xbc,0x1e,0x05,0x93,0xe0,0x01,0xc4,0x00,0xe0,0x01,0xc4,0x80,0xe1,0xff,0xc5,0x00,0x7e,0x08,0x7e,0x89,0x7f,0x07,0x7f,0x8a,0xdf,0x60,0x67,0x07,0xe7,0xff,0x15,0x80,0xad,0x9e,0x67,0x8a,0x66,0x89,0x66,0x08,0x9f,0x1e,0x3d,0xee,0xe2,0x01,0xc5,0xff,0x3f,0xab,0xaf,0x8e,0x17,0x80,0xaf,0xde,0xad,0x9e,0xae,0xce,0xe0,0x00,0x1f,0x83,0xb6,0x1e,0xe0,0x26,0xa7,0xff,0xbf,0x85,0x00,0x00,0xe0,0x00,0x1f,0x04,0xa7,0xbe,0xc7,0x81,0xbf,0xbe,0xe0,0x00,0x1f,0x83,0xe0,0x26,0xa7,0xff,0xbf,0x82,0x00,0x00,0xc3,0x01,0xe2,0x00,0xc3,0x03,0xe7,0xfe,0x00,0xd5,0x38,0x82,0xc0,0x7c,0x78,0x81,0xe0,0x00,0x1f,0x84,0xe0,0x00,0x1f,0x1a,0xbf,0x0f,0xe0,0x00,0x1f,0x1b,0xbf,0x0f,0xdf,0x38,0xe0,0x00,0x1f,0x84,0xe0,0x00,0x1f,0x14,0xbf,0x0f,0xbc,0x1f,0xbf,0x0f,0x3a,0x80,0x00,0xff,0x00,0x00,0xea,0x00,0xcb,0x80,0xe0,0x3f,0xcb,0xa8,0xb8,0x47,0xb8,0xd7,0xb9,0x67,0xb9,0xf7,0xe0,0x01,0xba,0x07,0xe0,0x01,0xba,0x97,0xe0,0x01,0xbb,0x27,0xe0,0x01,0xbb,0xb7,0xe0,0x01,0xbc,0x47,0xe0,0x01,0xbc,0xd7,0xe0,0x01,0xbd,0x67,0xe0,0x01,0xbd,0xf7,0xe0,0x02,0xbe,0x07,0xe0,0x02,0xbe,0x97,0xe0,0x02,0xbf,0x27,0xe0,0x02,0xbf,0xb7,0xe0,0x60,0x3e,0x09,0xe0,0x60,0x3e,0x8a,0xe0,0x60,0x3f,0x0b,0xe0,0x60,0x3f,0x8c,0xbe,0x07,0xbe,0x97,0xbf,0x27,0xbf,0xb7,0xea,0x00,0xcb,0x80,0xe0,0x10,0xcb,0xa0,0x3c,0x6c,0xe7,0xff,0x00,0xc5,0x00,0x00,0x10,0x00,0x10,0x80,0x11,0x00,0x11,0x80,0x12,0x00,0x12,0x80,0x13,0x00,0x13,0x80,0x14,0x00,0x14,0x80,0x15,0x00,0x15,0x80,0x16,0x00,0x16,0x80,0x17,0x00,0x17,0x80,0xea,0x00,0xc8,0x00,0xe0,0x14,0xc8,0x14,0xea,0x00,0xcb,0x80,0xe0,0x10,0xcb,0xa0,0xe0,0x60,0x3c,0x00,0xcc,0x02,0xe0,0x60,0x3c,0x10,0xef,0xff,0xdf,0x9a,0x3a,0x80,0x47,0x43,0x43,0x3a,0x20,0x28,0x47,0x4e,0x55,0x29,0x20,0x34,0x2e,0x37,0x2e,0x31,0x00,0x00,0x2e,0x73,0x68,0x73,0x74,0x72,0x74,0x61,0x62,0x00,0x2e,0x70,0x6d,0x65,0x6d,0x00,0x2e,0x65,0x78,0x69,0x74,0x00,0x2e,0x69,0x6e,0x69,0x74,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x70,0x65,0x73,0x74,0x61,0x74,0x75,0x73,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x67,0x6f,0x74,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x73,0x64,0x61,0x74,0x61,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x6c,0x69,0x74,0x34,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x62,0x73,0x73,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x73,0x74,0x61,0x63,0x6b,0x00,0x2e,0x76,0x65,0x63,0x74,0x6f,0x72,0x00,0x2e,0x63,0x6f,0x6d,0x6d,0x65,0x6e,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x06,0x00,0x01,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x01,0xd0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x06,0x00,0x01,0x01,0xd0,0x00,0x00,0x11,0xd0,0x00,0x00,0x00,0x7a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x06,0x00,0x01,0x02,0x4c,0x00,0x00,0x12,0x4c,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1d,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x08,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x08,0x20,0x00,0x00,0x08,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x36,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x08,0x40,0x00,0x00,0x08,0x40,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x12,0x00,0x00,0x08,0x70,0x00,0x00,0x08,0x70,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x4d,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x03,0x00,0x00,0x08,0x90,0x00,0x00,0x08,0x90,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x57,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x08,0x98,0x00,0x00,0x08,0x98,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x1f,0x80,0x00,0x00,0x0f,0x80,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6b,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0x8c,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0x9d,0x00,0x00,0x00,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
\ No newline at end of file
diff --git a/drivers/net/pfe_eth/hal.h b/drivers/net/pfe_eth/hal.h
new file mode 100644
index 0000000..e795fe6
--- /dev/null
+++ b/drivers/net/pfe_eth/hal.h
@@ -0,0 +1,64 @@
+/*
+ *  (C) Copyright 2011
+ *  Author : Mindspeed Technologes
+ *  
+ *  See file CREDITS for list of people who contributed to this
+ *  project.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License as
+ *  published by the Free Software Foundation; either version 2 of
+ *  the License, or (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA 02111-1307 USA
+ * */
+
+#ifndef _HAL_H_
+#define _HAL_H_
+
+#if defined(CONFIG_PLATFORM_PCI)  
+/* For ChipIT */
+
+#include <linux/types.h>
+#include <linux/elf.h>
+#include <linux/errno.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <linux/slab.h>
+#include <linux/firmware.h>
+
+
+#define free(x)  kfree(x)
+#define xzalloc(x)  kmalloc(x, GFP_DMA)
+#define printf  printk
+
+//#define dprint(fmt, arg...)	printk(fmt, ##arg)
+#define dprint(fmt, arg...)	
+
+#else
+
+#include <linux/types.h>
+#include <elf.h>
+#include <common.h>
+//#include <errno.h>
+#include <asm/byteorder.h>
+#include <miiphy.h>
+#include <malloc.h>
+#include <asm/io.h>
+
+
+#include "pfe_eth.h"
+
+#endif
+
+
+#endif /* _HAL_H_ */
+
diff --git a/drivers/net/pfe_eth/pfe.c b/drivers/net/pfe_eth/pfe.c
new file mode 100644
index 0000000..3b5570a
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe.c
@@ -0,0 +1,1677 @@
+#include "hal.h"
+#include "pfe/pfe.h"
+
+void *cbus_base_addr;
+void *ddr_base_addr;
+unsigned long ddr_phys_base_addr;
+#if 0
+#define dprintf(fmt, arg...) printf(fmt, ##arg)
+#else
+#define dprintf(fmt, arg...)
+#endif
+static struct pe_info pe[MAX_PE];
+
+/** Initializes the PFE library.
+* Must be called before using any of the library functions.
+*
+* @param[in] cbus_base		CBUS virtual base address (as mapped in the host CPU address space)
+* @param[in] ddr_base		DDR virtual base address (as mapped in the host CPU address space)
+* @param[in] ddr_phys_base	DDR physical base address (as mapped in platform)
+*/
+void pfe_lib_init(void *cbus_base, void *ddr_base, unsigned long ddr_phys_base)
+{
+	cbus_base_addr = cbus_base;
+	ddr_base_addr = ddr_base;
+	ddr_phys_base_addr = ddr_phys_base;
+
+	pe[CLASS0_ID].dmem_base_addr = (u32)CLASS_DMEM_BASE_ADDR(0);
+	pe[CLASS0_ID].pmem_base_addr = (u32)CLASS_IMEM_BASE_ADDR(0);
+	pe[CLASS0_ID].pmem_size = (u32)CLASS_IMEM_SIZE;
+	pe[CLASS0_ID].mem_access_wdata = (void *)CLASS_MEM_ACCESS_WDATA;
+	pe[CLASS0_ID].mem_access_addr = (void *)CLASS_MEM_ACCESS_ADDR;
+	pe[CLASS0_ID].mem_access_rdata = (void *)CLASS_MEM_ACCESS_RDATA;
+
+	pe[CLASS1_ID].dmem_base_addr = (u32)CLASS_DMEM_BASE_ADDR(1);
+	pe[CLASS1_ID].pmem_base_addr = (u32)CLASS_IMEM_BASE_ADDR(1);
+	pe[CLASS1_ID].pmem_size = (u32)CLASS_IMEM_SIZE;
+	pe[CLASS1_ID].mem_access_wdata = (void *)CLASS_MEM_ACCESS_WDATA;
+	pe[CLASS1_ID].mem_access_addr = (void *)CLASS_MEM_ACCESS_ADDR;
+	pe[CLASS1_ID].mem_access_rdata = (void *)CLASS_MEM_ACCESS_RDATA;
+
+	pe[CLASS2_ID].dmem_base_addr = (u32)CLASS_DMEM_BASE_ADDR(2);
+	pe[CLASS2_ID].pmem_base_addr = (u32)CLASS_IMEM_BASE_ADDR(2);
+	pe[CLASS2_ID].pmem_size = (u32)CLASS_IMEM_SIZE;
+	pe[CLASS2_ID].mem_access_wdata = (void *)CLASS_MEM_ACCESS_WDATA;
+	pe[CLASS2_ID].mem_access_addr = (void *)CLASS_MEM_ACCESS_ADDR;
+	pe[CLASS2_ID].mem_access_rdata = (void *)CLASS_MEM_ACCESS_RDATA;
+
+	pe[CLASS3_ID].dmem_base_addr = (u32)CLASS_DMEM_BASE_ADDR(3);
+	pe[CLASS3_ID].pmem_base_addr = (u32)CLASS_IMEM_BASE_ADDR(3);
+	pe[CLASS3_ID].pmem_size = (u32)CLASS_IMEM_SIZE;
+	pe[CLASS3_ID].mem_access_wdata = (void *)CLASS_MEM_ACCESS_WDATA;
+	pe[CLASS3_ID].mem_access_addr = (void *)CLASS_MEM_ACCESS_ADDR;
+	pe[CLASS3_ID].mem_access_rdata = (void *)CLASS_MEM_ACCESS_RDATA;
+
+#if !defined(CONFIG_PLATFORM_PCI)
+	pe[CLASS4_ID].dmem_base_addr = (u32)CLASS_DMEM_BASE_ADDR(4);
+	pe[CLASS4_ID].pmem_base_addr = (u32)CLASS_IMEM_BASE_ADDR(4);
+	pe[CLASS4_ID].pmem_size = (u32)CLASS_IMEM_SIZE;
+	pe[CLASS4_ID].mem_access_wdata = (void *)CLASS_MEM_ACCESS_WDATA;
+	pe[CLASS4_ID].mem_access_addr = (void *)CLASS_MEM_ACCESS_ADDR;
+	pe[CLASS4_ID].mem_access_rdata = (void *)CLASS_MEM_ACCESS_RDATA;
+
+	pe[CLASS5_ID].dmem_base_addr = (u32)CLASS_DMEM_BASE_ADDR(5);
+	pe[CLASS5_ID].pmem_base_addr = (u32)CLASS_IMEM_BASE_ADDR(5);
+	pe[CLASS5_ID].pmem_size = (u32)CLASS_IMEM_SIZE;
+	pe[CLASS5_ID].mem_access_wdata = (void *)CLASS_MEM_ACCESS_WDATA;
+	pe[CLASS5_ID].mem_access_addr = (void *)CLASS_MEM_ACCESS_ADDR;
+	pe[CLASS5_ID].mem_access_rdata = (void *)CLASS_MEM_ACCESS_RDATA;
+#endif
+	pe[TMU0_ID].dmem_base_addr = (u32)TMU_DMEM_BASE_ADDR(0);
+	pe[TMU0_ID].pmem_base_addr = (u32)TMU_IMEM_BASE_ADDR(0);
+	pe[TMU0_ID].pmem_size = (u32)TMU_IMEM_SIZE;
+	pe[TMU0_ID].mem_access_wdata = (void *)TMU_MEM_ACCESS_WDATA;
+	pe[TMU0_ID].mem_access_addr = (void *)TMU_MEM_ACCESS_ADDR;
+	pe[TMU0_ID].mem_access_rdata = (void *)TMU_MEM_ACCESS_RDATA;
+
+#if !defined(CONFIG_TMU_DUMMY)
+	pe[TMU1_ID].dmem_base_addr = (u32)TMU_DMEM_BASE_ADDR(1);
+	pe[TMU1_ID].pmem_base_addr = (u32)TMU_IMEM_BASE_ADDR(1);
+	pe[TMU1_ID].pmem_size = (u32)TMU_IMEM_SIZE;
+	pe[TMU1_ID].mem_access_wdata = (void *)TMU_MEM_ACCESS_WDATA;
+	pe[TMU1_ID].mem_access_addr = (void *)TMU_MEM_ACCESS_ADDR;
+	pe[TMU1_ID].mem_access_rdata = (void *)TMU_MEM_ACCESS_RDATA;
+
+#if !defined(CONFIG_LS1012A)
+	pe[TMU2_ID].dmem_base_addr = (u32)TMU_DMEM_BASE_ADDR(2);
+	pe[TMU2_ID].pmem_base_addr = (u32)TMU_IMEM_BASE_ADDR(2);
+	pe[TMU2_ID].pmem_size = (u32)TMU_IMEM_SIZE;
+	pe[TMU2_ID].mem_access_wdata = (void *)TMU_MEM_ACCESS_WDATA;
+	pe[TMU2_ID].mem_access_addr = (void *)TMU_MEM_ACCESS_ADDR;
+	pe[TMU2_ID].mem_access_rdata = (void *)TMU_MEM_ACCESS_RDATA;
+#endif
+
+	pe[TMU3_ID].dmem_base_addr = (u32)TMU_DMEM_BASE_ADDR(3);
+	pe[TMU3_ID].pmem_base_addr = (u32)TMU_IMEM_BASE_ADDR(3);
+	pe[TMU3_ID].pmem_size = (u32)TMU_IMEM_SIZE;
+	pe[TMU3_ID].mem_access_wdata = (void *)TMU_MEM_ACCESS_WDATA;
+	pe[TMU3_ID].mem_access_addr = (void *)TMU_MEM_ACCESS_ADDR;
+	pe[TMU3_ID].mem_access_rdata = (void *)TMU_MEM_ACCESS_RDATA;
+#endif
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+	pe[UTIL_ID].dmem_base_addr = (u32)UTIL_DMEM_BASE_ADDR;
+	pe[UTIL_ID].mem_access_wdata = (void *)UTIL_MEM_ACCESS_WDATA;
+	pe[UTIL_ID].mem_access_addr = (void *)UTIL_MEM_ACCESS_ADDR;
+	pe[UTIL_ID].mem_access_rdata = (void *)UTIL_MEM_ACCESS_RDATA;
+#endif
+}
+
+
+/** Writes a buffer to PE internal memory from the host
+ * through indirect access registers.
+ *
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
+ * @param[in] src		Buffer source address
+ * @param[in] mem_access_addr	DMEM destination address (must be 32bit aligned)
+ * @param[in] len		Number of bytes to copy
+ */
+void pe_mem_memcpy_to32(int id, u32 mem_access_addr, const void *src, unsigned int len)
+{
+	u32 offset = 0, val, addr;
+	unsigned int len32 = len >> 2;
+	int i;
+
+	addr = mem_access_addr | PE_MEM_ACCESS_WRITE | PE_MEM_ACCESS_BYTE_ENABLE(0, 4);
+
+	for (i = 0; i < len32; i++, offset += 4, src += 4) {
+		val = *(u32 *)src;
+		writel(cpu_to_be32(val), pe[id].mem_access_wdata);
+		writel(addr + offset, pe[id].mem_access_addr);
+	}
+
+	if ((len = (len & 0x3))) {
+		val = 0;
+
+		addr = (mem_access_addr | PE_MEM_ACCESS_WRITE | PE_MEM_ACCESS_BYTE_ENABLE(0, len)) + offset;
+
+		for (i = 0; i < len; i++, src++)
+			val |= (*(u8 *)src) << (8 * i);
+
+		writel(cpu_to_be32(val), pe[id].mem_access_wdata);
+		writel(addr, pe[id].mem_access_addr);
+	}
+}
+
+/** Writes a buffer to PE internal data memory (DMEM) from the host
+ * through indirect access registers.
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
+ * @param[in] src		Buffer source address
+ * @param[in] dst		DMEM destination address (must be 32bit aligned)
+ * @param[in] len		Number of bytes to copy
+ */
+void pe_dmem_memcpy_to32(int id, u32 dst, const void *src, unsigned int len)
+{
+	pe_mem_memcpy_to32(id, pe[id].dmem_base_addr | dst | PE_MEM_ACCESS_DMEM, src, len);
+}
+
+
+/** Writes a buffer to PE internal program memory (PMEM) from the host
+ * through indirect access registers.
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., TMU3_ID)
+ * @param[in] src		Buffer source address
+ * @param[in] dst		PMEM destination address (must be 32bit aligned)
+ * @param[in] len		Number of bytes to copy
+ */
+void pe_pmem_memcpy_to32(int id, u32 dst, const void *src, unsigned int len)
+{
+	pe_mem_memcpy_to32(id, pe[id].pmem_base_addr | (dst & (pe[id].pmem_size - 1)) | PE_MEM_ACCESS_IMEM, src, len);
+}
+
+
+/** Reads PE internal program memory (IMEM) from the host
+ * through indirect access registers.
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., TMU3_ID)
+ * @param[in] addr		PMEM read address (must be aligned on size)
+ * @param[in] size		Number of bytes to read (maximum 4, must not cross 32bit boundaries)
+ * @return			the data read (in PE endianess, i.e BE).
+ */
+u32 pe_pmem_read(int id, u32 addr, u8 size)
+{
+	u32 offset = addr & 0x3;
+	u32 mask = 0xffffffff >> ((4 - size) << 3);
+	u32 val;
+
+	addr = pe[id].pmem_base_addr | ((addr & ~0x3) & (pe[id].pmem_size - 1)) | PE_MEM_ACCESS_READ | PE_MEM_ACCESS_IMEM | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
+
+	writel(addr, pe[id].mem_access_addr);
+	val = be32_to_cpu(readl(pe[id].mem_access_rdata));
+
+	return (val >> (offset << 3)) & mask;
+}
+
+
+/** Writes PE internal data memory (DMEM) from the host
+ * through indirect access registers.
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
+ * @param[in] addr		DMEM write address (must be aligned on size)
+ * @param[in] val		Value to write (in PE endianess, i.e BE)
+ * @param[in] size		Number of bytes to write (maximum 4, must not cross 32bit boundaries)
+ */
+void pe_dmem_write(int id, u32 val, u32 addr, u8 size)
+{
+	u32 offset = addr & 0x3;
+
+	addr = pe[id].dmem_base_addr | (addr & ~0x3) | PE_MEM_ACCESS_WRITE | PE_MEM_ACCESS_DMEM | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
+
+	/* Indirect access interface is byte swapping data being written */
+	writel(cpu_to_be32(val << (offset << 3)), pe[id].mem_access_wdata);
+	writel(addr, pe[id].mem_access_addr);
+}
+
+
+/** Reads PE internal data memory (DMEM) from the host
+ * through indirect access registers.
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
+ * @param[in] addr		DMEM read address (must be aligned on size)
+ * @param[in] size		Number of bytes to read (maximum 4, must not cross 32bit boundaries)
+ * @return			the data read (in PE endianess, i.e BE).
+ */
+u32 pe_dmem_read(int id, u32 addr, u8 size)
+{
+	u32 offset = addr & 0x3;
+	u32 mask = 0xffffffff >> ((4 - size) << 3);
+	u32 val;
+
+	addr = pe[id].dmem_base_addr | (addr & ~0x3) | PE_MEM_ACCESS_READ | PE_MEM_ACCESS_DMEM | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
+
+	writel(addr, pe[id].mem_access_addr);
+
+	/* Indirect access interface is byte swapping data being read */
+	val = be32_to_cpu(readl(pe[id].mem_access_rdata));
+
+	return (val >> (offset << 3)) & mask;
+}
+
+/** This function is used to write to CLASS internal bus peripherals (ccu, pe-lem) from the host
+* through indirect access registers.
+* @param[in]	val	value to write
+* @param[in]	addr	Address to write to (must be aligned on size)
+* @param[in]	size	Number of bytes to write (1, 2 or 4)
+*
+*/
+void class_bus_write(u32 val, u32 addr, u8 size)
+{
+	u32 offset = addr & 0x3;
+
+	writel((addr & CLASS_BUS_ACCESS_BASE_MASK), CLASS_BUS_ACCESS_BASE);
+
+	addr = (addr & ~CLASS_BUS_ACCESS_BASE_MASK) | PE_MEM_ACCESS_WRITE | (size << 24);
+
+	writel(cpu_to_be32(val << (offset << 3)), CLASS_BUS_ACCESS_WDATA);
+	writel(addr, CLASS_BUS_ACCESS_ADDR);
+}
+
+
+/** Reads from CLASS internal bus peripherals (ccu, pe-lem) from the host
+* through indirect access registers.
+* @param[in] addr	Address to read from (must be aligned on size)
+* @param[in] size	Number of bytes to read (1, 2 or 4)
+* @return		the read data
+*
+*/
+u32 class_bus_read(u32 addr, u8 size)
+{
+	u32 offset = addr & 0x3;
+	u32 mask = 0xffffffff >> ((4 - size) << 3);
+	u32 val;
+
+	writel((addr & CLASS_BUS_ACCESS_BASE_MASK), CLASS_BUS_ACCESS_BASE);
+
+	addr = (addr & ~CLASS_BUS_ACCESS_BASE_MASK) | (size << 24);
+
+	writel(addr, CLASS_BUS_ACCESS_ADDR);
+	val = be32_to_cpu(readl(CLASS_BUS_ACCESS_RDATA));
+
+	return (val >> (offset << 3)) & mask;
+}
+
+/** Writes data to the cluster memory (PE_LMEM)
+* @param[in] dst	PE LMEM destination address (must be 32bit aligned)
+* @param[in] src	Buffer source address
+* @param[in] len	Number of bytes to copy
+*/
+void class_pe_lmem_memcpy_to32(u32 dst, const void *src, unsigned int len)
+{
+	u32 len32 = len >> 2;
+	int i;
+
+	for (i = 0; i < len32; i++, src += 4, dst += 4)
+		class_bus_write(*(u32 *)src, dst, 4);
+
+	if (len & 0x2)
+	{
+		class_bus_write(*(u16 *)src, dst, 2);
+		src += 2;
+		dst += 2;
+	}
+
+	if (len & 0x1)
+	{
+		class_bus_write(*(u8 *)src, dst, 1);
+		src++;
+		dst++;
+	}
+}
+
+/** Writes value to the cluster memory (PE_LMEM)
+* @param[in] dst	PE LMEM destination address (must be 32bit aligned)
+* @param[in] val	Value to write
+* @param[in] len	Number of bytes to write
+*/
+void class_pe_lmem_memset(u32 dst, int val, unsigned int len)
+{
+	u32 len32 = len >> 2;
+	int i;
+
+	val = val | (val << 8) | (val << 16) | (val << 24);
+	
+	for (i = 0; i < len32; i++, dst += 4)
+		class_bus_write(val, dst, 4);
+
+	if (len & 0x2)
+	{
+		class_bus_write(val, dst, 2);
+		dst += 2;
+	}
+
+	if (len & 0x1)
+	{
+		class_bus_write(val, dst, 1);
+		dst++;
+	}
+}
+
+/** Reads data from the cluster memory (PE_LMEM)
+* @param[out] dst		pointer to the source buffer data are copied to
+* @param[in] len		length in bytes of the amount of data to read from cluster memory
+* @param[in] offset	offset in bytes in the cluster memory where data are read from
+*/
+void pe_lmem_read(u32 *dst, u32 len, u32 offset)
+{
+	u32 len32 = len >> 2;
+	int i = 0;
+
+	for (i = 0; i < len32; dst++, i++, offset += 4)
+		*dst = class_bus_read(PE_LMEM_BASE_ADDR + offset, 4);
+
+	/* FIXME we may have an out of bounds access on dst */
+	if (len & 0x03)
+		*dst = class_bus_read(PE_LMEM_BASE_ADDR + offset, (len & 0x03));
+}
+
+/** Writes data to the cluster memory (PE_LMEM)
+* @param[in] src	pointer to the source buffer data are copied from
+* @param[in] len	length in bytes of the amount of data to write to the cluster memory
+* @param[in] offset	offset in bytes in the cluster memory where data are written to
+*/
+void pe_lmem_write(u32 *src, u32 len, u32 offset)
+{
+	u32 len32 = len >> 2;
+	int i = 0;
+
+	for (i = 0; i < len32; src++, i++, offset += 4)
+		class_bus_write(*src, PE_LMEM_BASE_ADDR + offset, 4);
+
+	/* FIXME we may have an out of bounds access on src */
+	if (len & 0x03)
+		class_bus_write(*src, PE_LMEM_BASE_ADDR + offset, (len & 0x03));
+}
+
+/** Writes UTIL program memory (DDR) from the host.
+ *
+ * @param[in] addr	Address to write (virtual, must be aligned on size)
+ * @param[in] val		Value to write (in PE endianess, i.e BE)
+ * @param[in] size		Number of bytes to write (2 or 4)
+ */
+static void util_pmem_write(u32 val, void *addr, u8 size)
+{
+	void *addr64 = (void *)((unsigned long)addr & ~0x7);
+	unsigned long off = 8 - ((unsigned long)addr & 0x7) - size;
+	
+	//IMEM should  be loaded as a 64bit swapped value in a 64bit aligned location
+	if (size == 4)
+		writel(be32_to_cpu(val), addr64 + off);
+	else
+		writew(be16_to_cpu((u16)val), addr64 + off);
+}
+
+
+/** Writes a buffer to UTIL program memory (DDR) from the host.
+ *
+ * @param[in] dst	Address to write (virtual, must be at least 16bit aligned)
+ * @param[in] src	Buffer to write (in PE endianess, i.e BE, must have same alignment as dst)
+ * @param[in] len	Number of bytes to write (must be at least 16bit aligned)
+ */
+static void util_pmem_memcpy(void *dst, const void *src, unsigned int len)
+{
+	unsigned int len32;
+	int i;
+
+	if ((unsigned long)src & 0x2) {
+		util_pmem_write(*(u16 *)src, dst, 2);
+		src += 2;
+		dst += 2;
+		len -= 2;
+	}
+
+	len32 = len >> 2;
+
+	for (i = 0; i < len32; i++, dst += 4, src += 4)
+		util_pmem_write(*(u32 *)src, dst, 4);
+
+	if (len & 0x2)
+		util_pmem_write(*(u16 *)src, dst, len & 0x2);
+}
+
+
+/** Loads an elf section into pmem
+ * Code needs to be at least 16bit aligned and only PROGBITS sections are supported
+ *
+ * @param[in] id	PE identification (CLASS0_ID, ..., TMU0_ID, ..., TMU3_ID)
+ * @param[in] data	pointer to the elf firmware
+ * @param[in] shdr	pointer to the elf section header
+ *
+ */
+static int pe_load_pmem_section(int id, const void *data, Elf32_Shdr *shdr)
+{
+	u32 offset = be32_to_cpu(shdr->sh_offset);
+	u32 addr = be32_to_cpu(shdr->sh_addr);
+	u32 size = be32_to_cpu(shdr->sh_size);
+	u32 type = be32_to_cpu(shdr->sh_type);
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+	if (id == UTIL_ID)
+	{
+		printf("%s: unsuported pmem section for UTIL\n", __func__);
+		return -1;
+	}
+#endif
+
+	if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3))
+	{
+		printf("%s: load address(%x) and elf file address(%lx) don't have the same alignment\n",
+			__func__, addr, (unsigned long) data + offset);
+
+		return -1;
+	}
+
+	if (addr & 0x1)
+	{
+		printf("%s: load address(%x) is not 16bit aligned\n", __func__, addr);
+		return -1;
+	}
+
+	if (size & 0x1)
+	{
+		printf("%s: load size(%x) is not 16bit aligned\n", __func__, size);
+		return -1;
+	}
+
+		dprintf("pmem pe%d @%x len %d\n",id, addr, size);
+	switch (type)
+        {
+        case SHT_PROGBITS:
+		pe_pmem_memcpy_to32(id, addr, data + offset, size);
+		break;
+
+	default:
+		printf("%s: unsuported section type(%x)\n", __func__, type);
+		return -1;
+		break;
+	}
+
+	return 0;
+}
+
+
+/** Loads an elf section into dmem
+ * Data needs to be at least 32bit aligned, NOBITS sections are correctly initialized to 0
+ *
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
+ * @param[in] data		pointer to the elf firmware
+ * @param[in] shdr		pointer to the elf section header
+ *
+ */
+static int pe_load_dmem_section(int id, const void *data, Elf32_Shdr *shdr)
+{
+	u32 offset = be32_to_cpu(shdr->sh_offset);
+	u32 addr = be32_to_cpu(shdr->sh_addr);
+	u32 size = be32_to_cpu(shdr->sh_size);
+	u32 type = be32_to_cpu(shdr->sh_type);
+	u32 size32 = size >> 2;
+	int i;
+
+	if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3))
+	{
+		printf("%s: load address(%x) and elf file address(%lx) don't have the same alignment\n",
+			__func__, addr, (unsigned long)data + offset);
+
+		return -1;
+	}
+
+	if (addr & 0x3)
+	{
+		printf("%s: load address(%x) is not 32bit aligned\n", __func__, addr);
+		return -1;
+	}
+
+	switch (type)
+        {
+        case SHT_PROGBITS:
+		dprintf("dmem pe%d @%x len %d\n",id, addr, size);
+		pe_dmem_memcpy_to32(id, addr, data + offset, size);
+		break;
+
+	case SHT_NOBITS:
+		dprintf("dmem zero pe%d @%x len %d\n",id, addr, size);
+		for (i = 0; i < size32; i++, addr += 4)
+			pe_dmem_write(id, 0, addr, 4);
+
+		if (size & 0x3)
+			pe_dmem_write(id, 0, addr, size & 0x3);
+
+		break;
+
+	default:
+		printf("%s: unsuported section type(%x)\n", __func__, type);
+		return -1;
+		break;
+	}
+
+	return 0;
+}
+
+
+/** Loads an elf section into DDR
+ * Data needs to be at least 32bit aligned, NOBITS sections are correctly initialized to 0
+ *
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
+ * @param[in] data		pointer to the elf firmware
+ * @param[in] shdr		pointer to the elf section header
+ *
+ */
+static int pe_load_ddr_section(int id, const void *data, Elf32_Shdr *shdr)
+{
+	u32 offset = be32_to_cpu(shdr->sh_offset);
+	u32 addr = be32_to_cpu(shdr->sh_addr);
+	u32 size = be32_to_cpu(shdr->sh_size);
+	u32 type = be32_to_cpu(shdr->sh_type);
+	u32 flags = be32_to_cpu(shdr->sh_flags);
+
+	switch (type)
+	{
+	case SHT_PROGBITS:
+		dprintf("ddr  pe%d @%x len %d\n",id, addr, size);
+		if (flags & SHF_EXECINSTR)
+		{
+			if (id <= CLASS_MAX_ID)
+			{
+				/* DO the loading only once in DDR */
+				if (id == CLASS0_ID)
+				{
+					dprintf("%s: load address(%x) and elf file address(%lx) rcvd\n", __func__, addr, (unsigned long)data + offset);
+					if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3))
+					{
+						printf("%s: load address(%x) and elf file address(%lx) don't have the same alignment\n",
+								__func__, addr, (unsigned long)data + offset);
+
+						return -1;
+					}
+
+					if (addr & 0x1)
+					{
+						printf("%s: load address(%x) is not 16bit aligned\n", __func__, addr);
+						return -1;
+					}
+
+					if (size & 0x1)
+					{
+						printf("%s: load length(%x) is not 16bit aligned\n", __func__, size);
+						return -1;
+					}
+
+					memcpy(DDR_PFE_TO_VIRT(addr), data + offset, size);
+				}
+			}
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+			else if (id == UTIL_ID)
+			{
+				if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3))
+				{
+					printf("%s: load address(%x) and elf file address(%lx) don't have the same alignment\n",
+								__func__, addr, (unsigned long)data + offset);
+
+					return -1;
+				}
+
+				if (addr & 0x1)
+				{
+					printf("%s: load address(%x) is not 16bit aligned\n", __func__, addr);
+					return -1;
+				}
+
+				if (size & 0x1)
+				{
+					printf("%s: load length(%x) is not 16bit aligned\n", __func__, size);
+					return -1;
+				}
+
+				util_pmem_memcpy((void *)DDR_PFE_TO_VIRT(addr), data + offset, size);
+			}
+#endif
+			else
+			{
+				printf("%s: unsuported ddr section type(%x) for PE(%d)\n", __func__, type, id);
+				return -1;
+			}
+
+		}
+		else
+		{
+			memcpy(DDR_PFE_TO_VIRT(addr), data + offset, size);
+		}
+
+		break;
+
+	case SHT_NOBITS:
+		dprintf("ddr zero pe%d @%x len %d\n",id, addr, size);
+		memset((void *)DDR_PFE_TO_VIRT(addr), 0, size);
+
+		break;
+
+	default:
+		printf("%s: unsuported section type(%x)\n", __func__, type);
+		return -1;
+		break;
+	}
+
+	return 0;
+}
+
+/** Loads an elf section into pe lmem
+ * Data needs to be at least 32bit aligned, NOBITS sections are correctly initialized to 0
+ *
+ * @param[in] id		PE identification (CLASS0_ID,..., CLASS5_ID)
+ * @param[in] data		pointer to the elf firmware
+ * @param[in] shdr		pointer to the elf section header
+ *
+ */
+static int pe_load_pe_lmem_section(int id, const void *data, Elf32_Shdr *shdr)
+{
+	u32 offset = be32_to_cpu(shdr->sh_offset);
+	u32 addr = be32_to_cpu(shdr->sh_addr);
+	u32 size = be32_to_cpu(shdr->sh_size);
+	u32 type = be32_to_cpu(shdr->sh_type);
+
+	if (id > CLASS_MAX_ID)
+	{
+		printf("%s: unsuported pe-lmem section type(%x) for PE(%d)\n", __func__, type, id);
+		return -1;
+	}
+	
+	if (((unsigned long)(data + offset) & 0x3) != (addr & 0x3))
+	{
+		printf("%s: load address(%x) and elf file address(%lx) don't have the same alignment\n",
+			__func__, addr, (unsigned long)data + offset);
+
+		return -1;
+	}
+
+	if (addr & 0x3)
+	{
+		printf("%s: load address(%x) is not 32bit aligned\n", __func__, addr);
+		return -1;
+	}
+	dprintf("lmem  pe%d @%x len %d\n",id, addr, size);
+	switch (type)
+	{
+	case SHT_PROGBITS:
+		class_pe_lmem_memcpy_to32(addr, data + offset, size);
+		break;
+
+	case SHT_NOBITS:
+		class_pe_lmem_memset(addr, 0, size);
+		break;
+
+	default:
+		printf("%s: unsuported section type(%x)\n", __func__, type);
+		return -1;
+		break;
+	}
+
+	return 0;
+}
+
+
+/** Loads an elf section into a PE
+ * For now only supports loading a section to dmem (all PE's), pmem (class and tmu PE's),
+ * DDDR (util PE code)
+ *
+ * @param[in] id		PE identification (CLASS0_ID, ..., TMU0_ID, ..., UTIL_ID)
+ * @param[in] data		pointer to the elf firmware
+ * @param[in] shdr		pointer to the elf section header
+ *
+ */
+int pe_load_elf_section(int id, const void *data, Elf32_Shdr *shdr)
+{
+	u32 addr = be32_to_cpu(shdr->sh_addr);
+	u32 size = be32_to_cpu(shdr->sh_size);
+
+	//printf(".");
+	if (IS_DMEM(addr, size))
+		return pe_load_dmem_section(id, data, shdr);
+	else if (IS_PMEM(addr, size))
+		return pe_load_pmem_section(id, data, shdr);
+	else if (IS_PFE_LMEM(addr, size))
+		return 0; /* FIXME */
+	else if (IS_PHYS_DDR(addr, size))
+		return pe_load_ddr_section(id, data, shdr);
+	else if (IS_PE_LMEM(addr, size))
+		return pe_load_pe_lmem_section(id, data, shdr); 
+	else {
+		printf("%s: unsuported memory range(%x)\n", __func__, addr);
+		/*FIXME this should be remove after testing UTIL from 0x20000 */
+		//printf("loading DDR section \n");
+		//return pe_load_ddr_section(id, data, shdr);
+//		return -1;
+	}
+
+	return 0;
+}
+
+/** This function is used to write to UTIL internal bus peripherals from the host
+* through indirect access registers.
+* @param[in]	val	32bits value to write
+* @param[in]	addr	Address to write to
+* @param[in]	size	Number of bytes to write
+*
+*/
+void util_bus_write(u32 val, u32 addr, u8 size)
+{
+	u32 offset = addr & 0x3;
+	u32 access_addr;
+
+	access_addr = ((addr & ~0x3) & CLASS_BUS_ACCESS_ADDR_MASK) | PE_MEM_ACCESS_WRITE | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
+
+//	writel((addr & CLASS_BUS_ACCESS_BASE_MASK), CLASS_BUS_ACCESS_BASE);
+
+	writel(cpu_to_be32(val << (offset << 3)), UTIL_BUS_ACCESS_WDATA);
+	writel(access_addr, UTIL_BUS_ACCESS_ADDR);
+}
+
+
+/** Reads from UTIL internal bus peripherals from the host
+* through indirect access registers.
+* @param[in] addr	Address to read from
+* @param[in] size	Number of bytes to read
+* @return		the read data
+*
+*/
+u32 util_bus_read(u32 addr, u8 size)
+{
+	u32 offset = addr & 0x3;
+	u32 mask = 0xffffffff >> ((4 - size) << 3);
+	u32 access_addr, val;
+
+	access_addr = ((addr & ~0x3) & CLASS_BUS_ACCESS_ADDR_MASK) | PE_MEM_ACCESS_READ | PE_MEM_ACCESS_BYTE_ENABLE(offset, size);
+
+//	writel((addr & CLASS_BUS_ACCESS_BASE_MASK), CLASS_BUS_ACCESS_BASE);
+
+	writel(access_addr, UTIL_BUS_ACCESS_ADDR);
+	val = be32_to_cpu(readl(UTIL_BUS_ACCESS_RDATA));
+
+	return (val >> (offset << 3)) & mask;
+}
+
+
+
+/**************************** BMU ***************************/
+
+/** Initializes a BMU block.
+* @param[in] base	BMU block base address
+* @param[in] cfg	BMU configuration
+*/
+void bmu_init(void *base, BMU_CFG *cfg)
+{
+
+	bmu_disable(base);
+
+	bmu_set_config(base, cfg);
+
+	bmu_reset(base);
+}
+
+/** Resets a BMU block.
+* @param[in] base	BMU block base address
+*/
+void bmu_reset(void *base)
+{
+	writel(CORE_SW_RESET, base + BMU_CTRL);
+
+	/* Wait for self clear */
+	while (readl(base + BMU_CTRL) & CORE_SW_RESET) ;
+}
+
+/** Enabled a BMU block.
+* @param[in] base	BMU block base address
+*/
+void bmu_enable(void *base)
+{
+	writel (CORE_ENABLE, base + BMU_CTRL);
+}
+
+/** Disables a BMU block.
+* @param[in] base	BMU block base address
+*/
+void bmu_disable(void *base)
+{
+	writel (CORE_DISABLE, base + BMU_CTRL);
+}
+
+/** Sets the configuration of a BMU block.
+* @param[in] base	BMU block base address
+* @param[in] cfg	BMU configuration
+*/
+void bmu_set_config(void *base, BMU_CFG *cfg)
+{	
+	writel (cfg->baseaddr, base + BMU_UCAST_BASE_ADDR);
+	writel (cfg->count & 0xffff, base + BMU_UCAST_CONFIG);
+	writel (cfg->size & 0xffff, base + BMU_BUF_SIZE);
+//	writel (BMU1_THRES_CNT, base + BMU_THRES);
+
+	/* Interrupts are never used */
+//	writel (0x0, base + BMU_INT_SRC);
+	writel (0x0, base + BMU_INT_ENABLE);
+}
+
+
+#if 0 //These are LS1012A functions
+/**************************** GEMAC ***************************/
+
+/** GEMAC block initialization.
+* @param[in] base	GEMAC base address (GEMAC0, GEMAC1, GEMAC2)
+* @param[in] cfg	GEMAC configuration
+*/
+void gemac_init(void *base, void *cfg)
+{
+	gemac_set_config(base, cfg);
+	gemac_set_bus_width(base, 64);
+}
+
+/** GEMAC set speed.
+* @param[in] base	GEMAC base address
+* @param[in] speed	GEMAC speed (10, 100 or 1000 Mbps)
+*/
+void gemac_set_speed(void *base, MAC_SPEED gem_speed)
+{
+	u32 val = readl(base + EMAC_NETWORK_CONFIG);
+
+	val = val & ~EMAC_SPEED_MASK;
+
+	switch (gem_speed)
+	{
+		case SPEED_10M:
+			val &= (~EMAC_PCS_ENABLE);
+			break;
+
+		case SPEED_100M:
+			val = val | EMAC_SPEED_100;
+			val &= (~EMAC_PCS_ENABLE);
+			break;
+
+		case SPEED_1000M:
+			val = val | EMAC_SPEED_1000;
+			val &= (~EMAC_PCS_ENABLE);
+			break;
+
+		case SPEED_1000M_PCS:
+			val = val | EMAC_SPEED_1000;
+			val |= EMAC_PCS_ENABLE;
+			break;
+
+		default:
+			val = val | EMAC_SPEED_100;
+			val &= (~EMAC_PCS_ENABLE);
+		break;
+	}
+	
+	writel (val, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC set duplex.
+* @param[in] base	GEMAC base address
+* @param[in] duplex	GEMAC duplex mode (Full, Half)
+*/
+void gemac_set_duplex(void *base, int duplex)
+{
+	u32 val = readl(base + EMAC_NETWORK_CONFIG);
+
+	if (duplex == DUPLEX_HALF)
+		val = (val & ~EMAC_DUPLEX_MASK) | EMAC_HALF_DUP;
+	else
+		val = (val & ~EMAC_DUPLEX_MASK) | EMAC_FULL_DUP;
+  
+	writel (val, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC set mode.
+* @param[in] base	GEMAC base address
+* @param[in] mode	GEMAC operation mode (MII, RMII, RGMII, SGMII)
+*/
+void gemac_set_mode(void *base, int mode)
+{
+	switch (mode)
+	{
+	case GMII:
+		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | EMAC_GMII_MODE_ENABLE, base + EMAC_CONTROL);
+		writel (readl(base + EMAC_NETWORK_CONFIG) & (~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
+		break;
+
+	case RGMII:
+		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | EMAC_RGMII_MODE_ENABLE, base + EMAC_CONTROL);
+		writel (readl(base + EMAC_NETWORK_CONFIG) & (~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
+		break;
+
+	case RMII:
+		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | EMAC_RMII_MODE_ENABLE, base + EMAC_CONTROL);
+		writel (readl(base + EMAC_NETWORK_CONFIG) & (~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
+		break;
+
+	case MII:
+		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | EMAC_MII_MODE_ENABLE, base + EMAC_CONTROL);
+		writel (readl(base + EMAC_NETWORK_CONFIG) & (~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
+		break;
+
+	case SGMII:
+		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | (EMAC_RMII_MODE_DISABLE | EMAC_RGMII_MODE_DISABLE), base + EMAC_CONTROL);
+		writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_SGMII_MODE_ENABLE, base + EMAC_NETWORK_CONFIG);
+		break;
+
+	default:
+		writel ((readl(base + EMAC_CONTROL) & ~EMAC_MODE_MASK) | EMAC_MII_MODE_ENABLE, base + EMAC_CONTROL);
+		writel (readl(base + EMAC_NETWORK_CONFIG) & (~EMAC_SGMII_MODE_ENABLE), base + EMAC_NETWORK_CONFIG);
+		break;
+	}
+}
+
+/** GEMAC Enable MDIO: Activate the Management interface.  This is required to program the PHY
+ * @param[in] base       GEMAC base address
+ */
+void gemac_enable_mdio(void *base)
+{
+        u32 data;
+
+        data = readl(base + EMAC_NETWORK_CONTROL);
+        data |= EMAC_MDIO_EN;
+        writel(data, base + EMAC_NETWORK_CONTROL);
+}
+
+/** GEMAC Disable MDIO: Disable the Management interface.
+ * @param[in] base       GEMAC base address
+ */
+void gemac_disable_mdio(void *base)
+{
+        u32 data;
+
+        data = readl(base + EMAC_NETWORK_CONTROL);
+        data &= ~EMAC_MDIO_EN;
+        writel(data, base + EMAC_NETWORK_CONTROL);
+}
+
+/** GEMAC Set MDC clock division
+ * @param[in] base       GEMAC base address
+ * @param[in] base       MDC divider value
+ */
+void gemac_set_mdc_div(void *base, MAC_MDC_DIV gem_mdcdiv)
+{
+        u32 data;
+
+        data = readl(base + EMAC_NETWORK_CONFIG);
+	data &= ~(MDC_DIV_MASK << MDC_DIV_SHIFT);
+        data |= (gem_mdcdiv & MDC_DIV_MASK) << MDC_DIV_SHIFT;
+        writel(data, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC reset function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_reset(void *base)
+{  
+}
+
+/** GEMAC enable function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_enable(void *base)
+{  
+	writel (readl(base + EMAC_NETWORK_CONTROL) | EMAC_TX_ENABLE | EMAC_RX_ENABLE, base + EMAC_NETWORK_CONTROL);
+}
+
+/** GEMAC disable function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_disable(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONTROL) & ~(EMAC_TX_ENABLE | EMAC_RX_ENABLE), base + EMAC_NETWORK_CONTROL);
+}
+
+/** GEMAC set mac address configuration.
+* @param[in] base	GEMAC base address
+* @param[in] addr	MAC address to be configured
+*/
+void gemac_set_address(void *base, SPEC_ADDR *addr)
+{ 
+	writel(addr->one.bottom,	base + EMAC_SPEC1_ADD_BOT);
+	writel(addr->one.top,		base + EMAC_SPEC1_ADD_TOP); 
+	writel(addr->two.bottom,	base + EMAC_SPEC2_ADD_BOT);
+	writel(addr->two.top,		base + EMAC_SPEC2_ADD_TOP);
+	writel(addr->three.bottom,	base + EMAC_SPEC3_ADD_BOT);
+	writel(addr->three.top,		base + EMAC_SPEC3_ADD_TOP);
+	writel(addr->four.bottom,	base + EMAC_SPEC4_ADD_BOT);
+	writel(addr->four.top,		base + EMAC_SPEC4_ADD_TOP);
+} 
+
+/** GEMAC get mac address configuration.
+* @param[in] base	GEMAC base address
+*
+* @return		MAC addresses configured
+*/
+SPEC_ADDR gemac_get_address(void *base)
+{
+	SPEC_ADDR addr;
+	
+	addr.one.bottom = 	readl(base + EMAC_SPEC1_ADD_BOT);
+	addr.one.top = 		readl(base + EMAC_SPEC1_ADD_TOP); 
+	addr.two.bottom =	readl(base + EMAC_SPEC2_ADD_BOT);
+	addr.two.top =		readl(base + EMAC_SPEC2_ADD_TOP);
+	addr.three.bottom =	readl(base + EMAC_SPEC3_ADD_BOT);
+	addr.three.top =	readl(base + EMAC_SPEC3_ADD_TOP);
+	addr.four.bottom =	readl(base + EMAC_SPEC4_ADD_BOT);
+	addr.four.top =		readl(base + EMAC_SPEC4_ADD_TOP);
+	
+	return addr;
+}
+
+/** GEMAC set specific local addresses of the MAC.
+* Rather than setting up all four specific addresses, this function sets them up individually.
+*
+* @param[in] base	GEMAC base address
+* @param[in] addr	MAC address to be configured
+*/
+void gemac_set_laddr1(void *base, MAC_ADDR *address)
+{
+	writel(address->bottom,		base + EMAC_SPEC1_ADD_BOT);
+	writel(address->top,		base + EMAC_SPEC1_ADD_TOP); 
+}
+
+
+void gemac_set_laddr2(void *base, MAC_ADDR *address)
+{
+	writel(address->bottom,		base + EMAC_SPEC2_ADD_BOT);
+	writel(address->top,		base + EMAC_SPEC2_ADD_TOP); 
+}
+
+
+void gemac_set_laddr3(void *base, MAC_ADDR *address)
+{
+	writel(address->bottom,		base + EMAC_SPEC3_ADD_BOT);
+	writel(address->top,		base + EMAC_SPEC3_ADD_TOP); 
+}
+
+
+void gemac_set_laddr4(void *base, MAC_ADDR *address)
+{
+	writel(address->bottom,		base + EMAC_SPEC4_ADD_BOT);
+	writel(address->top,		base + EMAC_SPEC4_ADD_TOP); 
+}
+
+void gemac_set_laddrN(void *base, MAC_ADDR *address, unsigned int entry_index)
+{
+	if (entry_index < 5)
+	{	
+		writel(address->bottom,		base + (entry_index * 8) + EMAC_SPEC1_ADD_BOT);
+		writel(address->top,		base + (entry_index * 8) + EMAC_SPEC1_ADD_TOP);
+	} 
+	else 
+	{
+		writel(address->bottom,		base + ((entry_index - 5) * 8) + EMAC_SPEC5_ADD_BOT);
+		writel(address->top,		base + ((entry_index - 5) * 8) + EMAC_SPEC5_ADD_TOP);
+	}
+}
+
+/** Get specific local addresses of the MAC.
+* This allows returning of a single specific address stored in the MAC.
+* @param[in] base	GEMAC base address
+*
+* @return		Specific MAC address 1
+* 
+*/
+MAC_ADDR gem_get_laddr1(void *base)
+{
+	MAC_ADDR addr;
+	addr.bottom = readl(base + EMAC_SPEC1_ADD_BOT);
+	addr.top = readl(base + EMAC_SPEC1_ADD_TOP);
+	return addr;
+}
+
+
+MAC_ADDR gem_get_laddr2(void *base)
+{
+	MAC_ADDR addr;
+	addr.bottom = readl(base + EMAC_SPEC2_ADD_BOT);
+	addr.top = readl(base + EMAC_SPEC2_ADD_TOP);
+	return addr;
+}
+
+
+MAC_ADDR gem_get_laddr3(void *base)
+{
+	MAC_ADDR addr;
+	addr.bottom = readl(base + EMAC_SPEC3_ADD_BOT);
+	addr.top = readl(base + EMAC_SPEC3_ADD_TOP);
+	return addr;
+}
+
+
+MAC_ADDR gem_get_laddr4(void *base)
+{
+	MAC_ADDR addr;
+	addr.bottom = readl(base + EMAC_SPEC4_ADD_BOT);
+	addr.top = readl(base + EMAC_SPEC4_ADD_TOP);
+	return addr;
+}
+
+
+MAC_ADDR gem_get_laddrN(void *base, unsigned int entry_index)
+{
+	MAC_ADDR addr;
+
+	if (entry_index < 5)
+	{
+		addr.bottom = readl(base + (entry_index * 8) + EMAC_SPEC1_ADD_BOT);
+		addr.top = readl(base + (entry_index * 8) + EMAC_SPEC1_ADD_TOP);
+	}
+	else
+	{
+		addr.bottom = readl(base + ((entry_index - 5) * 8) + EMAC_SPEC5_ADD_BOT);
+		addr.top = readl(base + ((entry_index - 5) * 8) + EMAC_SPEC5_ADD_TOP);
+	}
+
+	return addr;
+}
+
+/** GEMAC allow frames
+* @param[in] base	GEMAC base address
+*/
+void gemac_enable_copy_all(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & EMAC_ENABLE_COPY_ALL, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC do not allow frames
+* @param[in] base	GEMAC base address
+*/
+void gemac_disable_copy_all(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_COPY_ALL, base + EMAC_NETWORK_CONFIG);
+}
+
+
+
+/** GEMAC allow broadcast function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_allow_broadcast(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_NO_BROADCAST, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC no broadcast function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_no_broadcast(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_NO_BROADCAST, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC enable unicast function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_enable_unicast(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_UNICAST, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC disable unicast function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_disable_unicast(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_UNICAST, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC enable multicast function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_enable_multicast(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_MULTICAST, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC disable multicast function.
+* @param[in]	base	GEMAC base address
+*/
+void gemac_disable_multicast(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_MULTICAST, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC enable fcs rx function.
+* @param[in]	base	GEMAC base address
+*/
+void gemac_enable_fcs_rx(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_FCS_RX, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC disable fcs rx function.
+* @param[in]	base	GEMAC base address
+*/
+void gemac_disable_fcs_rx(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_FCS_RX, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC enable 1536 rx function.
+* @param[in]	base	GEMAC base address
+*/
+void gemac_enable_1536_rx(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_1536_RX, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC disable 1536 rx function.
+* @param[in]	base	GEMAC base address
+*/
+void gemac_disable_1536_rx(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_1536_RX, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC enable pause rx function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_enable_pause_rx(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_PAUSE_RX, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC disable pause rx function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_disable_pause_rx(void *base)
+{
+	writel (readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_PAUSE_RX, base + EMAC_NETWORK_CONFIG);
+}
+
+/** GEMAC enable rx checksum offload function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_enable_rx_checksum_offload(void *base)
+{
+	writel(readl(base + EMAC_NETWORK_CONFIG) | EMAC_ENABLE_CHKSUM_RX, base + EMAC_NETWORK_CONFIG);
+	writel(readl(CLASS_L4_CHKSUM_ADDR) | IPV4_CHKSUM_DROP, CLASS_L4_CHKSUM_ADDR);
+}
+
+/** GEMAC disable rx checksum offload function.
+* @param[in] base	GEMAC base address
+*/
+void gemac_disable_rx_checksum_offload(void *base)
+{
+	writel(readl(base + EMAC_NETWORK_CONFIG) & ~EMAC_ENABLE_CHKSUM_RX, base + EMAC_NETWORK_CONFIG);
+	writel(readl(CLASS_L4_CHKSUM_ADDR) & ~IPV4_CHKSUM_DROP, CLASS_L4_CHKSUM_ADDR);
+}
+
+/** Sets Gemac bus width to 64bit
+ * @param[in] base       GEMAC base address
+ * @param[in] width	gemac bus width to be set possible values are 32/64/128
+ * */
+void gemac_set_bus_width(void *base, int width)
+{
+	u32 val = readl(base + EMAC_NETWORK_CONFIG);
+	switch(width) 
+	{
+	case 32:
+		val = (val & ~EMAC_DATA_BUS_WIDTH_MASK) | EMAC_DATA_BUS_WIDTH_32;
+	case 128:
+		val = (val & ~EMAC_DATA_BUS_WIDTH_MASK) | EMAC_DATA_BUS_WIDTH_128;
+	case 64:
+	default:
+		val = (val & ~EMAC_DATA_BUS_WIDTH_MASK) | EMAC_DATA_BUS_WIDTH_64;
+
+	}
+	writel (val, base + EMAC_NETWORK_CONFIG);
+}
+
+/** Sets Gemac configuration.
+* @param[in] base	GEMAC base address
+* @param[in] cfg	GEMAC configuration
+*/
+void gemac_set_config(void *base, GEMAC_CFG *cfg)
+{
+	gemac_set_mode(base, cfg->mode);
+
+	gemac_set_speed(base, cfg->speed);
+
+	gemac_set_duplex(base,cfg->duplex);
+}
+#endif
+
+/**************************** GPI ***************************/
+
+/** Initializes a GPI block.
+* @param[in] base	GPI base address
+* @param[in] cfg	GPI configuration
+*/
+void gpi_init(void *base, GPI_CFG *cfg)
+{ 
+	gpi_reset(base);
+	
+	gpi_disable(base);
+	
+	gpi_set_config(base, cfg);
+}
+
+/** Resets a GPI block.
+* @param[in] base	GPI base address
+*/
+void gpi_reset(void *base)
+{
+	writel (CORE_SW_RESET, base + GPI_CTRL);
+}
+
+/** Enables a GPI block.
+* @param[in] base	GPI base address
+*/
+void gpi_enable(void *base)
+{
+	writel (CORE_ENABLE, base + GPI_CTRL);
+}
+
+/** Disables a GPI block.
+* @param[in] base	GPI base address
+*/
+void gpi_disable(void *base)
+{
+	writel (CORE_DISABLE, base + GPI_CTRL);
+}
+
+
+/** Sets the configuration of a GPI block.
+* @param[in] base	GPI base address
+* @param[in] cfg	GPI configuration
+*/
+void gpi_set_config(void *base, GPI_CFG *cfg)
+{  
+	writel (CBUS_VIRT_TO_PFE(BMU1_BASE_ADDR + BMU_ALLOC_CTRL),	base + GPI_LMEM_ALLOC_ADDR);
+	writel (CBUS_VIRT_TO_PFE(BMU1_BASE_ADDR + BMU_FREE_CTRL),	base + GPI_LMEM_FREE_ADDR);
+	writel (CBUS_VIRT_TO_PFE(BMU2_BASE_ADDR + BMU_ALLOC_CTRL),	base + GPI_DDR_ALLOC_ADDR);
+	writel (CBUS_VIRT_TO_PFE(BMU2_BASE_ADDR + BMU_FREE_CTRL),	base + GPI_DDR_FREE_ADDR);
+	writel (CBUS_VIRT_TO_PFE(CLASS_INQ_PKTPTR),			base + GPI_CLASS_ADDR);
+ 	writel (DDR_HDR_SIZE,						base + GPI_DDR_DATA_OFFSET);
+	writel (LMEM_HDR_SIZE,						base + GPI_LMEM_DATA_OFFSET);
+	writel (0,							base + GPI_LMEM_SEC_BUF_DATA_OFFSET);
+	writel (0,							base + GPI_DDR_SEC_BUF_DATA_OFFSET);
+	writel ((DDR_HDR_SIZE << 16) | LMEM_HDR_SIZE,			base + GPI_HDR_SIZE);
+	writel ((DDR_BUF_SIZE << 16) | LMEM_BUF_SIZE,			base + GPI_BUF_SIZE);
+	
+	writel (((cfg->lmem_rtry_cnt << 16) | (GPI_DDR_BUF_EN << 1) | GPI_LMEM_BUF_EN),	base + GPI_RX_CONFIG);
+	writel (cfg->tmlf_txthres,					base + GPI_TMLF_TX);
+	writel (cfg->aseq_len,						base + GPI_DTX_ASEQ);
+}
+
+/**************************** CLASSIFIER ***************************/
+
+/** Initializes CLASSIFIER block.
+* @param[in] cfg	CLASSIFIER configuration
+*/
+void class_init(CLASS_CFG *cfg)
+{
+	class_reset();
+	
+	class_disable();
+	
+	class_set_config(cfg);
+}
+
+/** Resets CLASSIFIER block.
+*
+*/
+void class_reset(void)
+{
+	writel(CORE_SW_RESET, CLASS_TX_CTRL);
+}
+
+/** Enables all CLASS-PE's cores.
+*
+*/
+void class_enable(void)
+{
+	writel(CORE_ENABLE, CLASS_TX_CTRL);
+}
+
+/** Disables all CLASS-PE's cores.
+*
+*/
+void class_disable(void)
+{
+	writel(CORE_DISABLE, CLASS_TX_CTRL); 
+}
+
+/** Sets the configuration of the CLASSIFIER block.
+* @param[in] cfg	CLASSIFIER configuration
+*/
+void class_set_config(CLASS_CFG *cfg)
+{
+	if (PLL_CLK_EN == 0)
+		writel(0x0,     CLASS_PE_SYS_CLK_RATIO);        // Clock ratio: for 1:1 the value is 0
+	else
+		writel(0x1,     CLASS_PE_SYS_CLK_RATIO);        // Clock ratio: for 1:2 the value is 1
+
+	writel((DDR_HDR_SIZE << 16) | LMEM_HDR_SIZE,	CLASS_HDR_SIZE);
+	writel(LMEM_BUF_SIZE,				CLASS_LMEM_BUF_SIZE);
+	writel(CLASS_ROUTE_ENTRY_SIZE(CLASS_ROUTE_SIZE) | CLASS_ROUTE_HASH_SIZE(cfg->route_table_hash_bits),	CLASS_ROUTE_HASH_ENTRY_SIZE);
+	writel(HASH_CRC_PORT_IP | QB2BUS_LE, CLASS_ROUTE_MULTI);
+
+	writel(cfg->route_table_baseaddr,		CLASS_ROUTE_TABLE_BASE);
+	memset((void *)DDR_PFE_TO_VIRT(cfg->route_table_baseaddr), 0, ROUTE_TABLE_SIZE);
+
+	writel(CLASS_PE0_RO_DM_ADDR0_VAL,		CLASS_PE0_RO_DM_ADDR0);
+	writel(CLASS_PE0_RO_DM_ADDR1_VAL,		CLASS_PE0_RO_DM_ADDR1);
+	writel(CLASS_PE0_QB_DM_ADDR0_VAL,		CLASS_PE0_QB_DM_ADDR0);
+	writel(CLASS_PE0_QB_DM_ADDR1_VAL,		CLASS_PE0_QB_DM_ADDR1);
+	writel(CBUS_VIRT_TO_PFE(TMU_PHY_INQ_PKTPTR),	CLASS_TM_INQ_ADDR);
+
+	writel(23, CLASS_AFULL_THRES);
+	writel(23, CLASS_TSQ_FIFO_THRES);
+
+	writel(24, CLASS_MAX_BUF_CNT);
+	writel(24, CLASS_TSQ_MAX_CNT);
+	//writel(1, CLASS_USE_TMU_INQ);
+}
+
+/**************************** TMU ***************************/
+
+void tmu_reset(void)
+{
+	writel(SW_RESET, TMU_CTRL);
+}
+
+/** Initializes TMU block.
+* @param[in] cfg	TMU configuration
+*/
+void tmu_init(TMU_CFG *cfg)
+{
+	int q, phyno;
+
+	/* keep in soft reset */
+	writel(SW_RESET,                     TMU_CTRL);
+
+	/* enable EMAC PHY ports */
+	writel(0x3,						TMU_SYS_GENERIC_CONTROL);
+
+	writel(750,						TMU_INQ_WATERMARK);
+	writel(CBUS_VIRT_TO_PFE(EGPI1_BASE_ADDR + GPI_INQ_PKTPTR),	TMU_PHY0_INQ_ADDR);
+	writel(CBUS_VIRT_TO_PFE(EGPI2_BASE_ADDR + GPI_INQ_PKTPTR),	TMU_PHY1_INQ_ADDR);
+#if !defined(CONFIG_LS1012A)
+	writel(CBUS_VIRT_TO_PFE(EGPI3_BASE_ADDR + GPI_INQ_PKTPTR),	TMU_PHY2_INQ_ADDR);
+#endif
+	writel(CBUS_VIRT_TO_PFE(HGPI_BASE_ADDR + GPI_INQ_PKTPTR),	TMU_PHY3_INQ_ADDR);
+	writel(CBUS_VIRT_TO_PFE(HIF_NOCPY_RX_INQ0_PKTPTR),		TMU_PHY4_INQ_ADDR);
+	writel(CBUS_VIRT_TO_PFE(UTIL_INQ_PKTPTR),			TMU_PHY5_INQ_ADDR);
+	writel(CBUS_VIRT_TO_PFE(BMU2_BASE_ADDR + BMU_FREE_CTRL), 	TMU_BMU_INQ_ADDR);
+
+	writel(0x3FF,	TMU_TDQ0_SCH_CTRL);	// enabling all 10 schedulers [9:0] of each TDQ 
+	writel(0x3FF,	TMU_TDQ1_SCH_CTRL);
+#if !defined(CONFIG_LS1012A)
+	writel(0x3FF,	TMU_TDQ2_SCH_CTRL);
+#endif
+	writel(0x3FF,	TMU_TDQ3_SCH_CTRL);
+	
+	
+	if (PLL_CLK_EN == 0)
+		writel(0x0,	TMU_PE_SYS_CLK_RATIO);	// Clock ratio: for 1:1 the value is 0
+	else
+		writel(0x1,	TMU_PE_SYS_CLK_RATIO);	// Clock ratio: for 1:2 the value is 1
+
+	//printf("TMU_LLM_BASE_ADDR %x\n", cfg->llm_base_addr);
+	writel(cfg->llm_base_addr,	TMU_LLM_BASE_ADDR);	// Extra packet pointers will be stored from this address onwards
+	
+	//printf("TMU_LLM_QUE_LEN %x\n", cfg->llm_queue_len);
+	writel(cfg->llm_queue_len,	TMU_LLM_QUE_LEN);
+	writel(5,			TMU_TDQ_IIFG_CFG);
+	writel(DDR_BUF_SIZE,		TMU_BMU_BUF_SIZE);
+
+	writel(0x0,			TMU_CTRL);
+
+	/* MEM init */
+	//printf("%s: mem init\n", __func__);
+	writel(MEM_INIT,	TMU_CTRL);
+
+	while(!(readl(TMU_CTRL) & MEM_INIT_DONE)) 
+	;
+
+	/* LLM init */
+	//printf("%s: lmem init\n", __func__);
+	writel(LLM_INIT,	TMU_CTRL);
+
+	while(!(readl(TMU_CTRL) & LLM_INIT_DONE)) 
+	;
+
+	// set up each queue for tail drop
+	for (phyno = 0; phyno < 4; phyno++)
+	{
+#if !defined(CONFIG_LS1012A)
+		if(phyno = 2) continue;
+#endif
+		for (q = 0; q < 16; q++)
+		{
+			u32 qmax;
+			writel((phyno << 8) | q, TMU_TEQ_CTRL);
+			writel(1 << 22, TMU_TEQ_QCFG);
+			qmax = ((phyno == 3) || (q < 8)) ? 255 : 127;
+			writel(qmax << 18, TMU_TEQ_HW_PROB_CFG2);
+			writel(qmax >> 14, TMU_TEQ_HW_PROB_CFG3);
+		}
+	}
+	writel(0x05, TMU_TEQ_DISABLE_DROPCHK);
+	writel(0,	TMU_CTRL);
+}
+
+/** Enables TMU-PE cores.
+* @param[in] pe_mask	TMU PE mask
+*/
+void tmu_enable(u32 pe_mask)
+{
+	writel(readl(TMU_TX_CTRL) | (pe_mask & 0xF), TMU_TX_CTRL);
+}
+
+/** Disables TMU cores.
+* @param[in] pe_mask	TMU PE mask
+*/
+void tmu_disable(u32 pe_mask)
+{
+	writel(readl(TMU_TX_CTRL) & ~(pe_mask & 0xF), TMU_TX_CTRL);
+}
+
+/**************************** UTIL ***************************/
+
+/** Resets UTIL block.
+*/
+void util_reset(void)
+{
+	writel(CORE_SW_RESET, UTIL_TX_CTRL);
+}
+
+/** Initializes UTIL block.
+* @param[in] cfg	UTIL configuration
+*/
+void util_init(UTIL_CFG *cfg)
+{
+
+	//writel(0x1, UTIL_MISC_REG);
+
+	if (PLL_CLK_EN == 0)
+		writel(0x0,     UTIL_PE_SYS_CLK_RATIO);        // Clock ratio: for 1:1 the value is 0
+	else
+		writel(0x1,     UTIL_PE_SYS_CLK_RATIO);        // Clock ratio: for 1:2 the value is 1
+}
+
+/** Enables UTIL-PE core.
+*
+*/
+void util_enable(void)
+{
+	writel(CORE_ENABLE, UTIL_TX_CTRL);
+}
+
+/** Disables UTIL-PE core.
+*
+*/
+void util_disable(void)
+{
+	writel(CORE_DISABLE, UTIL_TX_CTRL);
+}
+
+#if 0
+/** GEMAC PHY Statistics - This function return address of the first statistics register
+* @param[in]	base	GEMAC base address 
+*/
+unsigned int * gemac_get_stats(void *base)
+{
+	return (unsigned int *)(base + EMAC_OCT_TX_BOT);
+}
+#endif
+
+/**************************** HIF ***************************/
+
+/** Initializes HIF no copy block.
+*
+*/
+void hif_nocpy_init(void)
+{
+	writel(4,							HIF_NOCPY_TX_PORT_NO);
+	writel(CBUS_VIRT_TO_PFE(BMU1_BASE_ADDR + BMU_ALLOC_CTRL),		HIF_NOCPY_LMEM_ALLOC_ADDR);
+	writel(CBUS_VIRT_TO_PFE(CLASS_INQ_PKTPTR),	HIF_NOCPY_CLASS_ADDR);
+	writel(CBUS_VIRT_TO_PFE(TMU_PHY_INQ_PKTPTR),	HIF_NOCPY_TMU_PORT0_ADDR);
+}
+
+/** Initializes HIF copy block.
+*
+*/
+void hif_init(void)
+{
+	/*Initialize HIF registers*/
+	writel(HIF_RX_POLL_CTRL_CYCLE<<16|HIF_TX_POLL_CTRL_CYCLE, HIF_POLL_CTRL); 
+}
+
+/** Enable hif tx DMA and interrupt
+*
+*/
+void hif_tx_enable(void)
+{
+	/*TODO not sure poll_cntrl_en is required or not */
+	writel( HIF_CTRL_DMA_EN, HIF_TX_CTRL);
+	//writel((readl(HIF_INT_ENABLE) | HIF_INT_EN | HIF_TXPKT_INT_EN), HIF_INT_ENABLE);
+}
+
+/** Disable hif tx DMA and interrupt
+*
+*/
+void hif_tx_disable(void)
+{
+	u32	hif_int;
+
+	writel(0, HIF_TX_CTRL);
+
+	hif_int = readl(HIF_INT_ENABLE);
+	hif_int &= HIF_TXPKT_INT_EN;
+	writel(hif_int, HIF_INT_ENABLE);
+}
+
+/** Enable hif rx DMA and interrupt
+*
+*/
+void hif_rx_enable(void)
+{
+	/*TODO not sure poll_cntrl_en is required or not */
+	writel((HIF_CTRL_DMA_EN | HIF_CTRL_BDP_CH_START_WSTB), HIF_RX_CTRL);
+	//writel((readl(HIF_INT_ENABLE) | HIF_INT_EN | HIF_RXPKT_INT_EN), HIF_INT_ENABLE);
+}
+
+/** Disable hif rx DMA and interrupt
+*
+*/
+void hif_rx_disable(void)
+{
+	u32	hif_int;
+
+	writel(0, HIF_RX_CTRL);
+
+	hif_int = readl(HIF_INT_ENABLE);
+	hif_int &= HIF_RXPKT_INT_EN;
+	writel(hif_int, HIF_INT_ENABLE);
+
+}
diff --git a/drivers/net/pfe_eth/pfe/cbus.h b/drivers/net/pfe_eth/pfe/cbus.h
new file mode 100644
index 0000000..778fe45
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/cbus.h
@@ -0,0 +1,74 @@
+#ifndef _CBUS_H_
+#define _CBUS_H_
+
+#define EMAC1_BASE_ADDR		(CBUS_BASE_ADDR + 0x200000)
+#define EGPI1_BASE_ADDR		(CBUS_BASE_ADDR + 0x210000)
+#define EMAC2_BASE_ADDR		(CBUS_BASE_ADDR + 0x220000)
+#define EGPI2_BASE_ADDR		(CBUS_BASE_ADDR + 0x230000)
+#define BMU1_BASE_ADDR		(CBUS_BASE_ADDR + 0x240000)
+#define BMU2_BASE_ADDR		(CBUS_BASE_ADDR + 0x250000)
+#define ARB_BASE_ADDR		(CBUS_BASE_ADDR + 0x260000) /* FIXME not documented */
+#define DDR_CONFIG_BASE_ADDR	(CBUS_BASE_ADDR + 0x270000) /* FIXME not documented */
+#define HIF_BASE_ADDR		(CBUS_BASE_ADDR + 0x280000)
+#define HGPI_BASE_ADDR		(CBUS_BASE_ADDR + 0x290000)
+#define LMEM_BASE_ADDR		(CBUS_BASE_ADDR + 0x300000)
+#define LMEM_SIZE		0x10000
+#define LMEM_END		(LMEM_BASE_ADDR + LMEM_SIZE)
+#define TMU_CSR_BASE_ADDR	(CBUS_BASE_ADDR + 0x310000)
+#define CLASS_CSR_BASE_ADDR	(CBUS_BASE_ADDR + 0x320000)
+#if !defined(CONFIG_LS1012A)
+#define EMAC3_BASE_ADDR		(CBUS_BASE_ADDR + 0x330000)
+#define EGPI3_BASE_ADDR		(CBUS_BASE_ADDR + 0x340000)
+#endif
+#define HIF_NOCPY_BASE_ADDR	(CBUS_BASE_ADDR + 0x350000)
+#define UTIL_CSR_BASE_ADDR	(CBUS_BASE_ADDR + 0x360000)
+#define CBUS_GPT_BASE_ADDR	(CBUS_BASE_ADDR + 0x370000)
+
+#define IS_LMEM(addr, len)	(((unsigned long)(addr) >= LMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= LMEM_END))
+
+/** 
+* \defgroup XXX_MEM_ACCESS_ADDR PE memory access through CSR 
+* XXX_MEM_ACCESS_ADDR register bit definitions. 
+* @{
+*/
+#define PE_MEM_ACCESS_WRITE		(1<<31)			/**< Internal Memory Write. */
+#define PE_MEM_ACCESS_READ		(0<<31)			/**< Internal Memory Read. */
+#define PE_MEM_ACCESS_IMEM		(1<<15)
+#define PE_MEM_ACCESS_DMEM		(1<<16)
+#define PE_MEM_ACCESS_BYTE_ENABLE(offset,size)	(((((1 << (size)) - 1) << (4 - (offset) - (size))) & 0xf) << 24)	/**< Byte Enables of the Internal memory access. These are interpred in BE */
+// @}
+#include "cbus/emac.h"
+#include "cbus/gpi.h"
+#include "cbus/bmu.h"
+#include "cbus/hif.h"
+#include "cbus/tmu_csr.h"
+#include "cbus/class_csr.h"
+#include "cbus/hif_nocpy.h"
+#include "cbus/util_csr.h"
+#include "cbus/gpt.h"
+
+
+/* PFE cores states */
+#define CORE_DISABLE	0x00000000 
+#define CORE_ENABLE	0x00000001
+#define CORE_SW_RESET	0x00000002
+
+/* LMEM defines */
+#define LMEM_HDR_SIZE		0x0010
+#define LMEM_BUF_SIZE_LN2	0x7
+#define LMEM_BUF_SIZE		(1 << LMEM_BUF_SIZE_LN2)
+
+/* DDR defines */
+#define DDR_HDR_SIZE		0x0100
+#define DDR_BUF_SIZE_LN2	0xb
+#define DDR_BUF_SIZE		(1 << DDR_BUF_SIZE_LN2)
+
+
+/* Clock generation through PLL */
+#if defined(CONFIG_PLATFORM_PCI)
+#define PLL_CLK_EN	0
+#else
+#define PLL_CLK_EN	1
+#endif
+
+#endif /* _CBUS_H_ */
diff --git a/drivers/net/pfe_eth/pfe/cbus/bmu.h b/drivers/net/pfe_eth/pfe/cbus/bmu.h
new file mode 100644
index 0000000..f3e5e6d
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/cbus/bmu.h
@@ -0,0 +1,37 @@
+#ifndef _BMU_H_
+#define _BMU_H_
+
+#define BMU_VERSION		0x000
+#define BMU_CTRL		0x004
+#define BMU_UCAST_CONFIG	0x008
+#define BMU_UCAST_BASE_ADDR	0x00c
+#define BMU_BUF_SIZE		0x010
+#define BMU_BUF_CNT		0x014
+#define BMU_THRES		0x018
+#define BMU_INT_SRC		0x020
+#define BMU_INT_ENABLE		0x024
+#define BMU_ALLOC_CTRL		0x030
+#define BMU_FREE_CTRL		0x034
+#define BMU_FREE_ERR_ADDR	0x038
+#define BMU_CURR_BUF_CNT	0x03c
+#define BMU_MCAST_CNT		0x040
+#define BMU_MCAST_ALLOC_CTRL	0x044
+#define BMU_REM_BUF_CNT		0x048
+#define BMU_LOW_WATERMARK	0x050
+#define BMU_HIGH_WATERMARK	0x054
+#define BMU_INT_MEM_ACCESS	0x100
+
+typedef struct {
+	u32 baseaddr;
+	u32 count;
+	u32 size;
+} BMU_CFG;
+
+
+#define BMU1_BUF_SIZE	LMEM_BUF_SIZE_LN2
+#define BMU2_BUF_SIZE	DDR_BUF_SIZE_LN2
+
+#define BMU2_MCAST_ALLOC_CTRL	BMU2_BASE_ADDR + BMU_MCAST_ALLOC_CTRL
+
+#endif /* _BMU_H_ */
+
diff --git a/drivers/net/pfe_eth/pfe/cbus/class_csr.h b/drivers/net/pfe_eth/pfe/cbus/class_csr.h
new file mode 100644
index 0000000..f3151ec
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/cbus/class_csr.h
@@ -0,0 +1,206 @@
+#ifndef _CLASS_CSR_H_
+#define _CLASS_CSR_H_
+
+/** @file class_csr.h.
+ * class_csr - block containing all the classifier control and status register. Mapped on CBUS and accessible from all PE's and ARM.
+ */
+
+
+#define CLASS_VERSION			(CLASS_CSR_BASE_ADDR + 0x000)
+#define CLASS_TX_CTRL			(CLASS_CSR_BASE_ADDR + 0x004)
+#define CLASS_INQ_PKTPTR		(CLASS_CSR_BASE_ADDR + 0x010)
+#define CLASS_HDR_SIZE			(CLASS_CSR_BASE_ADDR + 0x014)	/**< (ddr_hdr_size[24:16], lmem_hdr_size[5:0]) */
+#define CLASS_HDR_SIZE_LMEM(off)	((off) & 0x3f)			/**< LMEM header size for the Classifier block.\ Data in the LMEM is written from this offset. */
+#define CLASS_HDR_SIZE_DDR(off)		(((off) & 0x1ff) << 16)		/**< DDR header size for the Classifier block.\ Data in the DDR is written from this offset. */
+
+#define CLASS_PE0_QB_DM_ADDR0		(CLASS_CSR_BASE_ADDR + 0x020)	/**< DMEM address of first [15:0] and second [31:16] buffers on QB side. */
+#define CLASS_PE0_QB_DM_ADDR1		(CLASS_CSR_BASE_ADDR + 0x024)	/**< DMEM address of third [15:0] and fourth [31:16] buffers on QB side. */
+
+#define CLASS_PE0_RO_DM_ADDR0		(CLASS_CSR_BASE_ADDR + 0x060)	/**< DMEM address of first [15:0] and second [31:16] buffers on RO side. */
+#define CLASS_PE0_RO_DM_ADDR1		(CLASS_CSR_BASE_ADDR + 0x064)	/**< DMEM address of third [15:0] and fourth [31:16] buffers on RO side. */
+
+/** @name Class PE memory access. Allows external PE's and HOST to read/write PMEM/DMEM memory ranges for each classifier PE.
+ */
+//@{
+#define CLASS_MEM_ACCESS_ADDR		(CLASS_CSR_BASE_ADDR + 0x100)	/**< {sr_pe_mem_cmd[31], csr_pe_mem_wren[27:24], csr_pe_mem_addr[23:0]}, See \ref XXX_MEM_ACCESS_ADDR for details. */ 
+#define CLASS_MEM_ACCESS_WDATA		(CLASS_CSR_BASE_ADDR + 0x104)	/**< Internal Memory Access Write Data [31:0] */
+#define CLASS_MEM_ACCESS_RDATA		(CLASS_CSR_BASE_ADDR + 0x108)	/**< Internal Memory Access Read Data [31:0] */
+//@}
+#define CLASS_TM_INQ_ADDR		(CLASS_CSR_BASE_ADDR + 0x114)
+#define CLASS_PE_STATUS			(CLASS_CSR_BASE_ADDR + 0x118)
+
+#define CLASS_PHY1_RX_PKTS		(CLASS_CSR_BASE_ADDR + 0x11c)
+#define CLASS_PHY1_TX_PKTS		(CLASS_CSR_BASE_ADDR + 0x120)
+#define CLASS_PHY1_LP_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x124)
+#define CLASS_PHY1_INTF_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x128)
+#define CLASS_PHY1_INTF_MATCH_PKTS	(CLASS_CSR_BASE_ADDR + 0x12c)
+#define CLASS_PHY1_L3_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x130)
+#define CLASS_PHY1_V4_PKTS		(CLASS_CSR_BASE_ADDR + 0x134)
+#define CLASS_PHY1_V6_PKTS		(CLASS_CSR_BASE_ADDR + 0x138)
+#define CLASS_PHY1_CHKSUM_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x13c)
+#define CLASS_PHY1_TTL_ERR_PKTS		(CLASS_CSR_BASE_ADDR + 0x140)
+#define CLASS_PHY2_RX_PKTS		(CLASS_CSR_BASE_ADDR + 0x144)
+#define CLASS_PHY2_TX_PKTS		(CLASS_CSR_BASE_ADDR + 0x148)
+#define CLASS_PHY2_LP_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x14c)
+#define CLASS_PHY2_INTF_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x150)
+#define CLASS_PHY2_INTF_MATCH_PKTS	(CLASS_CSR_BASE_ADDR + 0x154)
+#define CLASS_PHY2_L3_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x158)
+#define CLASS_PHY2_V4_PKTS		(CLASS_CSR_BASE_ADDR + 0x15c)
+#define CLASS_PHY2_V6_PKTS		(CLASS_CSR_BASE_ADDR + 0x160)
+#define CLASS_PHY2_CHKSUM_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x164)
+#define CLASS_PHY2_TTL_ERR_PKTS		(CLASS_CSR_BASE_ADDR + 0x168)
+#define CLASS_PHY3_RX_PKTS		(CLASS_CSR_BASE_ADDR + 0x16c)
+#define CLASS_PHY3_TX_PKTS		(CLASS_CSR_BASE_ADDR + 0x170)
+#define CLASS_PHY3_LP_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x174)
+#define CLASS_PHY3_INTF_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x178)
+#define CLASS_PHY3_INTF_MATCH_PKTS	(CLASS_CSR_BASE_ADDR + 0x17c)
+#define CLASS_PHY3_L3_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x180)
+#define CLASS_PHY3_V4_PKTS		(CLASS_CSR_BASE_ADDR + 0x184)
+#define CLASS_PHY3_V6_PKTS		(CLASS_CSR_BASE_ADDR + 0x188)
+#define CLASS_PHY3_CHKSUM_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x18c)
+#define CLASS_PHY3_TTL_ERR_PKTS		(CLASS_CSR_BASE_ADDR + 0x190)
+#define CLASS_PHY1_ICMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x194)
+#define CLASS_PHY1_IGMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x198)
+#define CLASS_PHY1_TCP_PKTS		(CLASS_CSR_BASE_ADDR + 0x19c)
+#define CLASS_PHY1_UDP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1a0)
+#define CLASS_PHY2_ICMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1a4)
+#define CLASS_PHY2_IGMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1a8)
+#define CLASS_PHY2_TCP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1ac)
+#define CLASS_PHY2_UDP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1b0)
+#define CLASS_PHY3_ICMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1b4)
+#define CLASS_PHY3_IGMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1b8)
+#define CLASS_PHY3_TCP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1bc)
+#define CLASS_PHY3_UDP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1c0)
+#define CLASS_PHY4_ICMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1c4)
+#define CLASS_PHY4_IGMP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1c8)
+#define CLASS_PHY4_TCP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1cc)
+#define CLASS_PHY4_UDP_PKTS		(CLASS_CSR_BASE_ADDR + 0x1d0)
+#define CLASS_PHY4_RX_PKTS		(CLASS_CSR_BASE_ADDR + 0x1d4)
+#define CLASS_PHY4_TX_PKTS		(CLASS_CSR_BASE_ADDR + 0x1d8)
+#define CLASS_PHY4_LP_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x1dc)
+#define CLASS_PHY4_INTF_FAIL_PKTS	(CLASS_CSR_BASE_ADDR + 0x1e0)
+#define CLASS_PHY4_INTF_MATCH_PKTS	(CLASS_CSR_BASE_ADDR + 0x1e4)
+#define CLASS_PHY4_L3_FAIL_PKTS		(CLASS_CSR_BASE_ADDR + 0x1e8)
+#define CLASS_PHY4_V4_PKTS		(CLASS_CSR_BASE_ADDR + 0x1ec)
+#define CLASS_PHY4_V6_PKTS		(CLASS_CSR_BASE_ADDR + 0x1f0)
+#define CLASS_PHY4_CHKSUM_ERR_PKTS	(CLASS_CSR_BASE_ADDR + 0x1f4)
+#define CLASS_PHY4_TTL_ERR_PKTS		(CLASS_CSR_BASE_ADDR + 0x1f8)
+
+#define CLASS_PE_SYS_CLK_RATIO		(CLASS_CSR_BASE_ADDR + 0x200)
+#define CLASS_AFULL_THRES		(CLASS_CSR_BASE_ADDR + 0x204)
+#define CLASS_GAP_BETWEEN_READS		(CLASS_CSR_BASE_ADDR + 0x208)
+#define CLASS_MAX_BUF_CNT		(CLASS_CSR_BASE_ADDR + 0x20c)
+#define CLASS_TSQ_FIFO_THRES		(CLASS_CSR_BASE_ADDR + 0x210)
+#define CLASS_TSQ_MAX_CNT		(CLASS_CSR_BASE_ADDR + 0x214)
+#define CLASS_IRAM_DATA_0		(CLASS_CSR_BASE_ADDR + 0x218)
+#define CLASS_IRAM_DATA_1		(CLASS_CSR_BASE_ADDR + 0x21c)
+#define CLASS_IRAM_DATA_2		(CLASS_CSR_BASE_ADDR + 0x220)
+#define CLASS_IRAM_DATA_3		(CLASS_CSR_BASE_ADDR + 0x224)
+
+#define CLASS_BUS_ACCESS_ADDR		(CLASS_CSR_BASE_ADDR + 0x228)
+#define CLASS_BUS_ACCESS_ADDR_MASK	(0x0001FFFF)	//bit 23:0 of PE peripheral address are stored in CLASS_BUS_ACCESS_ADDR
+
+#define CLASS_BUS_ACCESS_WDATA		(CLASS_CSR_BASE_ADDR + 0x22c)
+#define CLASS_BUS_ACCESS_RDATA		(CLASS_CSR_BASE_ADDR + 0x230)
+
+#define CLASS_ROUTE_HASH_ENTRY_SIZE	(CLASS_CSR_BASE_ADDR + 0x234)		/**< (route_entry_size[9:0], route_hash_size[23:16] (this is actually ln2(size))) */
+#define CLASS_ROUTE_ENTRY_SIZE(size)	 ((size) & 0x1ff)
+#define CLASS_ROUTE_HASH_SIZE(hash_bits) (((hash_bits) & 0xff) << 16)
+
+#define CLASS_ROUTE_TABLE_BASE		(CLASS_CSR_BASE_ADDR + 0x238)
+
+#define CLASS_ROUTE_MULTI		(CLASS_CSR_BASE_ADDR + 0x23c)
+#define CLASS_SMEM_OFFSET		(CLASS_CSR_BASE_ADDR + 0x240)
+#define CLASS_LMEM_BUF_SIZE		(CLASS_CSR_BASE_ADDR + 0x244)
+#define CLASS_VLAN_ID			(CLASS_CSR_BASE_ADDR + 0x248)
+#define CLASS_BMU1_BUF_FREE		(CLASS_CSR_BASE_ADDR + 0x24c)
+#define CLASS_USE_TMU_INQ		(CLASS_CSR_BASE_ADDR + 0x250)
+#define CLASS_VLAN_ID1			(CLASS_CSR_BASE_ADDR + 0x254)
+
+#define CLASS_BUS_ACCESS_BASE		(CLASS_CSR_BASE_ADDR + 0x258)
+#define CLASS_BUS_ACCESS_BASE_MASK	(0xFF000000)	//bit 31:24 of PE peripheral address are stored in CLASS_BUS_ACCESS_BASE
+
+#define CLASS_HIF_PARSE			(CLASS_CSR_BASE_ADDR + 0x25c)
+
+#define CLASS_HOST_PE0_GP		(CLASS_CSR_BASE_ADDR + 0x260)
+#define CLASS_PE0_GP			(CLASS_CSR_BASE_ADDR + 0x264)
+#define CLASS_HOST_PE1_GP		(CLASS_CSR_BASE_ADDR + 0x268)
+#define CLASS_PE1_GP			(CLASS_CSR_BASE_ADDR + 0x26c)
+#define CLASS_HOST_PE2_GP		(CLASS_CSR_BASE_ADDR + 0x270)
+#define CLASS_PE2_GP			(CLASS_CSR_BASE_ADDR + 0x274)
+#define CLASS_HOST_PE3_GP		(CLASS_CSR_BASE_ADDR + 0x278)
+#define CLASS_PE3_GP			(CLASS_CSR_BASE_ADDR + 0x27c)
+#define CLASS_HOST_PE4_GP		(CLASS_CSR_BASE_ADDR + 0x280)
+#define CLASS_PE4_GP			(CLASS_CSR_BASE_ADDR + 0x284)
+#define CLASS_HOST_PE5_GP		(CLASS_CSR_BASE_ADDR + 0x288)
+#define CLASS_PE5_GP			(CLASS_CSR_BASE_ADDR + 0x28c)
+
+#define CLASS_PE_INT_SRC		(CLASS_CSR_BASE_ADDR + 0x290)
+#define CLASS_PE_INT_ENABLE		(CLASS_CSR_BASE_ADDR + 0x294)
+
+#define CLASS_TPID0_TPID1		(CLASS_CSR_BASE_ADDR + 0x298)
+#define CLASS_TPID2			(CLASS_CSR_BASE_ADDR + 0x29c)
+
+#define CLASS_L4_CHKSUM_ADDR		(CLASS_CSR_BASE_ADDR + 0x2a0)
+
+#define CLASS_PE0_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2a4)
+#define CLASS_PE1_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2a8)
+#define CLASS_PE2_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2ac)
+#define CLASS_PE3_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2b0)
+#define CLASS_PE4_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2b4)
+#define CLASS_PE5_DEBUG			(CLASS_CSR_BASE_ADDR + 0x2b8)
+
+#define CLASS_STATE			(CLASS_CSR_BASE_ADDR + 0x2bc)
+
+/* CLASS defines */
+#define CLASS_PBUF_SIZE			0x100	/* Fixed by hardware */
+#define CLASS_PBUF_HEADER_OFFSET	0x80	/* Can be configured */
+
+#define CLASS_PBUF0_BASE_ADDR		0x000						/* Can be configured */
+#define CLASS_PBUF1_BASE_ADDR		(CLASS_PBUF0_BASE_ADDR + CLASS_PBUF_SIZE)	/* Can be configured */
+#define CLASS_PBUF2_BASE_ADDR		(CLASS_PBUF1_BASE_ADDR + CLASS_PBUF_SIZE)	/* Can be configured */
+#define CLASS_PBUF3_BASE_ADDR		(CLASS_PBUF2_BASE_ADDR + CLASS_PBUF_SIZE)	/* Can be configured */
+
+#define CLASS_PBUF0_HEADER_BASE_ADDR	(CLASS_PBUF0_BASE_ADDR + CLASS_PBUF_HEADER_OFFSET)
+#define CLASS_PBUF1_HEADER_BASE_ADDR	(CLASS_PBUF1_BASE_ADDR + CLASS_PBUF_HEADER_OFFSET)
+#define CLASS_PBUF2_HEADER_BASE_ADDR	(CLASS_PBUF2_BASE_ADDR + CLASS_PBUF_HEADER_OFFSET)
+#define CLASS_PBUF3_HEADER_BASE_ADDR	(CLASS_PBUF3_BASE_ADDR + CLASS_PBUF_HEADER_OFFSET)
+
+#define CLASS_PE0_RO_DM_ADDR0_VAL	((CLASS_PBUF1_BASE_ADDR << 16) | CLASS_PBUF0_BASE_ADDR)
+#define CLASS_PE0_RO_DM_ADDR1_VAL	((CLASS_PBUF3_BASE_ADDR << 16) | CLASS_PBUF2_BASE_ADDR)
+
+#define CLASS_PE0_QB_DM_ADDR0_VAL	((CLASS_PBUF1_HEADER_BASE_ADDR << 16) | CLASS_PBUF0_HEADER_BASE_ADDR)
+#define CLASS_PE0_QB_DM_ADDR1_VAL	((CLASS_PBUF3_HEADER_BASE_ADDR << 16) | CLASS_PBUF2_HEADER_BASE_ADDR)
+
+#define CLASS_ROUTE_SIZE		128
+#define CLASS_ROUTE_HASH_BITS		20
+#define CLASS_ROUTE_HASH_MASK		((1 << CLASS_ROUTE_HASH_BITS) - 1)
+
+#define	CLASS_ROUTE0_BASE_ADDR	0x400						/* Can be configured */
+#define CLASS_ROUTE1_BASE_ADDR	(CLASS_ROUTE0_BASE_ADDR + CLASS_ROUTE_SIZE)	/* Can be configured */
+#define CLASS_ROUTE2_BASE_ADDR	(CLASS_ROUTE1_BASE_ADDR + CLASS_ROUTE_SIZE)	/* Can be configured */
+#define CLASS_ROUTE3_BASE_ADDR	(CLASS_ROUTE2_BASE_ADDR + CLASS_ROUTE_SIZE)	/* Can be configured */
+
+#define TWO_LEVEL_ROUTE		(1 << 0)
+#define PHYNO_IN_HASH		(1 << 1)
+#define HW_ROUTE_FETCH		(1 << 3)
+#define HW_BRIDGE_FETCH		(1 << 5)
+#define IP_ALIGNED		(1 << 6)
+#define ARC_HIT_CHECK_EN	(1 << 7)
+#define CLASS_TOE		(1 << 11)
+#define HASH_NORMAL		(0 << 12)
+#define HASH_CRC_PORT		(1 << 12)
+#define HASH_CRC_IP		(2 << 12)
+#define HASH_CRC_PORT_IP	(3 << 12)
+#define QB2BUS_LE		(1 << 15)
+
+#define	TCP_CHKSUM_DROP		(1 << 0)
+#define	UDP_CHKSUM_DROP		(1 << 1)
+#define	IPV4_CHKSUM_DROP	(1 << 9)
+
+typedef struct {
+	u32 route_table_baseaddr;
+	u32 route_table_hash_bits;
+} CLASS_CFG;
+
+#endif /* _CLASS_CSR_H_ */
diff --git a/drivers/net/pfe_eth/pfe/cbus/emac.h b/drivers/net/pfe_eth/pfe/cbus/emac.h
new file mode 100644
index 0000000..1f308ce
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/cbus/emac.h
@@ -0,0 +1,232 @@
+#ifndef _EMAC_H_
+#define _EMAC_H_
+
+#define EMAC_IEVENT_REG	0x004
+#define EMAC_IMASK_REG	0x008
+#define EMAC_R_DES_ACTIVE_REG	0x010
+#define EMAC_X_DES_ACTIVE_REG	0x014
+#define EMAC_ECNTRL_REG		0x024
+#define EMAC_MII_DATA_REG	0x040
+#define EMAC_MII_CTRL_REG	0x044
+#define EMAC_MIB_CTRL_STS_REG	0x064
+#define EMAC_RCNTRL_REG		0x084
+#define EMAC_TCNTRL_REG		0x0C4
+#define EMAC_PHY_ADDR_LOW	0x0E4
+#define EMAC_PHY_ADDR_HIGH	0x0E8
+#define EMAC_TFWR_STR_FWD	0x144
+#define EMAC_RX_SECTIOM_FULL	0x190
+#define EMAC_TX_SECTION_EMPTY	0x1A0
+#define EMAC_TRUNC_FL		0x1B0
+
+#define RMON_T_DROP		0x200 /* Count of frames not cntd correctly */
+#define RMON_T_PACKETS		0x204 /* RMON TX packet count */
+#define RMON_T_BC_PKT		0x208 /* RMON TX broadcast pkts */
+#define RMON_T_MC_PKT		0x20c /* RMON TX multicast pkts */
+#define RMON_T_CRC_ALIGN	0x210 /* RMON TX pkts with CRC align err */
+#define RMON_T_UNDERSIZE	0x214 /* RMON TX pkts < 64 bytes, good CRC */
+#define RMON_T_OVERSIZE		0x218 /* RMON TX pkts > MAX_FL bytes good CRC */
+#define RMON_T_FRAG		0x21c /* RMON TX pkts < 64 bytes, bad CRC */
+#define RMON_T_JAB		0x220 /* RMON TX pkts > MAX_FL bytes, bad CRC */
+#define RMON_T_COL		0x224 /* RMON TX collision count */
+#define RMON_T_P64		0x228 /* RMON TX 64 byte pkts */
+#define RMON_T_P65TO127		0x22c /* RMON TX 65 to 127 byte pkts */
+#define RMON_T_P128TO255	0x230 /* RMON TX 128 to 255 byte pkts */
+#define RMON_T_P256TO511	0x234 /* RMON TX 256 to 511 byte pkts */
+#define RMON_T_P512TO1023	0x238 /* RMON TX 512 to 1023 byte pkts */
+#define RMON_T_P1024TO2047	0x23c /* RMON TX 1024 to 2047 byte pkts */
+#define RMON_T_P_GTE2048	0x240 /* RMON TX pkts > 2048 bytes */
+#define RMON_T_OCTETS		0x244 /* RMON TX octets */
+#define IEEE_T_DROP		0x248 /* Count of frames not counted crtly */
+#define IEEE_T_FRAME_OK		0x24c /* Frames tx'd OK */
+#define IEEE_T_1COL		0x250 /* Frames tx'd with single collision */
+#define IEEE_T_MCOL		0x254 /* Frames tx'd with multiple collision */
+#define IEEE_T_DEF		0x258 /* Frames tx'd after deferral delay */
+#define IEEE_T_LCOL		0x25c /* Frames tx'd with late collision */
+#define IEEE_T_EXCOL		0x260 /* Frames tx'd with excesv collisions */
+#define IEEE_T_MACERR		0x264 /* Frames tx'd with TX FIFO underrun */
+#define IEEE_T_CSERR		0x268 /* Frames tx'd with carrier sense err */
+#define IEEE_T_SQE		0x26c /* Frames tx'd with SQE err */
+#define IEEE_T_FDXFC		0x270 /* Flow control pause frames tx'd */
+#define IEEE_T_OCTETS_OK	0x274 /* Octet count for frames tx'd w/o err */
+#define RMON_R_PACKETS		0x284 /* RMON RX packet count */
+#define RMON_R_BC_PKT		0x288 /* RMON RX broadcast pkts */
+#define RMON_R_MC_PKT		0x28c /* RMON RX multicast pkts */
+#define RMON_R_CRC_ALIGN	0x290 /* RMON RX pkts with CRC alignment err */
+#define RMON_R_UNDERSIZE	0x294 /* RMON RX pkts < 64 bytes, good CRC */
+#define RMON_R_OVERSIZE		0x298 /* RMON RX pkts > MAX_FL bytes good CRC */
+#define RMON_R_FRAG		0x29c /* RMON RX pkts < 64 bytes, bad CRC */
+#define RMON_R_JAB		0x2a0 /* RMON RX pkts > MAX_FL bytes, bad CRC */
+#define RMON_R_RESVD_O		0x2a4 /* Reserved */
+#define RMON_R_P64		0x2a8 /* RMON RX 64 byte pkts */
+#define RMON_R_P65TO127		0x2ac /* RMON RX 65 to 127 byte pkts */
+#define RMON_R_P128TO255	0x2b0 /* RMON RX 128 to 255 byte pkts */
+#define RMON_R_P256TO511	0x2b4 /* RMON RX 256 to 511 byte pkts */
+#define RMON_R_P512TO1023	0x2b8 /* RMON RX 512 to 1023 byte pkts */
+#define RMON_R_P1024TO2047	0x2bc /* RMON RX 1024 to 2047 byte pkts */
+#define RMON_R_P_GTE2048	0x2c0 /* RMON RX pkts > 2048 bytes */
+#define RMON_R_OCTETS		0x2c4 /* RMON RX octets */
+#define IEEE_R_DROP		0x2c8 /* Count frames not counted correctly */
+#define IEEE_R_FRAME_OK		0x2cc /* Frames rx'd OK */
+#define IEEE_R_CRC		0x2d0 /* Frames rx'd with CRC err */
+#define IEEE_R_ALIGN		0x2d4 /* Frames rx'd with alignment err */
+#define IEEE_R_MACERR		0x2d8 /* Receive FIFO overflow count */
+#define IEEE_R_FDXFC		0x2dc /* Flow control pause frames rx'd */
+#define IEEE_R_OCTETS_OK	0x2e0 /* Octet cnt for frames rx'd w/o err */
+
+
+/* GEMAC definitions and settings */
+
+#define EMAC_PORT_0			0
+#define EMAC_PORT_1			1
+
+/* GEMAC Bit definitions */
+#define EMAC_IEVENT_HBERR                0x80000000
+#define EMAC_IEVENT_BABR                 0x40000000
+#define EMAC_IEVENT_BABT                 0x20000000
+#define EMAC_IEVENT_GRA                  0x10000000
+#define EMAC_IEVENT_TXF                  0x08000000
+#define EMAC_IEVENT_TXB                  0x04000000
+#define EMAC_IEVENT_RXF                  0x02000000
+#define EMAC_IEVENT_RXB                  0x01000000
+#define EMAC_IEVENT_MII                  0x00800000
+#define EMAC_IEVENT_EBERR                0x00400000
+#define EMAC_IEVENT_LC                   0x00200000
+#define EMAC_IEVENT_RL                   0x00100000
+#define EMAC_IEVENT_UN                   0x00080000
+
+#define EMAC_IMASK_HBERR                 0x80000000
+#define EMAC_IMASK_BABR                  0x40000000
+#define EMAC_IMASKT_BABT                 0x20000000
+#define EMAC_IMASK_GRA                   0x10000000
+#define EMAC_IMASKT_TXF                  0x08000000
+#define EMAC_IMASK_TXB                   0x04000000
+#define EMAC_IMASKT_RXF                  0x02000000
+#define EMAC_IMASK_RXB                   0x01000000
+#define EMAC_IMASK_MII                   0x00800000
+#define EMAC_IMASK_EBERR                 0x00400000
+#define EMAC_IMASK_LC                    0x00200000
+#define EMAC_IMASKT_RL                   0x00100000
+#define EMAC_IMASK_UN                    0x00080000
+
+#define EMAC_RCNTRL_MAX_FL_SHIFT         16
+#define EMAC_RCNTRL_LOOP                 0x00000001
+#define EMAC_RCNTRL_DRT                  0x00000002
+#define EMAC_RCNTRL_MII_MODE             0x00000004
+#define EMAC_RCNTRL_PROM                 0x00000008
+#define EMAC_RCNTRL_BC_REJ               0x00000010
+#define EMAC_RCNTRL_FCE                  0x00000020
+#define EMAC_RCNTRL_RGMII                0x00000040
+#define EMAC_RCNTRL_SGMII                0x00000080
+#define EMAC_RCNTRL_RMII                 0x00000100
+#define EMAC_RCNTRL_RMII_10T             0x00000200
+#define EMAC_RCNTRL_CRC_FWD		 0x00004000
+
+#define EMAC_TCNTRL_GTS                  0x00000001
+#define EMAC_TCNTRL_HBC                  0x00000002
+#define EMAC_TCNTRL_FDEN                 0x00000004
+#define EMAC_TCNTRL_TFC_PAUSE            0x00000008
+#define EMAC_TCNTRL_RFC_PAUSE            0x00000010
+
+#define EMAC_ECNTRL_RESET                0x00000001      /* reset the EMAC */
+#define EMAC_ECNTRL_ETHER_EN             0x00000002      /* enable the EMAC */
+#define EMAC_ECNTRL_SPEED                0x00000020
+#define EMAC_ECNTRL_DBSWAP               0x00000100
+
+#define EMAC_X_WMRK_STRFWD               0x00000100
+
+#define EMAC_X_DES_ACTIVE_TDAR           0x01000000
+#define EMAC_R_DES_ACTIVE_RDAR           0x01000000
+
+
+
+/* The possible operating speeds of the MAC, currently supporting 10, 100 and
+ * 1000Mb modes.
+ */
+typedef enum {SPEED_10M, SPEED_100M, SPEED_1000M, SPEED_1000M_PCS} MAC_SPEED;
+
+#define GMII	1
+#define MII	2
+#define RMII	3
+#define RGMII	4
+#define SGMII	5
+
+#define DUPLEX_HALF	0x00
+#define DUPLEX_FULL	0x01
+
+
+/* Default configuration */
+#define EMAC0_DEFAULT_DUPLEX_MODE	FULLDUPLEX 
+#define EMAC0_DEFAULT_EMAC_MODE		RGMII      
+#define EMAC0_DEFAULT_EMAC_SPEED	SPEED_1000M   
+
+#define EMAC1_DEFAULT_DUPLEX_MODE	FULLDUPLEX 
+#define EMAC1_DEFAULT_EMAC_MODE		SGMII      
+#define EMAC1_DEFAULT_EMAC_SPEED	SPEED_1000M   
+
+/* MII-related definitios */
+#define EMAC_MII_DATA_ST         0x40000000      /* Start of frame delimiter */
+#define EMAC_MII_DATA_OP_RD      0x20000000      /* Perform a read operation */
+#define EMAC_MII_DATA_OP_WR      0x10000000      /* Perform a write operation */
+#define EMAC_MII_DATA_PA_MSK     0x0f800000      /* PHY Address field mask */
+#define EMAC_MII_DATA_RA_MSK     0x007c0000      /* PHY Register field mask */
+#define EMAC_MII_DATA_TA         0x00020000      /* Turnaround */
+#define EMAC_MII_DATA_DATAMSK    0x0000ffff      /* PHY data field */
+
+#define EMAC_MII_DATA_RA_SHIFT   18      /* MII Register address bits */
+#define EMAC_MII_DATA_RA_MASK	 0x1F      /* MII Register address mask */
+#define EMAC_MII_DATA_PA_SHIFT   23      /* MII PHY address bits */
+#define EMAC_MII_DATA_PA_MASK    0x1F      /* MII PHY address mask */
+
+#define EMAC_MII_DATA_RA(v) ((v & EMAC_MII_DATA_RA_MASK) << EMAC_MII_DATA_RA_SHIFT)
+#define EMAC_MII_DATA_PA(v) ((v & EMAC_MII_DATA_RA_MASK) << EMAC_MII_DATA_PA_SHIFT)
+#define EMAC_MII_DATA(v)    (v & 0xffff)
+
+#define EMAC_MII_SPEED_SHIFT	1
+#define EMAC_HOLDTIME_SHIFT	8
+#define EMAC_HOLDTIME_MASK	0x7
+#define EMAC_HOLDTIME(v)	((v & EMAC_HOLDTIME_MASK) << EMAC_HOLDTIME_SHIFT)
+
+/* The Address organisation for the MAC device.  All addresses are split into
+ * two 32-bit register fields.  The first one (bottom) is the lower 32-bits of
+ * the address and the other field are the high order bits - this may be 16-bits
+ * in the case of MAC addresses, or 32-bits for the hash address.
+ * In terms of memory storage, the first item (bottom) is assumed to be at a
+ * lower address location than 'top'. i.e. top should be at address location of
+ * 'bottom' + 4 bytes.
+ */
+typedef struct {
+	u32 bottom;     /* Lower 32-bits of address. */
+	u32 top;        /* Upper 32-bits of address. */
+} MAC_ADDR;
+
+
+/* The following is the organisation of the address filters section of the MAC
+ * registers.  The Cadence MAC contains four possible specific address match
+ * addresses, if an incoming frame corresponds to any one of these four
+ * addresses then the frame will be copied to memory.
+ * It is not necessary for all four of the address match registers to be
+ * programmed, this is application dependant.
+ */
+typedef struct {
+	MAC_ADDR one;        /* Specific address register 1. */
+	MAC_ADDR two;        /* Specific address register 2. */
+	MAC_ADDR three;      /* Specific address register 3. */
+	MAC_ADDR four;       /* Specific address register 4. */
+} SPEC_ADDR;
+
+typedef struct {
+	u32 mode; 
+	u32 speed;
+	u32 duplex;
+} GEMAC_CFG;
+
+/* Internal PHY Registers - SGMII */
+#define PHY_SGMII_CR_PHY_RESET      0x8000
+#define PHY_SGMII_CR_RESET_AN       0x0200
+#define PHY_SGMII_CR_DEF_VAL        0x1140
+#define PHY_SGMII_DEV_ABILITY_SGMII 0x4001
+#define PHY_SGMII_IF_MODE_AN        0x0002
+#define PHY_SGMII_IF_MODE_SGMII     0x0001
+
+
+#endif /* _EMAC_H_ */
diff --git a/drivers/net/pfe_eth/pfe/cbus/gpi.h b/drivers/net/pfe_eth/pfe/cbus/gpi.h
new file mode 100644
index 0000000..d2d165f
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/cbus/gpi.h
@@ -0,0 +1,60 @@
+#ifndef _GPI_H_
+#define _GPI_H_
+
+#define GPI_VERSION			0x00
+#define GPI_CTRL			0x04
+#define GPI_RX_CONFIG			0x08
+#define GPI_HDR_SIZE			0x0c
+#define GPI_BUF_SIZE			0x10
+#define GPI_LMEM_ALLOC_ADDR		0x14
+#define GPI_LMEM_FREE_ADDR		0x18
+#define GPI_DDR_ALLOC_ADDR		0x1c
+#define GPI_DDR_FREE_ADDR		0x20
+#define GPI_CLASS_ADDR			0x24
+#define GPI_DRX_FIFO			0x28
+#define GPI_TRX_FIFO			0x2c
+#define GPI_INQ_PKTPTR			0x30
+#define GPI_DDR_DATA_OFFSET		0x34
+#define GPI_LMEM_DATA_OFFSET		0x38
+#define GPI_TMLF_TX			0x4c
+#define GPI_DTX_ASEQ			0x50
+#define GPI_FIFO_STATUS			0x54
+#define GPI_FIFO_DEBUG			0x58
+#define GPI_TX_PAUSE_TIME		0x5c
+#define GPI_LMEM_SEC_BUF_DATA_OFFSET	0x60
+#define GPI_DDR_SEC_BUF_DATA_OFFSET	0x64
+#define GPI_TOE_CHKSUM_EN		0x68
+#define GPI_OVERRUN_DROPCNT		0x6c
+
+typedef struct {
+	u32 lmem_rtry_cnt;
+	u32 tmlf_txthres;
+	u32 aseq_len;
+} GPI_CFG;
+
+
+/* GPI commons defines */ 
+#define GPI_LMEM_BUF_EN		0x1
+#define GPI_DDR_BUF_EN		0x1
+
+/* EGPI 1 defines */ 
+#define EGPI1_LMEM_RTRY_CNT	0x40
+#define EGPI1_TMLF_TXTHRES	0xBC
+#define EGPI1_ASEQ_LEN		0x50
+
+/* EGPI 2 defines */ 
+#define EGPI2_LMEM_RTRY_CNT	0x40
+#define EGPI2_TMLF_TXTHRES	0xBC
+#define EGPI2_ASEQ_LEN		0x40
+
+/* EGPI 3 defines */ 
+#define EGPI3_LMEM_RTRY_CNT	0x40
+#define EGPI3_TMLF_TXTHRES	0xBC
+#define EGPI3_ASEQ_LEN		0x40
+
+/* HGPI defines */ 
+#define HGPI_LMEM_RTRY_CNT	0x40
+#define HGPI_TMLF_TXTHRES	0xBC
+#define HGPI_ASEQ_LEN		0x40
+
+#endif /* _GPI_H_ */
diff --git a/drivers/net/pfe_eth/pfe/cbus/gpt.h b/drivers/net/pfe_eth/pfe/cbus/gpt.h
new file mode 100644
index 0000000..f8c114b
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/cbus/gpt.h
@@ -0,0 +1,11 @@
+#ifndef _CBUS_GPT_H_
+#define _CBUS_GPT_H_
+
+#define CBUS_GPT_VERSION	 (CBUS_GPT_BASE_ADDR + 0x00)
+#define CBUS_GPT_STATUS		 (CBUS_GPT_BASE_ADDR + 0x04)
+#define CBUS_GPT_CONFIG		 (CBUS_GPT_BASE_ADDR + 0x08)
+#define CBUS_GPT_COUNTER	 (CBUS_GPT_BASE_ADDR + 0x0c)
+#define CBUS_GPT_PERIOD		 (CBUS_GPT_BASE_ADDR + 0x10)
+#define CBUS_GPT_WIDTH		 (CBUS_GPT_BASE_ADDR + 0x14)
+
+#endif /* _CBUS_GPT_H_ */
diff --git a/drivers/net/pfe_eth/pfe/cbus/hif.h b/drivers/net/pfe_eth/pfe/cbus/hif.h
new file mode 100644
index 0000000..a4dd7c2
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/cbus/hif.h
@@ -0,0 +1,62 @@
+#ifndef _HIF_H_
+#define _HIF_H_
+
+/** @file hif.h.
+ * hif - PFE hif block control and status register. Mapped on CBUS and accessible from all PE's and ARM.
+ */
+#define HIF_VERSION		(HIF_BASE_ADDR + 0x00)
+#define HIF_TX_CTRL		(HIF_BASE_ADDR + 0x04)
+#define HIF_TX_CURR_BD_ADDR	(HIF_BASE_ADDR + 0x08)
+#define HIF_TX_ALLOC		(HIF_BASE_ADDR + 0x0c)
+#define HIF_TX_BDP_ADDR		(HIF_BASE_ADDR + 0x10)
+#define HIF_TX_STATUS		(HIF_BASE_ADDR + 0x14)
+#define HIF_RX_CTRL		(HIF_BASE_ADDR + 0x20)
+#define HIF_RX_BDP_ADDR		(HIF_BASE_ADDR + 0x24)
+#define HIF_RX_STATUS		(HIF_BASE_ADDR + 0x30)
+#define HIF_INT_SRC		(HIF_BASE_ADDR + 0x34)
+#define HIF_INT_ENABLE		(HIF_BASE_ADDR + 0x38)
+#define HIF_POLL_CTRL		(HIF_BASE_ADDR + 0x3c)
+#define HIF_RX_CURR_BD_ADDR	(HIF_BASE_ADDR + 0x40)
+#define HIF_RX_ALLOC		(HIF_BASE_ADDR + 0x44)
+#define HIF_TX_DMA_STATUS	(HIF_BASE_ADDR + 0x48)
+#define HIF_RX_DMA_STATUS	(HIF_BASE_ADDR + 0x4c)
+#define HIF_INT_COAL		(HIF_BASE_ADDR + 0x50)
+
+/*HIF_INT_SRC/ HIF_INT_ENABLE control bits */
+#define HIF_INT        		(1 << 0)
+#define HIF_RXBD_INT   		(1 << 1)
+#define HIF_RXPKT_INT  		(1 << 2)
+#define HIF_TXBD_INT   		(1 << 3)
+#define HIF_TXPKT_INT  		(1 << 4)
+
+/*HIF_TX_CTRL bits */
+#define HIF_CTRL_DMA_EN			(1<<0)
+#define HIF_CTRL_BDP_POLL_CTRL_EN	(1<<1)
+#define HIF_CTRL_BDP_CH_START_WSTB	(1<<2)
+
+/*HIF_INT_ENABLE bits */
+#define HIF_INT_EN		(1 << 0)
+#define HIF_RXBD_INT_EN		(1 << 1)
+#define HIF_RXPKT_INT_EN	(1 << 2)
+#define HIF_TXBD_INT_EN		(1 << 3)
+#define HIF_TXPKT_INT_EN	(1 << 4)
+
+/*HIF_POLL_CTRL bits*/
+#define HIF_RX_POLL_CTRL_CYCLE	0x0400
+#define HIF_TX_POLL_CTRL_CYCLE	0x0400
+
+/*Buffer descriptor control bits */
+#define BD_CTRL_BUFLEN_MASK	(0xffff)
+#define BD_BUF_LEN(x)		(x & BD_CTRL_BUFLEN_MASK)
+#define BD_CTRL_CBD_INT_EN	(1 << 16)
+#define BD_CTRL_PKT_INT_EN	(1 << 17)
+#define BD_CTRL_LIFM		(1 << 18)
+#define BD_CTRL_LAST_BD		(1 << 19)
+#define BD_CTRL_DIR		(1 << 20)
+#define BD_CTRL_PKT_XFER	(1 << 24)
+#define BD_CTRL_DESC_EN		(1 << 31)
+#define BD_CTRL_PARSE_DISABLE	(1 << 25)
+#define BD_CTRL_BRFETCH_DISABLE	(1 << 26)
+#define BD_CTRL_RTFETCH_DISABLE	(1 << 27)
+
+#endif /* _HIF_H_ */
diff --git a/drivers/net/pfe_eth/pfe/cbus/hif_nocpy.h b/drivers/net/pfe_eth/pfe/cbus/hif_nocpy.h
new file mode 100644
index 0000000..93cb946
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/cbus/hif_nocpy.h
@@ -0,0 +1,33 @@
+#ifndef _HIF_NOCPY_H_
+#define _HIF_NOCPY_H_
+
+#define HIF_NOCPY_VERSION		(HIF_NOCPY_BASE_ADDR + 0x00)
+#define HIF_NOCPY_TX_CTRL		(HIF_NOCPY_BASE_ADDR + 0x04)
+#define HIF_NOCPY_TX_CURR_BD_ADDR	(HIF_NOCPY_BASE_ADDR + 0x08)
+#define HIF_NOCPY_TX_ALLOC		(HIF_NOCPY_BASE_ADDR + 0x0c)
+#define HIF_NOCPY_TX_BDP_ADDR		(HIF_NOCPY_BASE_ADDR + 0x10)
+#define HIF_NOCPY_TX_STATUS		(HIF_NOCPY_BASE_ADDR + 0x14)
+#define HIF_NOCPY_RX_CTRL		(HIF_NOCPY_BASE_ADDR + 0x20)
+#define HIF_NOCPY_RX_BDP_ADDR		(HIF_NOCPY_BASE_ADDR + 0x24)
+#define HIF_NOCPY_RX_STATUS		(HIF_NOCPY_BASE_ADDR + 0x30)
+#define HIF_NOCPY_INT_SRC		(HIF_NOCPY_BASE_ADDR + 0x34)
+#define HIF_NOCPY_INT_ENABLE		(HIF_NOCPY_BASE_ADDR + 0x38)
+#define HIF_NOCPY_POLL_CTRL		(HIF_NOCPY_BASE_ADDR + 0x3c)
+#define HIF_NOCPY_RX_CURR_BD_ADDR	(HIF_NOCPY_BASE_ADDR + 0x40)
+#define HIF_NOCPY_RX_ALLOC		(HIF_NOCPY_BASE_ADDR + 0x44)
+#define HIF_NOCPY_TX_DMA_STATUS		(HIF_NOCPY_BASE_ADDR + 0x48)
+#define HIF_NOCPY_RX_DMA_STATUS		(HIF_NOCPY_BASE_ADDR + 0x4c)
+#define HIF_NOCPY_RX_INQ0_PKTPTR	(HIF_NOCPY_BASE_ADDR + 0x50)
+#define HIF_NOCPY_RX_INQ1_PKTPTR	(HIF_NOCPY_BASE_ADDR + 0x54)
+#define HIF_NOCPY_TX_PORT_NO		(HIF_NOCPY_BASE_ADDR + 0x60)
+#define HIF_NOCPY_LMEM_ALLOC_ADDR	(HIF_NOCPY_BASE_ADDR + 0x64)
+#define HIF_NOCPY_CLASS_ADDR		(HIF_NOCPY_BASE_ADDR + 0x68)
+#define HIF_NOCPY_TMU_PORT0_ADDR	(HIF_NOCPY_BASE_ADDR + 0x70)
+#define HIF_NOCPY_TMU_PORT1_ADDR	(HIF_NOCPY_BASE_ADDR + 0x74)
+#define HIF_NOCPY_TMU_PORT2_ADDR	(HIF_NOCPY_BASE_ADDR + 0x7c)
+#define HIF_NOCPY_TMU_PORT3_ADDR	(HIF_NOCPY_BASE_ADDR + 0x80)
+#define HIF_NOCPY_TMU_PORT4_ADDR	(HIF_NOCPY_BASE_ADDR + 0x84)
+#define HIF_NOCPY_INT_COAL		(HIF_NOCPY_BASE_ADDR + 0x90)
+
+
+#endif /* _HIF_NOCPY_H_ */
diff --git a/drivers/net/pfe_eth/pfe/cbus/tmu_csr.h b/drivers/net/pfe_eth/pfe/cbus/tmu_csr.h
new file mode 100644
index 0000000..cbcbb1f
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/cbus/tmu_csr.h
@@ -0,0 +1,102 @@
+#ifndef _TMU_CSR_H_
+#define _TMU_CSR_H_
+
+#define TMU_VERSION			(TMU_CSR_BASE_ADDR + 0x000)
+#define TMU_INQ_WATERMARK		(TMU_CSR_BASE_ADDR + 0x004)
+#define TMU_PHY_INQ_PKTPTR		(TMU_CSR_BASE_ADDR + 0x008)
+#define TMU_PHY_INQ_PKTINFO		(TMU_CSR_BASE_ADDR + 0x00c)
+#define TMU_PHY_INQ_FIFO_CNT		(TMU_CSR_BASE_ADDR + 0x010)
+#define TMU_SYS_GENERIC_CONTROL		(TMU_CSR_BASE_ADDR + 0x014)
+#define TMU_SYS_GENERIC_STATUS		(TMU_CSR_BASE_ADDR + 0x018)
+#define TMU_SYS_GEN_CON0		(TMU_CSR_BASE_ADDR + 0x01c)
+#define TMU_SYS_GEN_CON1		(TMU_CSR_BASE_ADDR + 0x020)
+#define TMU_SYS_GEN_CON2		(TMU_CSR_BASE_ADDR + 0x024)
+#define TMU_SYS_GEN_CON3		(TMU_CSR_BASE_ADDR + 0x028)
+#define TMU_SYS_GEN_CON4		(TMU_CSR_BASE_ADDR + 0x02c)
+#define TMU_TEQ_DISABLE_DROPCHK		(TMU_CSR_BASE_ADDR + 0x030)
+#define TMU_TEQ_CTRL			(TMU_CSR_BASE_ADDR + 0x034)
+#define TMU_TEQ_QCFG			(TMU_CSR_BASE_ADDR + 0x038)
+#define TMU_TEQ_DROP_STAT		(TMU_CSR_BASE_ADDR + 0x03c)
+#define TMU_TEQ_QAVG			(TMU_CSR_BASE_ADDR + 0x040)
+#define TMU_TEQ_WREG_PROB		(TMU_CSR_BASE_ADDR + 0x044)
+#define TMU_TEQ_TRANS_STAT		(TMU_CSR_BASE_ADDR + 0x048)
+#define TMU_TEQ_HW_PROB_CFG0		(TMU_CSR_BASE_ADDR + 0x04c)
+#define TMU_TEQ_HW_PROB_CFG1		(TMU_CSR_BASE_ADDR + 0x050)
+#define TMU_TEQ_HW_PROB_CFG2		(TMU_CSR_BASE_ADDR + 0x054)
+#define TMU_TEQ_HW_PROB_CFG3		(TMU_CSR_BASE_ADDR + 0x058)
+#define TMU_TEQ_HW_PROB_CFG4		(TMU_CSR_BASE_ADDR + 0x05c)
+#define TMU_TEQ_HW_PROB_CFG5		(TMU_CSR_BASE_ADDR + 0x060)
+#define TMU_TEQ_HW_PROB_CFG6		(TMU_CSR_BASE_ADDR + 0x064)
+#define TMU_TEQ_HW_PROB_CFG7		(TMU_CSR_BASE_ADDR + 0x068)
+#define TMU_TEQ_HW_PROB_CFG8		(TMU_CSR_BASE_ADDR + 0x06c)
+#define TMU_TEQ_HW_PROB_CFG9		(TMU_CSR_BASE_ADDR + 0x070)
+#define TMU_TEQ_HW_PROB_CFG10		(TMU_CSR_BASE_ADDR + 0x074)
+#define TMU_TEQ_HW_PROB_CFG11		(TMU_CSR_BASE_ADDR + 0x078)
+#define TMU_TEQ_HW_PROB_CFG12		(TMU_CSR_BASE_ADDR + 0x07c)
+#define TMU_TEQ_HW_PROB_CFG13		(TMU_CSR_BASE_ADDR + 0x080)
+#define TMU_TEQ_HW_PROB_CFG14		(TMU_CSR_BASE_ADDR + 0x084)
+#define TMU_TEQ_HW_PROB_CFG15		(TMU_CSR_BASE_ADDR + 0x088)
+#define TMU_TEQ_HW_PROB_CFG16		(TMU_CSR_BASE_ADDR + 0x08c)
+#define TMU_TEQ_HW_PROB_CFG17		(TMU_CSR_BASE_ADDR + 0x090)
+#define TMU_TEQ_HW_PROB_CFG18		(TMU_CSR_BASE_ADDR + 0x094)
+#define TMU_TEQ_HW_PROB_CFG19		(TMU_CSR_BASE_ADDR + 0x098)
+#define TMU_TEQ_HW_PROB_CFG20		(TMU_CSR_BASE_ADDR + 0x09c)
+#define TMU_TEQ_HW_PROB_CFG21		(TMU_CSR_BASE_ADDR + 0x0a0)
+#define TMU_TEQ_HW_PROB_CFG22		(TMU_CSR_BASE_ADDR + 0x0a4)
+#define TMU_TEQ_HW_PROB_CFG23		(TMU_CSR_BASE_ADDR + 0x0a8)
+#define TMU_TEQ_HW_PROB_CFG24		(TMU_CSR_BASE_ADDR + 0x0ac)
+#define TMU_TEQ_HW_PROB_CFG25		(TMU_CSR_BASE_ADDR + 0x0b0)
+#define TMU_TDQ_IIFG_CFG		(TMU_CSR_BASE_ADDR + 0x0b4)
+#define TMU_TDQ0_SCH_CTRL		(TMU_CSR_BASE_ADDR + 0x0b8)	/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ. This is a global Enable for all schedulers in PHY0 */
+#define TMU_LLM_CTRL			(TMU_CSR_BASE_ADDR + 0x0bc)
+#define TMU_LLM_BASE_ADDR		(TMU_CSR_BASE_ADDR + 0x0c0)
+#define TMU_LLM_QUE_LEN			(TMU_CSR_BASE_ADDR + 0x0c4)
+#define TMU_LLM_QUE_HEADPTR		(TMU_CSR_BASE_ADDR + 0x0c8)
+#define TMU_LLM_QUE_TAILPTR		(TMU_CSR_BASE_ADDR + 0x0cc)
+#define TMU_LLM_QUE_DROPCNT		(TMU_CSR_BASE_ADDR + 0x0d0)
+#define TMU_INT_EN			(TMU_CSR_BASE_ADDR + 0x0d4)
+#define TMU_INT_SRC			(TMU_CSR_BASE_ADDR + 0x0d8)
+#define TMU_INQ_STAT			(TMU_CSR_BASE_ADDR + 0x0dc)
+#define TMU_CTRL			(TMU_CSR_BASE_ADDR + 0x0e0)
+
+#define TMU_MEM_ACCESS_ADDR		(TMU_CSR_BASE_ADDR + 0x0e4)	/**< [31] Mem Access Command. 0 = Internal Memory Read, 1 = Internal memory Write [27:24] Byte Enables of the Internal memory access [23:0] Address of the internal memory. This address is used to access both the PM and DM of all the PE's */
+#define TMU_MEM_ACCESS_WDATA		(TMU_CSR_BASE_ADDR + 0x0e8)	/**< Internal Memory Access Write Data */
+#define TMU_MEM_ACCESS_RDATA		(TMU_CSR_BASE_ADDR + 0x0ec)	/**< Internal Memory Access Read Data. The commands are blocked at the mem_access only */
+
+#define TMU_PHY0_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x0f0)	/**< [31:0] PHY0 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
+#define TMU_PHY1_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x0f4)	/**< [31:0] PHY1 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
+#define TMU_PHY2_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x0f8)	/**< [31:0] PHY2 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
+#define TMU_PHY3_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x0fc)	/**< [31:0] PHY3 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
+#define TMU_BMU_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x100)
+#define TMU_TX_CTRL			(TMU_CSR_BASE_ADDR + 0x104)
+
+#define TMU_BUS_ACCESS_WDATA		(TMU_CSR_BASE_ADDR + 0x108)
+#define TMU_BUS_ACCESS			(TMU_CSR_BASE_ADDR + 0x10c)
+#define TMU_BUS_ACCESS_RDATA		(TMU_CSR_BASE_ADDR + 0x110)
+
+#define TMU_PE_SYS_CLK_RATIO		(TMU_CSR_BASE_ADDR + 0x114)
+#define TMU_PE_STATUS			(TMU_CSR_BASE_ADDR + 0x118)
+#define TMU_TEQ_MAX_THRESHOLD		(TMU_CSR_BASE_ADDR + 0x11c)
+#define TMU_PHY4_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x134)	/**< [31:0] PHY4 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
+#define TMU_TDQ1_SCH_CTRL		(TMU_CSR_BASE_ADDR + 0x138)	/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ. This is a global Enable for all schedulers in PHY1 */
+#define TMU_TDQ2_SCH_CTRL		(TMU_CSR_BASE_ADDR + 0x13c)	/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ. This is a global Enable for all schedulers in PHY2 */
+#define TMU_TDQ3_SCH_CTRL		(TMU_CSR_BASE_ADDR + 0x140)	/**< [9:0] Scheduler Enable for each of the scheduler in the TDQ. This is a global Enable for all schedulers in PHY3 */
+#define TMU_BMU_BUF_SIZE		(TMU_CSR_BASE_ADDR + 0x144)
+#define TMU_PHY5_INQ_ADDR		(TMU_CSR_BASE_ADDR + 0x148)	/**< [31:0] PHY5 in queue address (must be initialized with one of the xxx_INQ_PKTPTR cbus addresses) */
+
+#define SW_RESET	(1 << 0)	/**< Global software reset */
+#define INQ_RESET	(1 << 2)
+#define TEQ_RESET	(1 << 3)
+#define TDQ_RESET	(1 << 4)
+#define PE_RESET	(1 << 5)
+#define MEM_INIT	(1 << 6)
+#define MEM_INIT_DONE	(1 << 7)
+#define LLM_INIT	(1 << 8)
+#define LLM_INIT_DONE	(1 << 9)
+
+typedef struct {
+	u32 llm_base_addr;
+	u32 llm_queue_len;
+} TMU_CFG;
+
+#endif /* _TMU_CSR_H_ */
diff --git a/drivers/net/pfe_eth/pfe/cbus/util_csr.h b/drivers/net/pfe_eth/pfe/cbus/util_csr.h
new file mode 100644
index 0000000..d67e849
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/cbus/util_csr.h
@@ -0,0 +1,43 @@
+#ifndef _UTIL_CSR_H_
+#define _UTIL_CSR_H_
+
+#define UTIL_VERSION			(UTIL_CSR_BASE_ADDR + 0x000)
+#define UTIL_TX_CTRL			(UTIL_CSR_BASE_ADDR + 0x004)
+#define UTIL_INQ_PKTPTR			(UTIL_CSR_BASE_ADDR + 0x010)
+
+#define UTIL_HDR_SIZE			(UTIL_CSR_BASE_ADDR + 0x014)
+
+#define UTIL_PE0_QB_DM_ADDR0		(UTIL_CSR_BASE_ADDR + 0x020)
+#define UTIL_PE0_QB_DM_ADDR1		(UTIL_CSR_BASE_ADDR + 0x024)
+#define UTIL_PE0_RO_DM_ADDR0		(UTIL_CSR_BASE_ADDR + 0x060)
+#define UTIL_PE0_RO_DM_ADDR1		(UTIL_CSR_BASE_ADDR + 0x064)
+
+#define UTIL_MEM_ACCESS_ADDR		(UTIL_CSR_BASE_ADDR + 0x100)
+#define UTIL_MEM_ACCESS_WDATA		(UTIL_CSR_BASE_ADDR + 0x104)
+#define UTIL_MEM_ACCESS_RDATA		(UTIL_CSR_BASE_ADDR + 0x108)
+
+#define UTIL_TM_INQ_ADDR		(UTIL_CSR_BASE_ADDR + 0x114)
+#define UTIL_PE_STATUS			(UTIL_CSR_BASE_ADDR + 0x118)
+
+#define UTIL_PE_SYS_CLK_RATIO		(UTIL_CSR_BASE_ADDR + 0x200)
+#define UTIL_AFULL_THRES		(UTIL_CSR_BASE_ADDR + 0x204)
+#define UTIL_GAP_BETWEEN_READS		(UTIL_CSR_BASE_ADDR + 0x208)
+#define UTIL_MAX_BUF_CNT		(UTIL_CSR_BASE_ADDR + 0x20c)
+#define UTIL_TSQ_FIFO_THRES		(UTIL_CSR_BASE_ADDR + 0x210)
+#define UTIL_TSQ_MAX_CNT		(UTIL_CSR_BASE_ADDR + 0x214)
+#define UTIL_IRAM_DATA_0		(UTIL_CSR_BASE_ADDR + 0x218)
+#define UTIL_IRAM_DATA_1		(UTIL_CSR_BASE_ADDR + 0x21c)
+#define UTIL_IRAM_DATA_2		(UTIL_CSR_BASE_ADDR + 0x220)
+#define UTIL_IRAM_DATA_3		(UTIL_CSR_BASE_ADDR + 0x224)
+
+#define UTIL_BUS_ACCESS_ADDR		(UTIL_CSR_BASE_ADDR + 0x228)
+#define UTIL_BUS_ACCESS_WDATA		(UTIL_CSR_BASE_ADDR + 0x22c)
+#define UTIL_BUS_ACCESS_RDATA		(UTIL_CSR_BASE_ADDR + 0x230)
+
+#define UTIL_INQ_AFULL_THRES		(UTIL_CSR_BASE_ADDR + 0x234)
+#define UTIL_MISC_REG			(UTIL_CSR_BASE_ADDR + 0x240)
+
+typedef struct {
+} UTIL_CFG;
+
+#endif /* _UTIL_CSR_H_ */
diff --git a/drivers/net/pfe_eth/pfe/class.h b/drivers/net/pfe_eth/pfe/class.h
new file mode 100644
index 0000000..33ad826
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/class.h
@@ -0,0 +1,142 @@
+#ifndef _CLASS_H_
+#define _CLASS_H_
+
+#define CLASS_DMEM_BASE_ADDR	0x00000000
+#define CLASS_DMEM_SIZE		0x2000
+#define CLASS_DMEM_END		(CLASS_DMEM_BASE_ADDR + CLASS_DMEM_SIZE)
+#define CLASS_PMEM_BASE_ADDR	0x00010000
+
+#define CBUS_BASE_ADDR		0xc0000000
+#define CLASS_APB_BASE_ADDR	0xc1000000
+#define CLASS_AHB1_BASE_ADDR	0xc2000000
+#define CLASS_AHB2_BASE_ADDR	0xc3000000
+
+#include "cbus.h"
+
+#define GPT_BASE_ADDR		(CLASS_APB_BASE_ADDR + 0x00000)
+#define UART_BASE_ADDR		(CLASS_APB_BASE_ADDR + 0x10000)
+#define PERG_BASE_ADDR		(CLASS_APB_BASE_ADDR + 0x20000)
+#define EFET_BASE_ADDR		(CLASS_APB_BASE_ADDR + 0x40000)
+
+#define MAC_HASH_BASE_ADDR	(CLASS_AHB1_BASE_ADDR + 0x30000)
+#define VLAN_HASH_BASE_ADDR	(CLASS_AHB1_BASE_ADDR + 0x50000)
+
+#define PE_LMEM_BASE_ADDR	(CLASS_AHB2_BASE_ADDR + 0x10000)
+#define PE_LMEM_SIZE		0x8000
+#define PE_LMEM_END		(PE_LMEM_BASE_ADDR + PE_LMEM_SIZE)
+#define CCU_BASE_ADDR		(CLASS_AHB2_BASE_ADDR + 0x20000)
+
+#define IS_DMEM(addr, len)	(((unsigned long)(addr) >= CLASS_DMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= CLASS_DMEM_END))
+#define IS_PE_LMEM(addr, len)	(((unsigned long)(addr) >= PE_LMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= PE_LMEM_END))
+
+
+#include "gpt.h"
+#include "uart.h"
+#include "class/perg.h"
+#include "class/efet.h"
+#include "class/mac_hash.h"
+#include "class/vlan_hash.h"
+#include "class/ccu.h"
+
+
+#define CLASS_MAX_PBUFFERS	4
+
+#define PBUF_HWPARSE_OFFSET	0x10	/* Fixed by hardware */
+
+#define PAYLOAD_DMEM_MAX_SIZE	(CLASS_PBUF_SIZE - CLASS_PBUF_HEADER_OFFSET - sizeof(class_rx_hdr_t))
+
+#define PHYPORT_0               0x0
+#define PHYPORT_1               0x1
+#define HOST_PORT_NO		0x3
+
+#define   ACT_SRC_MAC_REPLACE 	(1 << (4+0))
+#define   ACT_VLAN_REPLACE		(1 << (4+3))
+#define   ACT_TCPCHKSUM_REPLACE	(1 << (4+2))
+#define   ACT_VLAN_ADD			(1 << (4+1))
+
+#define MIN_PKT_SIZE		56
+
+#define PARSE_ETH_TYPE		(1 << 0)
+#define PARSE_VLAN_TYPE		(1 << 1)
+#define PARSE_PPPOE_TYPE	(1 << 2)
+#define PARSE_ARP_TYPE		(1 << 3)
+#define PARSE_MCAST_TYPE	(1 << 4)
+#define PARSE_IP_TYPE		(1 << 5)
+#define PARSE_IPV6_TYPE		(1 << 6)
+#define PARSE_IPV4_TYPE		(1 << 7)
+
+#define PARSE_IPX_TYPE		(1 << 9)
+
+#define PARSE_UDP_FLOW		(1 << 11)
+#define PARSE_TCP_FLOW		(1 << 12)
+#define PARSE_ICMP_FLOW		(1 << 13)
+#define PARSE_IGMP_FLOW		(1 << 14)
+#define PARSE_FRAG_FLOW		(1 << 15)
+
+#define PARSE_HIF_PKT		(1 << 23)
+#define PARSE_ARC_HIT		(1 << 24)
+#define PARSE_PKT_OVERFLOW	(1 << 25)
+
+#define PARSE_PROTO_MISMATCH	(1 << 28)
+#define PARSE_L3_MISMATCH	(1 << 29)
+#define PARSE_L2_MISMATCH	(1 << 30)
+#define PARSE_INCOMPLETE	(1 << 31)
+
+
+typedef struct _hwparse_t {
+	u16	sid;
+	u16	connid;
+	u8	toevec;
+	u8	pLayer2Hdr;
+	u8	pLayer3Hdr;
+	u8	pLayer4Hdr;
+	u16	vlanid;
+	u16	ifParseFlags;
+	u32	parseFlags;
+	u16	srcport;
+	u16	dstport;
+	u32	proto:8;
+	u32	port:4;
+	u32	hash:20;
+	u64	rte_res_valid:1;
+	u64	vlan_res_valid:1;
+	u64	dst_res_valid:1;
+	u64	src_res_valid:1;
+	u64	vlan_lookup:20;
+	u64	dst_lookup:20;
+	u64	src_lookup:20;
+} hwparse_t;
+
+
+typedef struct {
+	u32	next_ptr;	/* ptr to the start of the first DDR buffer */
+	u16	length;		/* total packet length */
+	u16	phyno;		/* input physical port number */
+	u32	status;		/* gemac status bits */
+	u32	res;		/* reserved for software usage */
+} class_rx_hdr_t;
+
+
+typedef struct {
+	u8	num_cpy;	/* no of copies to send out from RO block, for each there must be a corresponding tx pre-header */
+	u8	dma_len;	/* len to be DMAed to DDR mem, including all tx pre-headers */
+	u16	src_addr;	/* class dmem source address, pointing to first tx pre-header */
+	u32	dst_addr;	/* DDR memory destination address of first tx pre-header, must be so packet data is continuous in DDR */
+	u32	res1;		/* reserved for software usage - queue number? */
+	u16	res2;		/* reserved for software usage */
+	u16	tsv;		/* time stamp val */
+} class_tx_desc_t;
+
+
+typedef struct {
+	u8	start_data_off;		/* packet data start offset, relative to start of this tx pre-header */
+	u8	start_buf_off;		/* this tx pre-header start offset, relative to start of DDR buffer */
+	u16	pkt_length;		/* total packet lenght */
+	u8	act_phyno;		/* action phy number */
+	u8	queueno;		/* queueno */
+	u16	src_mac_msb;		/* indicates src_mac 47:32 */
+	u32	src_mac_lsb;		/* indicates src_mac 31:0 */
+	u32	vlanid;			/* vlanid */
+} class_tx_hdr_t;
+
+#endif /* _CLASS_H_ */
diff --git a/drivers/net/pfe_eth/pfe/class/ccu.h b/drivers/net/pfe_eth/pfe/class/ccu.h
new file mode 100644
index 0000000..2c43d97
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/class/ccu.h
@@ -0,0 +1,10 @@
+#ifndef _CCU_H_
+#define _CCU_H_
+
+#define CCU_ADDR	(CCU_BASE_ADDR + 0x00)
+#define CCU_CNT		(CCU_BASE_ADDR + 0x04)
+#define CCU_STATUS	(CCU_BASE_ADDR + 0x08)
+#define CCU_VAL		(CCU_BASE_ADDR + 0x0c)
+
+#endif /* _CCU_H_ */
+
diff --git a/drivers/net/pfe_eth/pfe/class/efet.h b/drivers/net/pfe_eth/pfe/class/efet.h
new file mode 100644
index 0000000..4f3cc25
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/class/efet.h
@@ -0,0 +1,21 @@
+#ifndef _CLASS_EFET_H_
+#define _CLASS_EFET_H_
+
+#define CLASS_EFET_ENTRY_ADDR		(EFET_BASE_ADDR + 0x00)
+#define CLASS_EFET_ENTRY_SIZE		(EFET_BASE_ADDR + 0x04)
+#define CLASS_EFET_ENTRY_DMEM_ADDR	(EFET_BASE_ADDR + 0x08)
+#define CLASS_EFET_ENTRY_STATUS		(EFET_BASE_ADDR + 0x0c)
+#define CLASS_EFET_ENTRY_ENDIAN		(EFET_BASE_ADDR + 0x10)
+
+#define CBUS2DMEM	0
+#define DMEM2CBUS	1
+
+#define EFET2BUS_LE     (1 << 0)
+#define PE2BUS_LE	(1 << 1)
+
+void class_efet(u32 cbus_addr, u32 dmem_addr, u32 len, u32 dir);
+void class_efet_wait(void);
+void class_efet_sync(u32 cbus_addr, u32 dmem_addr, u32 len, u32 dir);
+
+#endif /* _CLASS_EFET_H_ */
+
diff --git a/drivers/net/pfe_eth/pfe/class/mac_hash.h b/drivers/net/pfe_eth/pfe/class/mac_hash.h
new file mode 100644
index 0000000..68023b4
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/class/mac_hash.h
@@ -0,0 +1,28 @@
+#ifndef _MAC_HASH_H_
+#define _MAC_HASH_H_
+
+#define MAC_HASH_REQ1_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x000)
+#define MAC_HASH_REQ2_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x020)
+#define MAC_HASH_REQ3_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x040)
+#define MAC_HASH_REQ4_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x060)
+#define MAC_HASH_REQ5_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x080)
+#define MAC_HASH_REQ6_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x0a0)
+#define MAC_HASH_REQ7_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x0c0)
+#define MAC_HASH_REQ8_BASE_ADDR		(MAC_HASH_BASE_ADDR + 0x0e0)
+
+#define MAC_HASH_REQ_CMD(i)		(MAC_HASH_REQ##i##_BASE_ADDR + 0x000)
+#define MAC_HASH_REQ_MAC1_ADDR(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x004)
+#define MAC_HASH_REQ_MAC2_ADDR(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x008)
+#define MAC_HASH_REQ_MASK1_ADDR(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x00c)
+#define MAC_HASH_REQ_MASK2_ADDR(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x010)
+#define MAC_HASH_REQ_ENTRY(i)		(MAC_HASH_REQ##i##_BASE_ADDR + 0x014)
+#define MAC_HASH_REQ_STATUS(i)		(MAC_HASH_REQ##i##_BASE_ADDR + 0x018)
+#define MAC_HASH_REQ_ENTRY_MAYCH(i)	(MAC_HASH_REQ##i##_BASE_ADDR + 0x01c)
+
+
+#define MAC_HASH_FREELIST_PTR_HEAD	(MAC_HASH_BASE_ADDR + 0x100)
+#define MAC_HASH_FREELIST_PTR_TAIL	(MAC_HASH_BASE_ADDR + 0x104)
+#define MAC_HASH_FREELIST_ENTRIES_ADDR	(MAC_HASH_BASE_ADDR + 0x108)
+
+#endif /* _MAC_HASH_H_ */
+
diff --git a/drivers/net/pfe_eth/pfe/class/perg.h b/drivers/net/pfe_eth/pfe/class/perg.h
new file mode 100644
index 0000000..7297171
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/class/perg.h
@@ -0,0 +1,21 @@
+#ifndef _PERG_H_
+#define _PERG_H_
+
+#define PERG_QB_BUF_STATUS		(PERG_BASE_ADDR + 0x00)
+#define PERG_RO_BUF_STATUS		(PERG_BASE_ADDR + 0x04)
+#define PERG_CLR_QB_BUF_STATUS		(PERG_BASE_ADDR + 0x08)
+#define PERG_SET_RO_BUF_STATUS		(PERG_BASE_ADDR + 0x0c)
+#define PERG_CLR_RO_ERR_PKT		(PERG_BASE_ADDR + 0x10)
+#define PERG_CLR_BMU2_ERR_PKT		(PERG_BASE_ADDR + 0x14)
+
+#define PERG_ID				(PERG_BASE_ADDR + 0x18)
+#define PERG_TIMER1			(PERG_BASE_ADDR + 0x1c)
+#define PERG_TIMER2			(PERG_BASE_ADDR + 0x20)
+#define PERG_BUF1			(PERG_BASE_ADDR + 0x24)
+#define PERG_BUF2			(PERG_BASE_ADDR + 0x28)
+#define PERG_HOST_GP			(PERG_BASE_ADDR + 0x2c)
+#define PERG_PE_GP			(PERG_BASE_ADDR + 0x30)
+#define PERG_INT_ENABLE			(PERG_BASE_ADDR + 0x34)
+#define PERG_INT_SRC			(PERG_BASE_ADDR + 0x38)
+
+#endif /* _PERG_H_ */
diff --git a/drivers/net/pfe_eth/pfe/class/vlan_hash.h b/drivers/net/pfe_eth/pfe/class/vlan_hash.h
new file mode 100644
index 0000000..a54ac19
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/class/vlan_hash.h
@@ -0,0 +1,28 @@
+#ifndef _VLAN_HASH_H_
+#define _VLAN_HASH_H_
+
+#define VLAN_HASH_REQ1_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x000)
+#define VLAN_HASH_REQ2_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x020)
+#define VLAN_HASH_REQ3_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x040)
+#define VLAN_HASH_REQ4_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x060)
+#define VLAN_HASH_REQ5_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x080)
+#define VLAN_HASH_REQ6_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x0a0)
+#define VLAN_HASH_REQ7_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x0c0)
+#define VLAN_HASH_REQ8_BASE_ADDR	(VLAN_HASH_BASE_ADDR + 0x0e0)
+
+#define VLAN_HASH_REQ_CMD(i)		(VLAN_HASH_REQ##i##_BASE_ADDR + 0x000)
+#define VLAN_HASH_REQ_MAC1_ADDR(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x004)
+#define VLAN_HASH_REQ_MAC2_ADDR(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x008)
+#define VLAN_HASH_REQ_MASK1_ADDR(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x00c)
+#define VLAN_HASH_REQ_MASK2_ADDR(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x010)
+#define VLAN_HASH_REQ_ENTRY(i)		(VLAN_HASH_REQ##i##_BASE_ADDR + 0x014)
+#define VLAN_HASH_REQ_STATUS(i)		(VLAN_HASH_REQ##i##_BASE_ADDR + 0x018)
+#define VLAN_HASH_REQ_ENTRY_MAYCH(i)	(VLAN_HASH_REQ##i##_BASE_ADDR + 0x01c)
+
+
+#define VLAN_HASH_FREELIST_PTR_HEAD	(VLAN_HASH_BASE_ADDR + 0x100)
+#define VLAN_HASH_FREELIST_PTR_TAIL	(VLAN_HASH_BASE_ADDR + 0x104)
+#define VLAN_HASH_FREELIST_ENTRIES_ADDR	(VLAN_HASH_BASE_ADDR + 0x108)
+
+#endif /* _VLAN_HASH_H_ */
+
diff --git a/drivers/net/pfe_eth/pfe/gpt.h b/drivers/net/pfe_eth/pfe/gpt.h
new file mode 100644
index 0000000..d820277
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/gpt.h
@@ -0,0 +1,11 @@
+#ifndef _GPT_H_
+#define _GPT_H_
+
+#define GPT_VERSION		 (GPT_BASE_ADDR + 0x00)
+#define GPT_STATUS		 (GPT_BASE_ADDR + 0x04)
+#define GPT_CONFIG		 (GPT_BASE_ADDR + 0x08)
+#define GPT_COUNTER		 (GPT_BASE_ADDR + 0x0c)
+#define GPT_PERIOD		 (GPT_BASE_ADDR + 0x10)
+#define GPT_WIDTH		 (GPT_BASE_ADDR + 0x14)
+
+#endif /* _GPT_H_ */
diff --git a/drivers/net/pfe_eth/pfe/pe.h b/drivers/net/pfe_eth/pfe/pe.h
new file mode 100644
index 0000000..a3838f5
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/pe.h
@@ -0,0 +1,147 @@
+#ifndef _PE_H_
+#define _PE_H_
+
+#include "hal.h"
+
+#define DDR_BASE_ADDR		0x00020000
+#define DDR_END			0x86000000 /* This includes ACP and IRAM areas */
+#define IRAM_BASE_ADDR		0x83000000
+
+#define IS_DDR(addr, len)	(((unsigned long)(addr) >= DDR_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= DDR_END))
+
+typedef struct {
+
+} ddr_rx_hdr_t;
+
+typedef struct {
+
+} lmem_rx_hdr_t;
+
+
+typedef struct {
+
+} tmu_rx_hdr_t;
+
+typedef struct {
+
+} tmu_tx_hdr_t;
+
+typedef struct {
+
+} util_rx_hdr_t;
+
+
+struct pe_sync_mailbox
+{
+	u32 stop;
+	u32 stopped;
+};
+
+struct pe_msg_mailbox
+{
+	u32 dst;
+	u32 src;
+	u32 len;
+	u32 request;
+};
+
+/** Basic busy loop delay function
+*
+* @param cycles		Number of cycles to delay (actual cpu cycles should be close to 3 x cycles)
+*
+*/
+static inline void delay(u32 cycles)
+{
+	volatile int i;
+
+	for (i = 0; i < cycles; i++);
+}
+
+
+/** Read PE id
+*
+* @return	PE id (0 - 5 for CLASS-PE's, 6 - 9 for TMU-PE's, 10 for UTIL-PE)
+*
+*/
+static inline u32 esi_get_mpid(void)
+{
+	u32 mpid;
+
+	asm ("rcsr %0, Configuration, MPID" : "=d" (mpid));
+
+	return mpid;
+}
+
+/** 64bit aligned memory copy using efet.
+* Either the source or destination address must be in DMEM, the other address can be in LMEM or DDR.
+* Source, destination addresses and len must all be 64bit aligned.
+* Uses efet synchronous interface to copy the data.
+*
+* @param dst	Destination address to write to (must be 64bit aligned)
+* @param src	Source address to read from (must be 64bit aligned)
+* @param len	Number of bytes to copy (must be 64bit aligned)
+*
+*/
+void efet_memcpy64(void *dst, void *src, unsigned int len);
+
+
+/** Aligned memory copy using efet.
+* Either the source or destination address must be in DMEM, the other address can be in LMEM or DDR.
+* Both the source and destination must have the same 64bit alignment, there is no restriction on length.
+*
+* @param dst	Destination address to write to (must have the same 64bit alignment as src)
+* @param src	Source address to read from (must have the same 64bit alignment as dst)
+* @param len	Number of bytes to copy
+*
+*/
+void efet_memcpy(void *dst, void *src, unsigned int len);
+
+
+/** 32bit aligned memory copy.
+* Source and destination addresses must be 32bit aligned, there is no restriction on the length.
+*
+* @param dst		Destination address (must be 32bit aligned)
+* @param src		Source address (must be 32bit aligned)
+* @param len		Number of bytes to copy
+*
+*/
+void memcpy_aligned32(void *dst, void *src, unsigned int len);
+
+/** Aligned memory copy.
+* Source and destination addresses must have the same alignment
+* relative to 32bit boundaries (but otherwsie may have any alignment),
+* there is no restriction on the length.
+*
+* @param dst		Destination address
+* @param src		Source address (must have same 32bit alignment as dst)
+* @param len		Number of bytes to copy
+*
+*/
+void memcpy_aligned(void *dst, void *src, unsigned int len);
+
+
+/** Generic memory set.
+* Implements a generic memory set. Not very optimal (uses byte writes for the entire range)
+*
+*
+* @param dst		Destination address
+* @param val		Value to set memory to
+* @param len		Number of bytes to set
+*
+*/
+void memset(void *dst, u8 val, unsigned int len);
+
+/** Generic memory copy.
+* Implements generic memory copy. If source and destination have the same
+* alignment memcpy_aligned() is used, otherwise, we first align the destination
+* to a 32bit boundary (using byte copies) then the src, and finally use a loop
+* of read, shift, write
+*
+* @param dst		Destination address
+* @param src		Source address
+* @param len		Number of bytes to copy
+*
+*/
+void memcpy(void *dst, void *src, unsigned int len);
+
+#endif /* _PE_H_ */
diff --git a/drivers/net/pfe_eth/pfe/pfe.h b/drivers/net/pfe_eth/pfe/pfe.h
new file mode 100644
index 0000000..e8e2221
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/pfe.h
@@ -0,0 +1,250 @@
+#ifndef _PFE_H_
+#define _PFE_H_
+
+#define CLASS_DMEM_BASE_ADDR(i)	(0x00000000 | ((i) << 20))
+#define CLASS_IMEM_BASE_ADDR(i)	(0x00000000 | ((i) << 20)) /* Only valid for mem access register interface */
+#define CLASS_DMEM_SIZE		0x00002000
+#define CLASS_IMEM_SIZE		0x00008000
+
+#define TMU_DMEM_BASE_ADDR(i)	(0x00000000 + ((i) << 20))
+#define TMU_IMEM_BASE_ADDR(i)	(0x00000000 + ((i) << 20)) /* Only valid for mem access register interface */
+#define TMU_DMEM_SIZE		0x00000800
+#define TMU_IMEM_SIZE		0x00002000
+
+#define UTIL_DMEM_BASE_ADDR	0x00000000
+#define UTIL_DMEM_SIZE		0x00002000
+
+#define PE_LMEM_BASE_ADDR	0xc3010000
+#define PE_LMEM_SIZE		0x8000
+#define PE_LMEM_END		(PE_LMEM_BASE_ADDR + PE_LMEM_SIZE)
+
+#define DMEM_BASE_ADDR		0x00000000
+#define DMEM_SIZE		0x2000		/**< TMU has less... */
+#define DMEM_END		(DMEM_BASE_ADDR + DMEM_SIZE)
+
+#define PMEM_BASE_ADDR		0x00010000
+#define PMEM_SIZE		0x8000		/**< TMU has less... */
+#define PMEM_END		(PMEM_BASE_ADDR + PMEM_SIZE)
+
+
+/* Memory ranges check from PE point of view/memory map */
+#define IS_DMEM(addr, len)	(((unsigned long)(addr) >= DMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= DMEM_END))
+#define IS_PMEM(addr, len)	(((unsigned long)(addr) >= PMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= PMEM_END))
+#define IS_PE_LMEM(addr, len)	(((unsigned long)(addr) >= PE_LMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= PE_LMEM_END))
+
+#define IS_PFE_LMEM(addr, len)	(((unsigned long)(addr) >= CBUS_VIRT_TO_PFE(LMEM_BASE_ADDR)) && (((unsigned long)(addr) + (len)) <= CBUS_VIRT_TO_PFE(LMEM_END)))
+#define IS_PHYS_DDR(addr, len)	(((unsigned long)(addr) >= PFE_DDR_PHYS_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= PFE_DDR_PHYS_END))
+
+/* Host View Address */
+extern void *cbus_base_addr;
+extern void *ddr_base_addr;
+#define CBUS_BASE_ADDR		cbus_base_addr
+#define DDR_BASE_ADDR		ddr_base_addr
+
+/* PFE View Address */
+#define PFE_DDR_PHYS_BASE_ADDR	0x03800000      /**< DDR physical base address as seen by PE's. */
+#define PFE_DDR_PHYS_SIZE	0xC000000
+#define PFE_DDR_PHYS_END	(PFE_DDR_PHYS_BASE_ADDR + PFE_DDR_PHYS_SIZE)
+#define PFE_CBUS_PHYS_BASE_ADDR	0xc0000000	/**< CBUS physical base address as seen by PE's. */
+
+/* Host<->PFE Mapping */
+#define DDR_PFE_TO_VIRT(p)	((p ) + 0x80000000)
+#define CBUS_VIRT_TO_PFE(v)	(((v) - CBUS_BASE_ADDR) + PFE_CBUS_PHYS_BASE_ADDR)
+#define CBUS_PFE_TO_VIRT(p)	(((p) - PFE_CBUS_PHYS_BASE_ADDR) + CBUS_BASE_ADDR)
+
+#include "cbus.h"
+
+enum {
+	CLASS0_ID = 0,
+	CLASS1_ID,
+	CLASS2_ID,
+	CLASS3_ID,
+#if !defined(CONFIG_PLATFORM_PCI)
+	CLASS4_ID,
+	CLASS5_ID,
+#endif
+#if !defined(CONFIG_TMU_DUMMY)
+	TMU0_ID,
+	TMU1_ID,
+	TMU2_ID,
+	TMU3_ID,
+#else
+	TMU0_ID,
+#endif
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+	UTIL_ID,
+#endif
+	MAX_PE
+};
+
+#if !defined(CONFIG_PLATFORM_PCI)
+#define CLASS_MASK	((1 << CLASS0_ID) | (1 << CLASS1_ID) | (1 << CLASS2_ID) | (1 << CLASS3_ID) | (1 << CLASS4_ID) | (1 << CLASS5_ID))
+#define CLASS_MAX_ID	CLASS5_ID
+#else
+#define CLASS_MASK      ((1 << CLASS0_ID) | (1 << CLASS1_ID) | (1 << CLASS2_ID) | (1 << CLASS3_ID))
+#define CLASS_MAX_ID	CLASS3_ID
+#endif
+
+#if !defined(CONFIG_TMU_DUMMY)
+#if defined(CONFIG_LS1012A)
+#define TMU_MASK	((1 << TMU0_ID) | (1 << TMU1_ID) | (1 << TMU3_ID))
+#else
+#define TMU_MASK	((1 << TMU0_ID) | (1 << TMU1_ID) | (1 << TMU2_ID) | (1 << TMU3_ID))
+#endif
+#define TMU_MAX_ID	TMU3_ID
+#else
+#define TMU_MASK	(1 << TMU0_ID) 
+#define TMU_MAX_ID	TMU0_ID
+#endif
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+#define UTIL_MASK	(1 << UTIL_ID)
+#endif
+
+struct pe_sync_mailbox
+{
+	u32 stop;
+	u32 stopped;
+};
+
+struct pe_msg_mailbox
+{
+	u32 dst;
+	u32 src;
+	u32 len;
+	u32 request;
+};
+
+/** PE information.
+ * Structure containing PE's specific information. It is used to create
+ * generic C functions common to all PE's.
+ * Before using the library functions this structure needs to be initialized with the different registers virtual addresses
+ * (according to the ARM MMU mmaping). The default initialization supports a virtual == physical mapping.
+ *
+ */
+struct pe_info
+{
+	u32 dmem_base_addr;		/**< PE's dmem base address */
+	u32 pmem_base_addr;		/**< PE's pmem base address */
+	u32 pmem_size;			/**< PE's pmem size */
+
+	void *mem_access_wdata;		/**< PE's _MEM_ACCESS_WDATA register address */
+	void *mem_access_addr;		/**< PE's _MEM_ACCESS_ADDR register address */
+	void *mem_access_rdata;		/**< PE's _MEM_ACCESS_RDATA register address */
+};
+
+
+void pe_lmem_read(u32 *dst, u32 len, u32 offset);
+void pe_lmem_write(u32 *src, u32 len, u32 offset);
+
+void pe_dmem_memcpy_to32(int id, u32 dst, const void *src, unsigned int len);
+void pe_pmem_memcpy_to32(int id, u32 dst, const void *src, unsigned int len);
+
+u32 pe_pmem_read(int id, u32 addr, u8 size);
+
+void pe_dmem_write(int id, u32 val, u32 addr, u8 size);
+u32 pe_dmem_read(int id, u32 addr, u8 size);
+void class_bus_write(u32 val, u32 addr, u8 size);
+u32 class_bus_read(u32 addr, u8 size);
+void util_bus_write(u32 val, u32 addr, u8 size);
+u32 util_bus_read(u32 addr, u8 size);
+
+#define class_bus_readl(addr)			class_bus_read(addr, 4)
+#define class_bus_readw(addr)			class_bus_read(addr, 2)
+#define class_bus_readb(addr)			class_bus_read(addr, 1)
+
+#define class_bus_writel(val, addr)		class_bus_write(val, addr, 4)
+#define class_bus_writew(val, addr)		class_bus_write(val, addr, 2)
+#define class_bus_writeb(val, addr)		class_bus_write(val, addr, 1)
+
+#define pe_mem_readl(id, addr)			pe_mem_read(id, addr, 4)
+#define pe_mem_readw(id, addr)			pe_mem_read(id, addr, 2)
+#define pe_mem_readb(id, addr)			pe_mem_read(id, addr, 1)
+
+#define pe_mem_writel(id, val, addr)		pe_mem_write(id, val, addr, 4)
+#define pe_mem_writew(id, val, addr)		pe_mem_write(id, val, addr, 2)
+#define pe_mem_writeb(id, val, addr)		pe_mem_write(id, val, addr, 1)
+
+int pe_load_elf_section(int id, const void *data, Elf32_Shdr *shdr);
+
+void pfe_lib_init(void *cbus_base, void *ddr_base, unsigned long ddr_phys_base);
+void bmu_init(void *base, BMU_CFG *cfg);
+void bmu_reset(void *base);
+void bmu_enable(void *base);
+void bmu_disable(void *base);
+void bmu_set_config(void *base, BMU_CFG *cfg);
+
+#if 0
+void gemac_init(void *base, void *config);
+void gemac_set_speed(void *base, MAC_SPEED gem_speed);
+void gemac_set_duplex(void *base, int duplex);
+void gemac_set_mode(void *base, int mode);
+void gemac_enable_mdio(void *base);
+void gemac_disable_mdio(void *base);
+void gemac_set_mdc_div(void *base, MAC_MDC_DIV gem_mdcdiv);
+void gemac_enable(void *base);
+void gemac_disable(void *base);
+void gemac_enable_mdio(void *base);
+void gemac_disable_mdio(void *base);
+void gemac_reset(void *base);
+void gemac_set_address(void *base, SPEC_ADDR *addr);
+SPEC_ADDR gemac_get_address(void *base);
+void gemac_set_laddr1(void *base, MAC_ADDR *address);
+void gemac_set_laddr2(void *base, MAC_ADDR *address);
+void gemac_set_laddr3(void *base, MAC_ADDR *address);
+void gemac_set_laddr4(void *base, MAC_ADDR *address);
+void gemac_set_laddrN(void *base, MAC_ADDR *address, unsigned int entry_index);
+MAC_ADDR gem_get_laddr1(void *base);
+MAC_ADDR gem_get_laddr2(void *base);
+MAC_ADDR gem_get_laddr3(void *base);
+MAC_ADDR gem_get_laddr4(void *base);
+MAC_ADDR gem_get_laddrN(void *base, unsigned int entry_index);
+void gemac_set_config(void *base, GEMAC_CFG *cfg);
+void gemac_enable_copy_all(void *base);
+void gemac_disable_copy_all(void *base);
+void gemac_allow_broadcast(void *base);
+void gemac_no_broadcast(void *base);
+void gemac_enable_unicast(void *base);
+void gemac_disable_unicast(void *base);
+void gemac_enable_multicast(void *base);
+void gemac_disable_multicast(void *base);
+void gemac_enable_fcs_rx(void *base);
+void gemac_disable_fcs_rx(void *base);
+void gemac_enable_1536_rx(void *base);
+void gemac_disable_1536_rx(void *base);
+void gemac_enable_pause_rx(void *base);
+void gemac_disable_pause_rx(void *base);
+void gemac_enable_rx_checksum_offload(void *base);
+void gemac_disable_rx_checksum_offload(void *base);
+unsigned int * gemac_get_stats(void *base);
+void gemac_set_bus_width(void *base, int width);
+#endif
+
+void gpi_init(void *base, GPI_CFG *cfg);
+void gpi_reset(void *base);
+void gpi_enable(void *base);
+void gpi_disable(void *base);
+void gpi_set_config(void *base, GPI_CFG *cfg);
+
+void class_init(CLASS_CFG *cfg);
+void class_reset(void);
+void class_enable(void);
+void class_disable(void);
+void class_set_config(CLASS_CFG *cfg);
+
+void tmu_init(TMU_CFG *cfg);
+void tmu_enable(u32 pe_mask);
+void tmu_disable(u32 pe_mask);
+
+void util_init(UTIL_CFG *cfg);
+void util_reset(void);
+void util_enable(void);
+void util_disable(void);
+
+void hif_init(void);
+void hif_tx_enable(void);
+void hif_tx_disable(void);
+void hif_rx_enable(void);
+void hif_rx_disable(void);
+
+#endif /* _PFE_H_ */
diff --git a/drivers/net/pfe_eth/pfe/tmu.h b/drivers/net/pfe_eth/pfe/tmu.h
new file mode 100644
index 0000000..12eaf12
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/tmu.h
@@ -0,0 +1,48 @@
+#ifndef _TMU_H_
+#define _TMU_H_
+
+#define TMU_DMEM_BASE_ADDR	0x00000000
+#define TMU_PMEM_BASE_ADDR	0x00010000
+
+
+#define CBUS_BASE_ADDR		0xc0000000
+#define TMU_APB_BASE_ADDR	0xc1000000
+
+#include "cbus.h"
+
+#define GPT_BASE_ADDR		(TMU_APB_BASE_ADDR + 0x00000)
+#define UART_BASE_ADDR		(TMU_APB_BASE_ADDR + 0x10000)
+
+
+#define SHAPER0_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x020000)
+#define SHAPER1_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x030000)
+#define SHAPER2_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x040000)
+#define SHAPER3_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x050000)
+#define SHAPER4_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x060000)
+#define SHAPER5_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x070000)
+#define SHAPER6_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x080000)
+#define SHAPER7_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x090000)
+#define SHAPER8_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x0a0000)
+#define SHAPER9_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x0b0000)
+
+#define SCHED0_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x1c0000)
+#define SCHED1_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x1d0000)
+#define SCHED2_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x1e0000)
+#define SCHED3_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x1f0000)
+#define SCHED4_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x200000)
+#define SCHED5_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x210000)
+#define SCHED6_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x220000)
+#define SCHED7_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x230000)
+
+
+#define PHY_QUEUE_BASE_ADDR	(TMU_APB_BASE_ADDR + 0x260000)
+#define SHAPER_STATUS		(TMU_APB_BASE_ADDR + 0x270000) /**< [9:0] bitmask of shapers that have positive credit */
+
+
+#include "gpt.h"
+#include "uart.h"
+#include "tmu/shaper.h"
+#include "tmu/sched.h"
+#include "tmu/phy_queue.h"
+
+#endif /* _TMU_H_ */
diff --git a/drivers/net/pfe_eth/pfe/tmu/phy_queue.h b/drivers/net/pfe_eth/pfe/tmu/phy_queue.h
new file mode 100644
index 0000000..9eef9a9
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/tmu/phy_queue.h
@@ -0,0 +1,31 @@
+#ifndef _PHY_QUEUE_H_
+#define _PHY_QUEUE_H_
+
+#define PHY_QUEUE_SHAPER_STATUS	(PHY_QUEUE_BASE_ADDR + 0x00)	/**< [28:19] same as SHAPER_STATUS, [18:3] same as QUEUE_STATUS, [2:0] must be zero before a new packet may be dequeued */
+#define QUEUE_STATUS		(PHY_QUEUE_BASE_ADDR + 0x04)	/**< [15:0] bit mask of input queues with pending packets */
+
+#define QUEUE0_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x08)
+#define QUEUE1_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x0c)
+#define QUEUE2_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x10)
+#define QUEUE3_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x14)
+#define QUEUE4_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x18)
+#define QUEUE5_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x1c)
+#define QUEUE6_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x20)
+#define QUEUE7_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x24)
+#define QUEUE8_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x28)
+#define QUEUE9_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x2c)
+#define QUEUE10_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x30)
+#define QUEUE11_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x34)
+#define QUEUE12_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x38)
+#define QUEUE13_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x3c)
+#define QUEUE14_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x40)
+#define QUEUE15_PKT_LEN		(PHY_QUEUE_BASE_ADDR + 0x44)
+#define QUEUE_RESULT0		(PHY_QUEUE_BASE_ADDR + 0x48)	/**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1, TMU2->PHY2, TMU3->PHY3), [6:0] winner input queue number */
+#define QUEUE_RESULT1		(PHY_QUEUE_BASE_ADDR + 0x4c)	/**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1, TMU2->PHY2, TMU3->PHY4), [6:0] winner input queue number */
+#define QUEUE_RESULT2		(PHY_QUEUE_BASE_ADDR + 0x50)	/**< [7] set to one to indicate output PHY (TMU0->PHY0, TMU1->PHY1, TMU2->PHY2, TMU3->PHY5), [6:0] winner input queue number */
+#define QUEUE_GBL_PKTLEN	(PHY_QUEUE_BASE_ADDR + 0x5c)
+#define QUEUE_GBL_PKTLEN_MASK	(PHY_QUEUE_BASE_ADDR + 0x60)
+
+
+
+#endif /* _PHY_QUEUE_H_ */
diff --git a/drivers/net/pfe_eth/pfe/tmu/sched.h b/drivers/net/pfe_eth/pfe/tmu/sched.h
new file mode 100644
index 0000000..0c741cc
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/tmu/sched.h
@@ -0,0 +1,47 @@
+#ifndef _SCHED_H_
+#define _SCHED_H_
+
+/* Offsets from SCHEDx_BASE_ADDR */
+#define SCHED_CTRL			0x00
+#define SCHED_SLOT_TIME			0x04
+#define SCHED_RES			0x08
+#define SCHED_QUEUE_ALLOC0		0x0c
+#define SCHED_QUEUE_ALLOC1		0x10
+#define SCHED_BW			0x14
+#define SCHED_GUR_DEF_CTR		0x18
+#define SCHED_AVL_CTR			0x1c
+#define SCHED_QU0_WGHT			0x20
+#define SCHED_QU1_WGHT			0x24
+#define SCHED_QU2_WGHT			0x28
+#define SCHED_QU3_WGHT			0x2c
+#define SCHED_QU4_WGHT			0x30
+#define SCHED_QU5_WGHT			0x34
+#define SCHED_QU6_WGHT			0x38
+#define SCHED_QU7_WGHT			0x3c
+#define SCHED_QUE0_DEFICIT_CNT		0x40
+#define SCHED_QUE1_DEFICIT_CNT		0x44
+#define SCHED_QUE2_DEFICIT_CNT		0x48
+#define SCHED_QUE3_DEFICIT_CNT		0x4c
+#define SCHED_QUE4_DEFICIT_CNT		0x50
+#define SCHED_QUE5_DEFICIT_CNT		0x54
+#define SCHED_QUE6_DEFICIT_CNT		0x58
+#define SCHED_QUE7_DEFICIT_CNT		0x5c
+#define SCHED_PKT_LEN			0x60
+
+#define SCHED_CTRL_ALGOTYPE(x) 		(((x) & 0xf) << 0)
+#define SCHED_CTRL_CALQUOTA(x) 		(((x) & 0x1) << 4)
+#define SCHED_CTRL_ACTIVE_Q(x) 		(((x) & 0xff) << 8)
+#define SCHED_CTRL_SHARE_BW(x) 		(((x) & 0xff) << 16)
+#define SCHED_CTRL_BARROW_BW(x) 	(((x) & 0xff) << 24)
+
+#define SCHED_QUEUE_ALLOC0_QUEUEA(x)	(((x) & 0x1f) << 0)
+#define SCHED_QUEUE_ALLOC0_QUEUEB(x)	(((x) & 0x1f) << 8)
+#define SCHED_QUEUE_ALLOC0_QUEUEC(x)	(((x) & 0x1f) << 16)
+#define SCHED_QUEUE_ALLOC0_QUEUED(x)	(((x) & 0x1f) << 24)
+
+#define SCHED_QUEUE_ALLOC0_RES0(x)	(((x) & 0x7) << 5)
+#define SCHED_QUEUE_ALLOC0_RES1(x)	(((x) & 0x7) << 13)
+#define SCHED_QUEUE_ALLOC0_RES2(x)	(((x) & 0x7) << 21)
+#define SCHED_QUEUE_ALLOC0_RES3(x)	(((x) & 0x7) << 29)
+
+#endif /* _SCHED_H_ */
diff --git a/drivers/net/pfe_eth/pfe/tmu/shaper.h b/drivers/net/pfe_eth/pfe/tmu/shaper.h
new file mode 100644
index 0000000..76315f3
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/tmu/shaper.h
@@ -0,0 +1,19 @@
+#ifndef _SHAPER_H_
+#define _SHAPER_H_
+
+/* Offsets from SHAPPERx_BASE_ADDR */
+#define SHAPER_CTRL		0x00
+#define SHAPER_WEIGHT		0x04
+#define SHAPER_PKT_LEN		0x08
+
+#define SHAPER_CTRL_ENABLE(x) 	(((x) & 0x1) << 0)
+#define SHAPER_CTRL_QNO(x) 	(((x) & 0x3f) << 1)
+#define SHAPER_CTRL_CLKDIV(x) 	(((x) & 0xffff) << 16)
+
+#define SHAPER_WEIGHT_FRACWT(x) 	(((x) & 0xff) << 0)
+#define SHAPER_WEIGHT_INTWT(x) 		(((x) & 0x3) << 8)
+#define SHAPER_WEIGHT_MAXCREDIT(x) 	(((x) & 0x3fffff) << 10)
+
+#define PORT_SHAPER_MASK (1 << 0)
+
+#endif /* _SHAPER_H_ */
diff --git a/drivers/net/pfe_eth/pfe/uart.h b/drivers/net/pfe_eth/pfe/uart.h
new file mode 100644
index 0000000..483d446
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/uart.h
@@ -0,0 +1,13 @@
+#ifndef _UART_H_
+#define _UART_H_
+
+#define UART_THR	(UART_BASE_ADDR + 0x00)
+#define UART_IER	(UART_BASE_ADDR + 0x04)
+#define UART_IIR	(UART_BASE_ADDR + 0x08)
+#define UART_LCR	(UART_BASE_ADDR + 0x0c)
+#define UART_MCR	(UART_BASE_ADDR + 0x10)
+#define UART_LSR	(UART_BASE_ADDR + 0x14)
+#define UART_MDR	(UART_BASE_ADDR + 0x18)
+#define UART_SCRATCH	(UART_BASE_ADDR + 0x1c)
+
+#endif /* _UART_H_ */
diff --git a/drivers/net/pfe_eth/pfe/util.h b/drivers/net/pfe_eth/pfe/util.h
new file mode 100644
index 0000000..fb2417c
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/util.h
@@ -0,0 +1,30 @@
+#ifndef _UTIL_H_
+#define _UTIL_H_
+
+#define UTIL_DMEM_BASE_ADDR	0x00000000
+#define UTIL_DMEM_SIZE		0x00002000
+#define UTIL_DMEM_END		(UTIL_DMEM_BASE_ADDR + UTIL_DMEM_SIZE)
+
+#define IS_DMEM(addr, len)	(((unsigned long)(addr) >= UTIL_DMEM_BASE_ADDR) && (((unsigned long)(addr) + (len)) <= UTIL_DMEM_END))
+
+#define CBUS_BASE_ADDR		0xc0000000
+#define UTIL_APB_BASE_ADDR	0xc1000000
+
+#include "cbus.h"
+
+#define GPT_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x00000)
+#define UART_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x10000)
+#define EAPE_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x20000)
+#define INQ_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x30000)
+#define EFET1_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x40000)
+#define EFET2_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x50000)
+#define EFET3_BASE_ADDR		(UTIL_APB_BASE_ADDR + 0x60000)
+
+
+#include "gpt.h"
+#include "uart.h"
+#include "util/eape.h"
+#include "util/inq.h"
+#include "util/efet.h"
+
+#endif /* _UTIL_H_ */
diff --git a/drivers/net/pfe_eth/pfe/util/eape.h b/drivers/net/pfe_eth/pfe/util/eape.h
new file mode 100644
index 0000000..07344dc
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/util/eape.h
@@ -0,0 +1,10 @@
+#ifndef _EAPE_H_
+#define _EAPE_H_
+
+#define EAPE_STATUS		(EAPE_BASE_ADDR + 0x0)
+#define EAPE_INT_ENABLE		(EAPE_BASE_ADDR + 0x4)
+#define EAPE_INT_SRC		(EAPE_BASE_ADDR + 0x8)
+#define EAPE_HOST_INT_ENABLE	(EAPE_BASE_ADDR + 0xc)
+
+
+#endif /* _EAPE_H_ */
diff --git a/drivers/net/pfe_eth/pfe/util/efet.h b/drivers/net/pfe_eth/pfe/util/efet.h
new file mode 100644
index 0000000..12d0310
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/util/efet.h
@@ -0,0 +1,20 @@
+#ifndef _UTIL_EFET_H_
+#define _UTIL_EFET_H_
+
+#define EFET_ENTRY_ADDR		0x00
+#define EFET_ENTRY_SIZE		0x04
+#define EFET_ENTRY_DMEM_ADDR	0x08
+#define EFET_ENTRY_STATUS	0x0c
+#define EFET_ENTRY_ENDIAN	0x10
+
+#define CBUS2DMEM	0
+#define DMEM2CBUS	1
+
+#define EFET2BUS_LE     (1 << 0)
+
+void util_efet(int i, u32 cbus_addr, u32 dmem_addr, u32 len, u8 dir);
+void util_efet_wait(int i);
+void util_efet_sync(int i, u32 cbus_addr, u32 dmem_addr, u32 len, u8 dir);
+
+#endif /* _UTIL_EFET_H_ */
+
diff --git a/drivers/net/pfe_eth/pfe/util/inq.h b/drivers/net/pfe_eth/pfe/util/inq.h
new file mode 100644
index 0000000..73d1acb
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe/util/inq.h
@@ -0,0 +1,10 @@
+#ifndef _INQ_H_
+#define _INQ_H_
+
+#define INQ_HOST_GP	(INQ_BASE_ADDR + 0x00) /* FIXME what are these for ? */
+#define INQ_UPE_GP	(INQ_BASE_ADDR + 0x04) /* FIXME what are these for ? */
+
+#define INQ_QB_PKTPTR	(INQ_BASE_ADDR + 0x08)
+#define INQ_FIFO_CNT	(INQ_BASE_ADDR + 0x0c)
+
+#endif /* _INQ_H_ */
diff --git a/drivers/net/pfe_eth/pfe_driver.c b/drivers/net/pfe_eth/pfe_driver.c
new file mode 100644
index 0000000..ca00e98
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe_driver.c
@@ -0,0 +1,710 @@
+/*
+ *  (C) Copyright 2011
+ *  Author : Mindspeed Technologes
+ *
+ *  See file CREDITS for list of people who contributed to this
+ *  project.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License as
+ *  published by the Free Software Foundation; either version 2 of
+ *  the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA 02111-1307 USA
+ * */
+
+
+#include "hal.h"
+#include "pfe/pfe.h"
+#include "pfe_driver.h"
+#include "pfe_firmware.h"
+
+
+static struct tx_desc_s *g_tx_desc = NULL;
+static struct rx_desc_s *g_rx_desc = NULL;
+
+#define wmb()	asm volatile("dsb st" : : : "memory")
+
+/** HIF Rx interface function
+ * Reads the rx descriptor from the current location (rxToRead).
+ * - If the descriptor has a valid data/pkt, then get the data pointer
+ * - check for the input rx phy number
+ * - increments the rx data pointer by pkt_head_room_size
+ * - decrements the data length by pkt_head_room_size
+ * - handover the packet to caller.
+ *
+ * @param[out]	pkt_ptr	Pointer to store rx packet pointer
+ * @param[out] phy_port Pointer to store recv phy port
+ *
+ * @return	-1 if no packet, else returns length of packet.
+ */
+int pfe_recv(unsigned int *pkt_ptr, int *phy_port)
+{
+	struct rx_desc_s *rx_desc = g_rx_desc;
+	struct bufDesc *bd;
+	int len = -1;
+	//volatile u32 ctrl;
+	struct hif_header_s *hif_header;
+
+	bd = rx_desc->rxBase + rx_desc->rxToRead;
+
+	if (bd->ctrl & BD_CTRL_DESC_EN)
+		return len; //No pending Rx packet
+
+	/* this len include hif_header(8bytes) */
+	len = bd->ctrl & 0xFFFF;
+
+	hif_header = (struct hif_header_s *)DDR_PFE_TO_VIRT(bd->data);
+
+
+	/* Get the recive port info from the packet */
+	dprint("Pkt recv'd: Pkt ptr(%p), len(%d), gemac_port(%d) status(%08x)\n",
+				hif_header, len, hif_header->port_no, bd->status);
+
+#if 0
+	{
+		int i;
+		unsigned char *p = (unsigned char *)hif_header;
+		for(i=0; i < len; i++) {
+			if(!(i % 16))
+				printf("\n");
+			printf(" %02x", p[i]);
+		}
+		printf("\n");
+	}
+#endif
+
+	*pkt_ptr = (unsigned int )(hif_header + 1);
+	*phy_port = hif_header->port_no;
+	len -= sizeof(struct hif_header_s);
+#if 0
+	/* reset bd control field */
+	ctrl = (MAX_FRAME_SIZE | BD_CTRL_DESC_EN | BD_CTRL_DIR);
+	bd->ctrl = ctrl;
+	bd->status = 0;
+
+	rx_desc->rxToRead = (rx_desc->rxToRead + 1) & (rx_desc->rxRingSize - 1);
+
+	/* Give START_STROBE to BDP to fetch the descriptor __NOW__,
+	 * BDP need not to wait for rx_poll_cycle time to fetch the descriptor,
+	 * In idle state (ie., no rx pkt), BDP will not fetch
+	 * the descriptor even if strobe is given(I think) */
+	writel((readl(HIF_RX_CTRL) | HIF_CTRL_BDP_CH_START_WSTB), HIF_RX_CTRL);
+#endif
+	return len;
+}
+
+void pfe_recv_ack(void)
+{
+	struct rx_desc_s *rx_desc = g_rx_desc;
+	struct bufDesc *bd;
+	volatile u32 ctrl;
+
+	bd = rx_desc->rxBase + rx_desc->rxToRead;
+
+	/* reset bd control field */
+	ctrl = (MAX_FRAME_SIZE | BD_CTRL_DESC_EN | BD_CTRL_DIR);
+	bd->ctrl = ctrl;
+	bd->status = 0;
+
+	rx_desc->rxToRead = (rx_desc->rxToRead + 1) & (rx_desc->rxRingSize - 1);
+
+	/* Give START_STROBE to BDP to fetch the descriptor __NOW__,
+	 * BDP need not to wait for rx_poll_cycle time to fetch the descriptor,
+	 * In idle state (ie., no rx pkt), BDP will not fetch
+	 * the descriptor even if strobe is given(I think) */
+	writel((readl(HIF_RX_CTRL) | HIF_CTRL_BDP_CH_START_WSTB), HIF_RX_CTRL);
+	return;
+}
+
+
+/** HIF Tx interface function
+ * This function sends a single packet to PFE from HIF interface.
+ * - No interrupt indication on tx completion.
+ * - After tx descriptor is updated and TX DMA is enabled.
+ * - To support both chipit and read c2k environment, data is copied to
+ *   tx buffers. After verification this copied can be avoided.
+ *
+ * @param[in] phy_port	Phy port number to send out this packet
+ * @param[in] data	Pointer to the data
+ * @param[in] length	Length of the ethernet packet to be transfered.
+ *
+ * @return -1 if tx Q is full, else returns the tx location where the pkt is placed.
+ */
+int pfe_send(int phy_port, void *data, int length)
+{
+	struct tx_desc_s *tx_desc = g_tx_desc;
+	struct bufDesc *bd;
+	struct hif_header_s hif_header;
+	u8 *tx_buf_va;
+	volatile u32 ctrl_word;
+
+	dprint("%s:pkt: %p, len: %d, txBase: %p, txToSend: %d\n", __func__,
+			data, length, tx_desc->txBase, tx_desc->txToSend);
+
+	bd = tx_desc->txBase + tx_desc->txToSend;
+
+	/* check queue-full condition */
+	if (bd->ctrl & BD_CTRL_DESC_EN) {
+		printf("Tx queue full\n");
+		return -1;
+	}
+
+	/* PFE checks for min pkt size */
+	if (length < MIN_PKT_SIZE) {
+		length = MIN_PKT_SIZE;
+	}
+
+	tx_buf_va = (u8 *)DDR_PFE_TO_VIRT(bd->data);
+	dprint("%s: tx_buf_va: %p, tx_buf_pa: %08x\n", __func__, tx_buf_va, bd->data);
+
+	/* Fill the gemac/phy port number to send this packet out */
+	memset(&hif_header, 0 ,  sizeof(struct hif_header_s));
+	hif_header.port_no = phy_port;
+
+	memcpy(tx_buf_va, (u8 *)&hif_header, sizeof(struct hif_header_s));
+	memcpy(tx_buf_va + sizeof(struct hif_header_s), data, length);
+	length += sizeof(struct hif_header_s);
+
+#if 0
+	{
+		int i;
+		unsigned char *p = (unsigned char *)tx_buf_va;
+		for(i=0; i < length; i++) {
+			if (!(i % 16)) printf("\n");
+			printf("%02x ", p[i]);
+		}
+	}
+#endif
+
+	dprint("before0: Tx Done, status: %08x, ctrl: %08x\n", bd->status, bd->ctrl);
+
+	/* fill the tx desc */
+	ctrl_word = (u32)(BD_CTRL_DESC_EN | BD_CTRL_LIFM | (length & 0xFFFF));
+	bd->ctrl = ctrl_word;
+	bd->status = 0;
+
+	/* NOTE: This code can be removed after verification */
+#if 1 //SRAM_RETENTION_BUG
+	ctrl_word = 0;
+	bd->status = 0xF0;
+	ctrl_word = bd->ctrl;
+	//printf("0: contrl word: %08x\n", ctrl_word);
+#endif
+	wmb();
+
+	/* Indicate Tx DMA to start fetching the Tx Descriptor,
+    	 * set START_STOBE */
+	//writel((readl(HIF_TX_CTRL) | HIF_TX_BDP_CH_START_WSTB), HIF_TX_CTRL);
+	//writel((readl(HIF_TX_CTRL) | (HIF_TX_DMA_EN | HIF_TX_BDP_CH_START_WSTB)), HIF_TX_CTRL);
+	writel((HIF_CTRL_DMA_EN | HIF_CTRL_BDP_CH_START_WSTB), HIF_TX_CTRL);
+
+	udelay(100);
+
+	return tx_desc->txToSend;
+}
+
+/** HIF to check the Tx done
+ *  This function will chceck the tx done indication of the current txToSend locations
+ *  if success, moves the txToSend to next location.
+ *
+ * @return -1 if TX ownership bit is not cleared by hw.
+			  else on success (tx done copletion) returns zero.
+ */
+int pfe_tx_done(void)
+{
+	struct tx_desc_s *tx_desc = g_tx_desc;
+	struct bufDesc *bd;
+	volatile u32 ctrl_word;
+
+	dprint("%s:txBase: %p, txToSend: %d\n", __func__, tx_desc->txBase, tx_desc->txToSend);
+
+	bd = tx_desc->txBase + tx_desc->txToSend;
+
+	/* check queue-full condition */
+	ctrl_word = bd->ctrl;
+	if (ctrl_word & BD_CTRL_DESC_EN)
+		return -1;
+
+	/* reset the control field */
+	bd->ctrl = 0;
+	//bd->data = (u32)NULL;
+	bd->status = 0;
+
+	dprint("Tx Done : status: %08x, ctrl: %08x\n", bd->status, bd->ctrl);
+
+	/* increment the txtosend index to next location */
+	tx_desc->txToSend = (tx_desc->txToSend + 1) & (tx_desc->txRingSize - 1);
+
+	dprint("Tx next pkt location: %d\n", tx_desc->txToSend);
+
+	return 0;
+}
+#if defined CONFIG_LS1024A
+/** GEMAC initialization
+ * Initializes the GEMAC registers.
+ *
+ * @param[in] gemac_base   Pointer to GEMAC reg base
+ * @param[in] mode GEMAC mode to configure (MII config)
+ * @param[in] speed GEMAC speed
+ * @param[in] duplex
+ */
+void pfe_gemac_init(void *gemac_base, u32 mode, u32 speed, u32 duplex)
+{
+	GEMAC_CFG gemac_cfg  = {
+		.mode = mode,
+		.speed = speed,
+		.duplex = duplex,
+	};
+
+	dprint("%s: gemac_base=%p\n", __func__, gemac_base);
+
+	gemac_init(gemac_base, &gemac_cfg);
+
+	//gemac_set_loop(gemac_base, LB_NONE);
+	//gemac_disable_copy_all(gemac_base);
+	//gemac_disable_rx_checksum_offload(gemac_base);
+
+	gemac_allow_broadcast(gemac_base);
+	gemac_disable_unicast(gemac_base); /* unicast hash disabled  */
+	gemac_disable_multicast(gemac_base); /* multicast hash disabled */
+	gemac_disable_fcs_rx(gemac_base);
+	gemac_disable_1536_rx(gemac_base);
+	gemac_enable_pause_rx(gemac_base);
+	gemac_enable_rx_checksum_offload(gemac_base);
+}
+#endif
+/** Helper function to dump Rx descriptors.
+ */
+void hif_rx_desc_dump(void)
+{
+	struct bufDesc *bd_va;
+	int i;
+	struct rx_desc_s *rx_desc;
+
+	if (g_rx_desc == NULL) {
+		printf("%s: HIF Rx desc no init \n", __func__);
+		return;
+	}
+
+	rx_desc = g_rx_desc;
+	bd_va = rx_desc->rxBase;
+
+	printf("HIF rx desc: base_va: %p, base_pa: %08x\n", rx_desc->rxBase, rx_desc->rxBase_pa);
+	for (i=0; i < rx_desc->rxRingSize; i++) {
+//		printf("status: %08x, ctrl: %08x, data: %08x, next: %p\n",
+//			bd_va->status, bd_va->ctrl, bd_va->data, bd_va->next);
+		bd_va++;
+	}
+}
+
+/** HIF Rx Desc initialization function.
+ */
+static int hif_rx_desc_init(struct pfe *pfe)
+{
+	u32 ctrl;
+	struct bufDesc *bd_va;
+	struct bufDesc *bd_pa;
+	struct rx_desc_s *rx_desc;
+	u32 rx_buf_pa;
+	int i;
+
+	/* sanity check */
+	if (g_rx_desc) {
+		printf("%s: HIF Rx desc re-init request\n", __func__);
+		return 0;
+	}
+
+	rx_desc = (struct rx_desc_s *)malloc(sizeof(struct rx_desc_s));
+	if (rx_desc == NULL) {
+		printf("%s:%d:Memory allocation failure\n", __func__, __LINE__);
+		return -1;
+	}
+	memset(rx_desc, 0 , sizeof(struct rx_desc_s));
+
+	/* init: Rx ring buffer */
+	rx_desc->rxRingSize = HIF_RX_DESC_NT;
+
+	/* NOTE: must be 64bit aligned  */
+	bd_va = (struct bufDesc *)(pfe->ddr_baseaddr + RX_BD_BASEADDR);
+	bd_pa = (struct bufDesc *)(pfe->ddr_phys_baseaddr + RX_BD_BASEADDR);
+
+	rx_desc->rxBase = bd_va;
+	rx_desc->rxBase_pa = (unsigned long)bd_pa;
+
+	rx_buf_pa = pfe->ddr_phys_baseaddr + HIF_RX_PKT_DDR_BASEADDR;
+
+
+	printf("%s: Rx desc base: %p, base_pa: %08x, desc_count: %d\n",
+		__func__, rx_desc->rxBase, rx_desc->rxBase_pa, rx_desc->rxRingSize);
+
+	memset(bd_va, 0, sizeof(struct bufDesc) * rx_desc->rxRingSize);
+
+	ctrl = (MAX_FRAME_SIZE | BD_CTRL_DESC_EN | BD_CTRL_DIR | BD_CTRL_LIFM);
+	for (i=0; i < rx_desc->rxRingSize; i++) {
+		bd_va->next = (u32 )(bd_pa + 1);
+		bd_va->ctrl = ctrl;
+		bd_va->data = rx_buf_pa + (i * MAX_FRAME_SIZE);
+//		printf("status: %08x, ctrl: %08x, data: %08x, next: %p\n",
+//			bd_va->status, bd_va->ctrl, bd_va->data, bd_va->next);
+		bd_va++;
+		bd_pa++;
+	}
+	--bd_va;
+	bd_va->next = (u32 )rx_desc->rxBase_pa;
+
+	/* !!! This is a redundent information for h/w as we are also
+		maintaining next address in the buffer descriptor
+		Posedge: reference code does not using this bit to go back to base address */
+	//bd->ctrl |= BD_CTRL_LAST_BD;
+
+	writel(rx_desc->rxBase_pa, HIF_RX_BDP_ADDR);
+	writel((readl(HIF_RX_CTRL) | HIF_CTRL_BDP_CH_START_WSTB), HIF_RX_CTRL);
+
+	g_rx_desc = rx_desc;
+
+	return 0;
+}
+
+/** Helper function to dump Tx Descriptors.
+ */
+void hif_tx_desc_dump(void)
+{
+	struct tx_desc_s *tx_desc;
+	int i;
+	struct bufDesc *bd_va;
+
+	if (g_tx_desc == NULL) {
+		printf("%s: HIF Tx desc no init \n", __func__);
+		return;
+	}
+
+	tx_desc = g_tx_desc;
+	bd_va = tx_desc->txBase;
+
+	printf("HIF tx desc: base_va: %p, base_pa: %08x\n", tx_desc->txBase, tx_desc->txBase_pa);
+	for (i=0; i < tx_desc->txRingSize; i++) {
+//		printf("status: %08x, ctrl: %08x, data: %08x, next: %p\n",
+//			bd_va->status, bd_va->ctrl, bd_va->data, bd_va->next);
+		bd_va++;
+	}
+}
+
+/** HIF Tx descriptor initialization function.
+ */
+static int hif_tx_desc_init(struct pfe *pfe)
+{
+	struct bufDesc *bd_va;
+	struct bufDesc *bd_pa;
+	int i;
+	struct tx_desc_s *tx_desc;
+	u32 tx_buf_pa;
+
+	/* sanity check */
+	if (g_tx_desc) {
+		printf("%s: HIF Tx desc re-init request\n", __func__);
+		return 0;
+	}
+
+	tx_desc = (struct tx_desc_s *)malloc(sizeof(struct tx_desc_s));
+	if (tx_desc == NULL) {
+		printf("%s:%d:Memory allocation failure\n", __func__, __LINE__);
+		return -1;
+	}
+	memset(tx_desc, 0 , sizeof(struct tx_desc_s));
+
+	/* init: Tx ring buffer */
+	tx_desc->txRingSize = HIF_TX_DESC_NT;
+	/* NOTE: must be 64bit aligned  */
+	bd_va = (struct bufDesc *)(pfe->ddr_baseaddr + TX_BD_BASEADDR);
+	bd_pa = (struct bufDesc *)(pfe->ddr_phys_baseaddr + TX_BD_BASEADDR);
+
+	tx_desc->txBase_pa = (unsigned long)bd_pa;
+	tx_desc->txBase = bd_va;
+
+	printf("%s: Tx desc_base: %p, base_pa: %08x, desc_count: %d\n",
+			__func__, tx_desc->txBase, tx_desc->txBase_pa, tx_desc->txRingSize);
+
+	memset(bd_va, 0, sizeof(struct bufDesc) * tx_desc->txRingSize);
+
+	tx_buf_pa = pfe->ddr_phys_baseaddr + HIF_TX_PKT_DDR_BASEADDR;
+
+	for (i=0; i < tx_desc->txRingSize; i++) {
+		bd_va->next = (u32 )(bd_pa + 1);
+		bd_va->data = tx_buf_pa + (i * MAX_FRAME_SIZE);
+//		printf("status: %08x, ctrl: %08x, data: %08x, next: %p\n",
+//			bd_va->status, bd_va->ctrl, bd_va->data, bd_va->next);
+		bd_va++;
+		bd_pa++;
+	}
+	--bd_va;
+	bd_va->next = (u32 )tx_desc->txBase_pa;
+//	printf("status: %08x, ctrl: %08x, data: %08x, next: %p\n",
+//		bd_va->status, bd_va->ctrl, bd_va->data, bd_va->next);
+
+	/* !!! This is a redundent information for h/w as we are also
+		maintaining next address in the buffer descriptor,
+		Posedge: reference code does not using LAST_BD for moving back to base address */
+	//bd->ctrl |= BD_CTRL_LAST_BD;
+
+	writel(tx_desc->txBase_pa, HIF_TX_BDP_ADDR);
+
+	g_tx_desc = tx_desc;
+
+	return 0;
+}
+
+/** PFE/Class initialization.
+ */
+static void pfe_class_init(struct pfe *pfe)
+{
+	CLASS_CFG class_cfg = {
+		.route_table_baseaddr = pfe->ddr_phys_baseaddr + ROUTE_TABLE_BASEADDR,
+		.route_table_hash_bits = ROUTE_TABLE_HASH_BITS,
+	};
+
+	class_init(&class_cfg);
+	printf("class init complete\n");
+}
+
+/** PFE/TMU initialization.
+ */
+static void pfe_tmu_init(struct pfe *pfe)
+{
+	TMU_CFG tmu_cfg = {
+		.llm_base_addr = pfe->ddr_phys_baseaddr + TMU_LLM_BASEADDR,
+		.llm_queue_len = TMU_LLM_QUEUE_LEN,
+	};
+
+	tmu_init(&tmu_cfg);
+	printf("tmu init complete\n");
+}
+
+/** PFE/BMU (both BMU1 & BMU2) initialization.
+ */
+static void pfe_bmu_init(struct pfe *pfe)
+{
+	BMU_CFG bmu1_cfg = {
+		.baseaddr = CBUS_VIRT_TO_PFE(LMEM_BASE_ADDR + BMU1_LMEM_BASEADDR),
+		.count = BMU1_BUF_COUNT,
+		.size = BMU1_BUF_SIZE,
+	};
+
+	BMU_CFG bmu2_cfg = {
+		.baseaddr = pfe->ddr_phys_baseaddr + BMU2_DDR_BASEADDR,
+		.count = BMU2_BUF_COUNT,
+		.size = BMU2_BUF_SIZE,
+	};
+
+	bmu_init(BMU1_BASE_ADDR, &bmu1_cfg);
+	printf("bmu1 init: done\n");
+
+	bmu_init(BMU2_BASE_ADDR, &bmu2_cfg);
+	printf("bmu2 init: done\n");
+}
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+/** PFE/Util initialization function.
+ */
+static void pfe_util_init(struct pfe *pfe)
+{
+	UTIL_CFG util_cfg = { };
+
+	util_init(&util_cfg);
+	printf("util init complete\n");
+}
+#endif
+
+/** PFE/GPI initialization function.
+ *  - egpi1, egpi2, egpi3, hgpi
+ */
+static void pfe_gpi_init(struct pfe *pfe)
+{
+	GPI_CFG egpi1_cfg = {
+		.lmem_rtry_cnt = EGPI1_LMEM_RTRY_CNT,
+		.tmlf_txthres = EGPI1_TMLF_TXTHRES,
+		.aseq_len = EGPI1_ASEQ_LEN,
+	};
+
+	GPI_CFG egpi2_cfg = {
+		.lmem_rtry_cnt = EGPI2_LMEM_RTRY_CNT,
+		.tmlf_txthres = EGPI2_TMLF_TXTHRES,
+		.aseq_len = EGPI2_ASEQ_LEN,
+	};
+
+#if 0
+	GPI_CFG egpi3_cfg = {
+		.lmem_rtry_cnt = EGPI3_LMEM_RTRY_CNT,
+		.tmlf_txthres = EGPI3_TMLF_TXTHRES,
+		.aseq_len = EGPI3_ASEQ_LEN,
+	};
+#endif
+
+	GPI_CFG hgpi_cfg = {
+		.lmem_rtry_cnt = HGPI_LMEM_RTRY_CNT,
+		.tmlf_txthres = HGPI_TMLF_TXTHRES,
+		.aseq_len = HGPI_ASEQ_LEN,
+	};
+
+	gpi_init(EGPI1_BASE_ADDR, &egpi1_cfg);
+	printf("GPI1 init complete\n");
+
+   gpi_init(EGPI2_BASE_ADDR, &egpi2_cfg);
+	printf("GPI2 init complete\n");
+
+#if 0
+   gpi_init(EGPI3_BASE_ADDR, &egpi3_cfg);
+#endif
+
+   gpi_init(HGPI_BASE_ADDR, &hgpi_cfg);
+	printf("HGPI init complete\n");
+}
+
+
+/** PFE/HIF initialization function.
+ */
+static void pfe_hif_init(struct pfe *pfe)
+{
+	hif_tx_disable();
+	hif_rx_disable();
+
+	hif_tx_desc_init(pfe);
+	hif_rx_desc_init(pfe);
+
+	hif_init();
+
+	hif_tx_enable();
+	hif_rx_enable();
+
+	hif_rx_desc_dump();
+	hif_tx_desc_dump();
+
+	printf("HIF init complete\n");
+}
+
+/** PFE initialization
+ * - Firmware loading (CLASS-PE and TMU-PE)
+ * - BMU1 and BMU2 init
+ * - GEMAC init
+ * - GPI init
+ * - CLASS-PE init
+ * - TMU-PE init
+ * - HIF tx and rx descriptors init
+ *
+ * @param[in]	edev	Pointer to eth device structure.
+ *
+ * @return 0, on success.
+ */
+static int pfe_hw_init(struct pfe *pfe)
+{
+
+	dprint("%s: start \n", __func__);
+#if defined (CONFIG_LS1012A)
+	/*This clock workaround needed for LS1012 */
+	writel(0x3,     CLASS_PE_SYS_CLK_RATIO);
+	writel(0x3,	TMU_PE_SYS_CLK_RATIO);
+	writel(0x3,     UTIL_PE_SYS_CLK_RATIO);
+	udelay(10);
+#endif
+
+	pfe_class_init(pfe);
+
+	pfe_tmu_init(pfe);
+
+	pfe_bmu_init(pfe);
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+	pfe_util_init(pfe);
+#endif
+
+	pfe_gpi_init(pfe);
+
+	pfe_hif_init(pfe);
+
+	bmu_enable(BMU1_BASE_ADDR);
+	printf("bmu1 enabled\n");
+
+	bmu_enable(BMU2_BASE_ADDR);
+	printf("bmu2 enabled\n");
+
+	printf("%s: done\n", __func__);
+
+	/* NOTE: Load PE specific data (if any) */
+
+	return 0;
+}
+
+
+/** PFE probe function.
+ * - Initializes pfe_lib
+ * - pfe hw init
+ * - fw loading and enables PEs
+ * - should be executed once.
+ *
+ * @param[in] pfe  Pointer the pfe control block
+ */
+int pfe_probe(struct pfe *pfe)
+{
+	static int init_done = 0;
+
+	if (init_done)
+		return 0;
+
+	printf("cbus_baseaddr: %p, ddr_baseaddr: %p, ddr_phys_baseaddr: %08x\n",
+	             pfe->cbus_baseaddr, pfe->ddr_baseaddr, (u32)pfe->ddr_phys_baseaddr);
+
+	pfe_lib_init(pfe->cbus_baseaddr, pfe->ddr_baseaddr, pfe->ddr_phys_baseaddr);
+
+
+	pfe_hw_init(pfe);
+
+	/* Load the class,TM, Util fw
+    * by now pfe is,
+    * - out of reset + disabled + configured,
+    * Fw loading should be done after pfe_hw_init() */
+#ifdef CONFIG_CMD_PFE_START
+	/* It loads firmware from DDR locations Class@0x100000 TMU@0x180000  UTIL@200000*/
+	//For this firmware should be preloaded in DDR
+	//pfe_firmware_init((u8 *)0x80100000, (u8 *)0x80180000, 0x80200000);
+	pfe_firmware_init(NULL, NULL, NULL);
+#else
+	/*It loads default inbuilt sbl firmware */
+	pfe_firmware_init(NULL, NULL, NULL);
+#endif
+
+	init_done = 1;
+
+	return 0;
+}
+
+
+/** PFE remove function
+ *  - stopes PEs
+ *  - frees tx/rx descriptor resources
+ *  - should be called once.
+ *
+ * @param[in] pfe Pointer to pfe control block.
+ */
+int pfe_remove(struct pfe *pfe)
+{
+	if (g_tx_desc) {
+		free(g_tx_desc);
+	}
+
+	if (g_rx_desc) {
+		free(g_rx_desc);
+	}
+
+	pfe_firmware_exit();
+
+	return 0;
+}
+
diff --git a/drivers/net/pfe_eth/pfe_driver.h b/drivers/net/pfe_eth/pfe_driver.h
new file mode 100644
index 0000000..4d2e8b6
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe_driver.h
@@ -0,0 +1,141 @@
+/*
+ *  (C) Copyright 2011
+ *  Author : Mindspeed Technologes
+ *  
+ *  See file CREDITS for list of people who contributed to this
+ *  project.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License as
+ *  published by the Free Software Foundation; either version 2 of
+ *  the License, or (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA 02111-1307 USA
+ * */
+
+#ifndef __PFE_DRIVER_H__
+#define __PFE_DRIVER_H__
+
+#include "hal.h"
+
+#include "pfe/pfe.h"
+#include "pfe/cbus.h"
+#include "pfe/cbus/bmu.h"
+
+
+
+typedef struct bufDesc {
+	volatile u32 ctrl;
+	volatile u32 status;
+	volatile u32 data;
+	volatile u32 next;
+		 // struct bufDesc *next;
+}__attribute__((packed)) bufDesc_t;
+
+#if defined(CONFIG_PLATFORM_PCI)
+#define HIF_RX_DESC_NT		4
+#define	HIF_TX_DESC_NT		4
+#else
+#define HIF_RX_DESC_NT		64
+#define	HIF_TX_DESC_NT		64
+#endif
+#define RX_BD_BASEADDR		(HIF_DESC_BASEADDR)
+#define TX_BD_BASEADDR		(HIF_DESC_BASEADDR + HIF_TX_DESC_SIZE)
+
+#define MIN_PKT_SIZE   		56
+#define MAX_FRAME_SIZE     2048
+
+
+typedef struct hif_header_s {
+	u8	port_no; //Carries input port no for host rx packets and output port no for tx pkts
+	u8 reserved0;
+	u32 reserved2;
+} __attribute__((packed)) hif_header_t;
+
+
+typedef struct rx_desc_s {
+	struct bufDesc *rxBase;
+	unsigned int rxBase_pa;
+	int rxToRead;
+	int rxRingSize;
+}rx_desc_t;
+
+typedef struct tx_desc_s {
+	struct bufDesc *txBase;
+	unsigned int txBase_pa;
+	int txToSend;
+	int txRingSize;
+}tx_desc_t;
+
+
+/* The set of statistics registers implemented in the Cadence MAC.
+ * The statistics registers implemented are a subset of all the statistics
+ * available, but contains all the compulsory ones.
+ */
+typedef struct gem_stats{
+    u32 octets_tx_bot;      /* Lower 32-bits for number of octets tx'd */
+    u32 octets_tx_top;      /* Upper 16-bits for number of octets tx'd */
+    u32 frames_tx;          /* Number of frames transmitted OK */
+    u32 broadcast_tx;       /* Number of broadcast frames transmitted */
+    u32 multicast_tx;       /* Number of multicast frames transmitted */
+    u32 pause_tx;           /* Number of pause frames transmitted. */
+    u32 frame64_tx;         /* Number of 64byte frames transmitted */
+    u32 frame65_127_tx;     /* Number of 65-127 byte frames transmitted */
+    u32 frame128_255_tx;    /* Number of 128-255 byte frames transmitted */
+    u32 frame256_511_tx;    /* Number of 256-511 byte frames transmitted */
+    u32 frame512_1023_tx;   /* Number of 512-1023 byte frames transmitted */
+    u32 frame1024_1518_tx;  /* Number of 1024-1518 byte frames transmitted*/
+    u32 frame1519_tx;       /* Number of frames greater than 1518 bytes tx*/
+    u32 tx_urun;            /* Transmit underrun errors due to DMA */
+    u32 single_col;         /* Number of single collision frames */
+    u32 multi_col;          /* Number of multi collision frames */
+    u32 excess_col;         /* Number of excessive collision frames. */
+    u32 late_col;           /* Collisions occuring after slot time */
+    u32 def_tx;             /* Frames deferred due to crs */
+    u32 crs_errors;         /* Errors caused by crs not being asserted. */
+    u32 octets_rx_bot;      /* Lower 32-bits for number of octets rx'd */
+    u32 octets_rx_top;      /* Upper 16-bits for number of octets rx'd */
+    u32 frames_rx;          /* Number of frames received OK */
+    u32 broadcast_rx;       /* Number of broadcast frames received */
+    u32 multicast_rx;       /* Number of multicast frames received */
+    u32 pause_rx;           /* Number of pause frames received. */
+    u32 frame64_rx;         /* Number of 64byte frames received */
+    u32 frame65_127_rx;     /* Number of 65-127 byte frames received */
+    u32 frame128_255_rx;    /* Number of 128-255 byte frames received */
+    u32 frame256_511_rx;    /* Number of 256-511 byte frames received */
+    u32 frame512_1023_rx;   /* Number of 512-1023 byte frames received */
+    u32 frame1024_1518_rx;  /* Number of 1024-1518 byte frames received*/
+    u32 frame1519_rx;       /* Number of frames greater than 1518 bytes rx*/
+    u32 usize_frames;       /* Frames received less than min of 64 bytes */
+    u32 excess_length;      /* Number of excessive length frames rx */
+    u32 jabbers;            /* Excessive length + crc or align errors. */
+    u32 fcs_errors;         /* Number of frames received with crc errors */
+    u32 length_check_errors;/* Number of frames with incorrect length */
+    u32 rx_symbol_errors;   /* Number of times rx_er asserted during rx */
+    u32 align_errors;       /* Frames received without integer no. bytes */
+    u32 rx_res_errors;      /* Number of times buffers ran out during rx */
+    u32 rx_orun;            /* Receive overrun errors due to DMA */
+    u32 ip_cksum;           /* IP header checksum errors */
+    u32 tcp_cksum;           /* TCP checksum errors */
+    u32 udp_cksum;           /* UDP checksum errors */
+} volatile GEM_STATS;
+
+
+int pfe_send(int phy_port, void *data, int length);
+int pfe_recv(unsigned int *pkt_ptr, int *phy_port);
+void pfe_recv_ack(void);
+int pfe_tx_done(void);
+void pfe_gem_enable_all(void);
+void pfe_gemac_init(void *gemac_base, u32 mode, u32 speed, u32 duplex);
+
+
+#endif
+
diff --git a/drivers/net/pfe_eth/pfe_eth.c b/drivers/net/pfe_eth/pfe_eth.c
new file mode 100644
index 0000000..40ac095
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe_eth.c
@@ -0,0 +1,521 @@
+#include <common.h>
+#include <config.h>
+//#include <asm/arch/hardware.h>
+#include <asm/byteorder.h>
+#include <net.h>
+#include <command.h>
+#include <miiphy.h>
+#include "pfe_eth.h"
+
+struct gemac_s gem_info[] = {
+        /* PORT_0 configuration */
+        {
+                /* GEMAC config */
+                .gemac_mode = GMII,
+                .gemac_speed = SPEED_1000M,
+                .gemac_duplex = DUPLEX_FULL,
+
+                /* phy iface */
+                .phy_address = EMAC1_PHY_ADDR,
+		.phy_mode = PHY_INTERFACE_MODE_SGMII,
+        },
+        /* PORT_1 configuration */
+        {
+                /* GEMAC config */
+                .gemac_mode = GMII,
+                .gemac_speed = SPEED_1000M,
+                .gemac_duplex = DUPLEX_FULL,
+
+                /* phy iface */
+                .phy_address = EMAC2_PHY_ADDR,
+		.phy_mode = PHY_INTERFACE_MODE_RGMII,
+        },
+};
+
+#define MAX_GEMACS      2
+
+static struct ls1012a_eth_dev *gemac_list[MAX_GEMACS];
+
+/* Max MII register/address (we support) */
+#define MII_REGISTER_MAX  31
+#define MII_ADDRESS_MAX   31
+
+#define MDIO_TIMEOUT    5000
+
+
+static void ls1012a_gemac_enable(void *gemac_base)
+{
+        writel(readl(gemac_base + EMAC_ECNTRL_REG) | EMAC_ECNTRL_ETHER_EN, gemac_base + EMAC_ECNTRL_REG);	
+}
+
+static void ls1012a_gemac_dsable(void *gemac_base)
+{
+        writel(readl(gemac_base + EMAC_ECNTRL_REG) & ~EMAC_ECNTRL_ETHER_EN, gemac_base + EMAC_ECNTRL_REG);	
+}
+
+static void ls1012a_gemac_set_mode(void *gemac_base, u32 mode)
+{
+}
+
+static void ls1012a_gemac_set_speed(void *gemac_base, u32 speed)
+{
+	struct ccsr_scfg *scfg = (struct ccsr_scfg *)CONFIG_SYS_FSL_SCFG_ADDR;
+	u32 ecr = readl(gemac_base + EMAC_ECNTRL_REG) & ~EMAC_ECNTRL_SPEED;
+	u32 rcr = readl(gemac_base + EMAC_RCNTRL_REG) & ~EMAC_RCNTRL_RMII_10T;
+	u32 rgmii_pcr = in_be32(&scfg->rgmiipcr) & ~(SCFG_RGMIIPCR_SETSP_1000M|SCFG_RGMIIPCR_SETSP_10M);
+
+	if (speed == _1000BASET) {
+		ecr |= EMAC_ECNTRL_SPEED;
+		rgmii_pcr |= SCFG_RGMIIPCR_SETSP_1000M;
+	}
+	else if (speed != _100BASET){
+		rcr |= EMAC_RCNTRL_RMII_10T;
+		rgmii_pcr |= SCFG_RGMIIPCR_SETSP_10M;
+	}
+
+	writel(ecr, gemac_base + EMAC_ECNTRL_REG);
+	out_be32(&scfg->rgmiipcr, rgmii_pcr | SCFG_RGMIIPCR_SETFD);
+
+	/* remove loop back */
+	rcr &= ~EMAC_RCNTRL_LOOP;
+	/* enable flow control */
+	rcr |= EMAC_RCNTRL_FCE;
+
+	/* Enable MII mode */
+	rcr |= EMAC_RCNTRL_MII_MODE;
+
+	/* CRC field is stripped from the frame */
+	//rcr |= EMAC_RCNTRL_CRC_FWD;
+
+	/* Enable promiscuous mode
+	   FIXME should be removed later*/
+	//rcr |= EMAC_RCNTRL_PROM;
+	writel(rcr, gemac_base + EMAC_RCNTRL_REG);
+
+	/*Enable Tx full duplex */
+	writel(readl(gemac_base + EMAC_TCNTRL_REG ) | EMAC_TCNTRL_FDEN, gemac_base + EMAC_TCNTRL_REG);
+
+}
+
+static void ls1012a_gemac_set_ethaddr(void *gemac_base, uchar *mac)
+{
+        writel((mac[0] << 24) + (mac[1] << 16) + (mac[2] << 8) + mac[3], gemac_base + EMAC_PHY_ADDR_LOW);
+        writel((mac[4] << 24) + (mac[5] << 16) + 0x8808, gemac_base + EMAC_PHY_ADDR_HIGH);
+}
+
+/** Stops or Disables GEMAC pointing to this eth iface.
+ *
+ * @param[in]   edev    Pointer to eth device structure.
+ *
+ * @return      none
+ */
+static void ls1012a_eth_halt(struct eth_device *edev)
+{
+        struct ls1012a_eth_dev *priv = (struct ls1012a_eth_dev *)edev->priv;
+
+        ls1012a_gemac_enable(priv->gem->gemac_base);
+
+        gpi_disable(priv->gem->egpi_base);
+
+        return;
+}
+
+static int ls1012a_eth_init(struct eth_device *dev, bd_t * bd)
+{
+        struct ls1012a_eth_dev *priv = (struct ls1012a_eth_dev *)dev->priv;
+        struct gemac_s *gem = priv->gem;
+	int speed;
+	int tmp;
+
+        /* set ethernet mac address */
+        ls1012a_gemac_set_ethaddr(gem->gemac_base, dev->enetaddr);
+
+	//MAC will be always in GMII mode, it doesn't change with the link speed.
+	//ls1012a_gemac_set_mode(gem->gemac_base, gem->gemac_mode);
+
+	writel(0x00000004, gem->gemac_base + EMAC_TFWR_STR_FWD);
+	writel(0x00000005, gem->gemac_base + EMAC_RX_SECTIOM_FULL);
+	writel(0x00003fff, gem->gemac_base + EMAC_TRUNC_FL);
+	writel(0x00000030, gem->gemac_base + EMAC_TX_SECTION_EMPTY);
+	writel(0x00000000, gem->gemac_base + EMAC_MIB_CTRL_STS_REG);
+
+#ifndef CONFIG_EMU
+#ifdef CONFIG_PHYLIB
+	/* Start up the PHY */
+	//if(gem->phy_mode != PHY_INTERFACE_MODE_SGMII) {
+	if (phy_startup(priv->phydev)) {
+		printf("Could not initialize PHY %s\n",
+				priv->phydev->dev->name);
+		return -1;
+	}
+	speed = priv->phydev->speed;
+	printf("Speed detected %x\n", speed);
+	if(priv->phydev->duplex == DUPLEX_HALF) {
+		printf("Half duplex not supported \n");
+		return -1;
+	}
+#endif
+#else
+	/*in emulator it is always 1000Mbps */
+	speed = _1000BASET;
+#endif
+	ls1012a_gemac_set_speed(gem->gemac_base, speed);
+
+        /* Enable GPI */
+        gpi_enable(gem->egpi_base);
+
+        /* Enable GEMAC */
+        ls1012a_gemac_enable(gem->gemac_base);
+
+	return 0;
+
+}
+
+static int ls1012a_eth_send(struct eth_device *dev, void *data, int length)
+{
+        struct ls1012a_eth_dev *priv = (struct ls1012a_eth_dev *)dev->priv;
+
+        int rc;
+	int i=0;
+
+        rc = pfe_send(priv->gemac_port, data, length);
+
+        if (rc < 0) {
+                printf("Tx Q full\n");
+                return 0;
+        }
+
+        while (1) {
+                rc = pfe_tx_done();
+                if (rc == 0)
+                        break;
+		
+		udelay(100);
+		i++;
+		if(i == 30000)
+			printf("Tx timeout, send failed\n");
+			break;
+
+	}
+
+	return 0;
+}
+
+static int ls1012a_eth_recv(struct eth_device *dev)
+{
+        struct ls1012a_eth_dev *priv = (struct ls1012a_eth_dev *)dev->priv;
+        u32 pkt_buf;
+        int len;
+        int phy_port;
+
+        len = pfe_recv(&pkt_buf, &phy_port);
+
+        if (len < 0)
+                return 0; //no packet in rx
+
+        dprint("Rx pkt: pkt_buf(%08x), phy_port(%d), len(%d)\n", pkt_buf, phy_port, len);
+        if (phy_port != priv->gemac_port)  {
+                printf("Rx pkt not on expected port\n");
+		pfe_recv_ack();
+                return 0;
+        }
+
+	// Pass the packet up to the protocol layers.
+	net_process_received_packet((uchar *)pkt_buf, len);
+
+	pfe_recv_ack();
+	return 0;
+}
+
+#if defined(CONFIG_PHYLIB)
+
+#define MDIO_TIMEOUT    5000
+static int ls1012a_phy_read(struct mii_dev *bus, int phy_addr, int dev_addr, int reg_addr)
+{
+	void *reg_base = bus->priv;
+	u32 reg;
+	u32 phy;
+	u32 reg_data;
+	u16 val;
+	int timeout = MDIO_TIMEOUT;
+
+	reg = ((reg_addr & EMAC_MII_DATA_RA_MASK) << EMAC_MII_DATA_RA_SHIFT);
+	phy = ((phy_addr & EMAC_MII_DATA_PA_MASK) << EMAC_MII_DATA_PA_SHIFT);
+
+	reg_data = (EMAC_MII_DATA_ST | EMAC_MII_DATA_OP_RD | EMAC_MII_DATA_TA | phy | reg );
+
+	//dprint("%s write data %x %x %x\n", __func__, reg_data, reg_addr, phy_addr);
+	writel(reg_data, reg_base + EMAC_MII_DATA_REG);
+
+        /*
+         * wait for the MII interrupt
+         */
+	while(!(readl(reg_base + EMAC_IEVENT_REG) & EMAC_IEVENT_MII))
+	{
+		if (timeout-- <= 0) {
+			printf("Phy MDIO read/write timeout\n");
+			return -1;
+		}
+	}
+
+	/*
+         * clear MII interrupt
+         */
+        writel(EMAC_IEVENT_MII, reg_base + EMAC_IEVENT_REG);
+
+        /*
+         * it's now safe to read the PHY's register
+         */
+        val = (u16)readl(reg_base + EMAC_MII_DATA_REG);
+        dprint("%s: %x phy: %02x reg:%02x val:%#x\n", __func__, reg_base, phy_addr, reg_addr, val);
+
+        return val;
+}
+
+static int ls1012a_phy_write(struct mii_dev *bus, int phy_addr, int dev_addr, int reg_addr, u16 data)
+{
+	void *reg_base = bus->priv;
+	u32 reg;
+	u32 phy;
+	u32 reg_data;
+	int timeout = MDIO_TIMEOUT;
+	int val;
+
+	reg = ((reg_addr & EMAC_MII_DATA_RA_MASK) << EMAC_MII_DATA_RA_SHIFT);
+	phy = ((phy_addr & EMAC_MII_DATA_PA_MASK) << EMAC_MII_DATA_PA_SHIFT);
+
+	reg_data = (EMAC_MII_DATA_ST | EMAC_MII_DATA_OP_WR | EMAC_MII_DATA_TA | phy | reg | data);
+
+	//dprint("%s write data %x\n", __func__, reg_data);
+	writel(reg_data, reg_base + EMAC_MII_DATA_REG);
+
+        /*
+         * wait for the MII interrupt
+         */
+	while(!(readl(reg_base + EMAC_IEVENT_REG) & EMAC_IEVENT_MII))
+	{
+		if (timeout-- <= 0) {
+			printf("Phy MDIO read/write timeout\n");
+			return -1;
+		}
+	}
+
+	/*
+         * clear MII interrupt
+         */
+        writel(EMAC_IEVENT_MII, reg_base + EMAC_IEVENT_REG);
+
+        dprint("%s: phy: %02x reg:%02x val:%#x\n", __func__, phy_addr, reg_addr, data);
+
+        return val;
+}
+
+
+struct mii_dev *ls1012a_mdio_init(struct mdio_info *mdio_info)
+{
+        struct mii_dev *bus;
+        int ret;
+	u32 mdio_speed;
+	u32 pclk = 250000000;
+
+        bus = mdio_alloc();
+        if (!bus) {
+                printf("mdio_alloc failed\n");
+                return NULL;
+        }
+        bus->read = ls1012a_phy_read;
+        bus->write = ls1012a_phy_write;
+	/* MAC1 MDIO used to communicate with external PHYS */
+        bus->priv = mdio_info->reg_base;
+	sprintf(bus->name, mdio_info->name);
+
+	/*configure mdio speed */
+	mdio_speed = (DIV_ROUND_UP(pclk, 4000000) << EMAC_MII_SPEED_SHIFT);
+	mdio_speed |= EMAC_HOLDTIME(0x4);
+	writel(mdio_speed, mdio_info->reg_base + EMAC_MII_CTRL_REG);
+
+        ret = mdio_register(bus);
+        if (ret) {
+                printf("mdio_register failed\n");
+                free(bus);
+                return NULL;
+        }
+	return bus;
+}
+
+static void ls1012a_configure_serdes(struct ls1012a_eth_dev *priv)
+{
+	struct mii_dev bus;
+	int value,sgmii_2500=0;
+
+	printf("%s %d\n", __func__, priv->gemac_port);
+	/* PCS configuration done with corresponding GEMAC */
+	bus.priv = priv->gem->gemac_base;
+
+	ls1012a_phy_read(&bus, 0, MDIO_DEVAD_NONE, 0x0);
+	ls1012a_phy_read(&bus, 0, MDIO_DEVAD_NONE, 0x1);
+	ls1012a_phy_read(&bus, 0, MDIO_DEVAD_NONE, 0x2);
+	ls1012a_phy_read(&bus, 0, MDIO_DEVAD_NONE, 0x3);
+#if 0
+	/*These settings taken from validtion team */
+	ls1012a_phy_write(&bus, 0, MDIO_DEVAD_NONE, 0x0, 0x8000);
+	ls1012a_phy_write(&bus, 0, MDIO_DEVAD_NONE, 0x14, 0xb); //3 in case our code
+	ls1012a_phy_write(&bus, 0, MDIO_DEVAD_NONE, 0x4, 0x1a1);
+	ls1012a_phy_write(&bus, 0, MDIO_DEVAD_NONE, 0x12, 0x400);
+	ls1012a_phy_write(&bus, 0, MDIO_DEVAD_NONE, 0x13, 0x0);
+	ls1012a_phy_write(&bus, 0, MDIO_DEVAD_NONE, 0x0, 0x1140);
+	return;
+#endif
+
+	/*Reset serdes */
+	ls1012a_phy_write(&bus, 0, MDIO_DEVAD_NONE, 0x0, 0x8000);
+
+	/* SGMII IF mode + AN enable only for 1G SGMII, not for 2.5G */
+	value = PHY_SGMII_IF_MODE_SGMII;
+	if (!sgmii_2500)
+		value |= PHY_SGMII_IF_MODE_AN;
+
+	ls1012a_phy_write(&bus, 0, MDIO_DEVAD_NONE, 0x14, value);
+
+	/* Dev ability according to SGMII specification */
+	value = PHY_SGMII_DEV_ABILITY_SGMII;
+	ls1012a_phy_write(&bus, 0, MDIO_DEVAD_NONE, 0x4, value);
+
+	/* Adjust link timer for SGMII  -
+	1.6 ms in units of 8 ns = 2 * 10^5 = 0x30d40 */
+	//ls1012a_phy_write(&bus, 0, MDIO_DEVAD_NONE, 0x13, 0x3);
+	//ls1012a_phy_write(&bus, 0, MDIO_DEVAD_NONE, 0x12, 0xd40);
+
+	//These values taken from validation team
+	ls1012a_phy_write(&bus, 0, MDIO_DEVAD_NONE, 0x13, 0x0);
+	ls1012a_phy_write(&bus, 0, MDIO_DEVAD_NONE, 0x12, 0x400);
+
+	/* Restart AN */
+	value = PHY_SGMII_CR_DEF_VAL;
+	if (!sgmii_2500)
+		value |= PHY_SGMII_CR_RESET_AN;
+	ls1012a_phy_write(&bus, 0, MDIO_DEVAD_NONE, 0, value);
+
+
+}
+
+void ls1012a_set_mdio(int dev_id, struct mii_dev *bus)
+{
+	gem_info[dev_id].bus = bus;
+}
+
+void ls1012a_set_phy_address_mode(int dev_id, int phy_id, int phy_mode)
+{
+	gem_info[dev_id].phy_address = phy_id;
+	gem_info[dev_id].phy_mode  = phy_mode;
+}
+
+int ls1012a_phy_configure(struct ls1012a_eth_dev *priv, int dev_id, int phy_id)
+{
+	struct phy_device *phydev = NULL;
+	struct eth_device *dev = priv->dev;
+        struct gemac_s *gem = priv->gem;
+	struct ccsr_scfg *scfg = (struct ccsr_scfg *)CONFIG_SYS_FSL_SCFG_ADDR;
+
+	//Configure SGMII  PCS
+	if(gem->phy_mode == PHY_INTERFACE_MODE_SGMII ||
+			gem->phy_mode == PHY_INTERFACE_MODE_SGMII_2500)
+	{
+		//printf("Select MDIO from serdes\n");
+		out_be32(&scfg->mdioselcr, 0x00000000);
+		ls1012a_configure_serdes(priv);
+	}
+
+	/*By this time on-chip SGMII initialization is done
+	* we can swith mdio interface to external PHYs */
+	//printf("Select MDIO from PAD\n");
+	out_be32(&scfg->mdioselcr, 0x80000000);
+
+	if(! gem->bus) return -1;
+        phydev = phy_connect(gem->bus, phy_id, dev, gem->phy_mode);
+        if (!phydev) {
+                printf("phy_connect failed\n");
+                return -1;
+        }
+
+        phy_config(phydev);
+
+	priv->phydev = phydev;
+
+        return 0;
+}
+#endif
+
+int ls1012a_gemac_initialize(bd_t * bis, int dev_id, char *devname)
+{
+        struct eth_device *dev;
+        struct ls1012a_eth_dev *priv;
+        struct pfe *pfe;
+	int i;
+
+	if(dev_id > 1)
+	{
+		printf("Invalid port\n");
+		return -1;
+	}
+
+        dev = (struct eth_device *)malloc(sizeof(struct eth_device));
+        if (!dev)
+                return -1;
+
+        memset(dev, 0, sizeof(struct eth_device));
+
+        priv = (struct ls1012a_eth_dev *)malloc(sizeof(struct ls1012a_eth_dev));
+        if (!priv)
+                return -1;
+
+        gemac_list[dev_id] = priv;
+	priv->gemac_port = dev_id;
+        priv->gem = &gem_info[priv->gemac_port];
+        priv->dev = dev;
+
+        pfe = &priv->pfe;
+
+        pfe->cbus_baseaddr = (void *)CONFIG_SYS_PPFE_ADDR;
+        pfe->ddr_baseaddr = (void *)CONFIG_DDR_PPFE_BASEADDR;
+        pfe->ddr_phys_baseaddr = (unsigned long)CONFIG_DDR_PPFE_PHYS_BASEADDR;
+
+	sprintf(dev->name, devname);
+        dev->priv = priv;
+        dev->init = ls1012a_eth_init;
+        dev->halt = ls1012a_eth_halt;
+        dev->send = ls1012a_eth_send;
+        dev->recv = ls1012a_eth_recv;
+
+        /* Tell u-boot to get the addr from the env */
+        for (i = 0; i < 6; i++)
+                dev->enetaddr[i] = 0;
+
+        pfe_probe(pfe);
+
+        switch(priv->gemac_port)  {
+                case EMAC_PORT_0:
+                default:
+                        priv->gem->gemac_base = EMAC1_BASE_ADDR;
+                        priv->gem->egpi_base = EGPI1_BASE_ADDR;
+                break;
+                case EMAC_PORT_1:
+                        priv->gem->gemac_base = EMAC2_BASE_ADDR;
+                        priv->gem->egpi_base = EGPI2_BASE_ADDR;
+                break;
+        }
+
+
+#ifndef CONFIG_EMU
+#if defined(CONFIG_PHYLIB)
+	if(ls1012a_phy_configure(priv, dev_id, gem_info[priv->gemac_port].phy_address))
+		return -1;
+#else
+	#error ("Please enable CONFIG_PHYLIB")
+#endif
+#endif
+
+        eth_register(dev);
+
+	return 0;
+}
diff --git a/drivers/net/pfe_eth/pfe_eth.h b/drivers/net/pfe_eth/pfe_eth.h
new file mode 100644
index 0000000..dfcc00e
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe_eth.h
@@ -0,0 +1,161 @@
+/*
+ *  (C) Copyright 2011
+ *  Author : Mindspeed Technologes
+ *  
+ *  See file CREDITS for list of people who contributed to this
+ *  project.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License as
+ *  published by the Free Software Foundation; either version 2 of
+ *  the License, or (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA 02111-1307 USA
+ * */
+
+#ifndef _LS1012a_ETH_H_
+#define _LS1012a_ETH_H_
+
+
+#include "pfe_driver.h"
+
+#ifndef SZ_1K
+#define SZ_1K 1024
+#endif
+
+#ifndef SZ_1M
+#define SZ_1M (1024 * 1024)
+#endif
+
+#define BMU2_DDR_BASEADDR	0
+#define BMU2_BUF_COUNT		(3 * SZ_1K)
+#define BMU2_DDR_SIZE		(DDR_BUF_SIZE * BMU2_BUF_COUNT)
+
+#define TMU_LLM_BASEADDR	(BMU2_DDR_BASEADDR + BMU2_DDR_SIZE)
+#define TMU_LLM_QUEUE_LEN	(16 * 256)			/**< Must be power of two and at least 16 * 8 = 128 bytes */
+#define TMU_LLM_SIZE		(4 * 16 * TMU_LLM_QUEUE_LEN)	/**< (4 TMU's x 16 queues x queue_len) */
+
+#define HIF_RX_PKT_DDR_BASEADDR (TMU_LLM_BASEADDR + TMU_LLM_SIZE)
+#define HIF_RX_PKT_DDR_SIZE     (HIF_RX_DESC_NT * DDR_BUF_SIZE)
+#define HIF_TX_PKT_DDR_BASEADDR (HIF_RX_PKT_DDR_BASEADDR + HIF_RX_PKT_DDR_SIZE)
+#define HIF_TX_PKT_DDR_SIZE     (HIF_TX_DESC_NT * DDR_BUF_SIZE)
+
+#define HIF_DESC_BASEADDR       (HIF_TX_PKT_DDR_BASEADDR + HIF_TX_PKT_DDR_SIZE)
+#define HIF_RX_DESC_SIZE        (16*HIF_RX_DESC_NT)
+#define HIF_TX_DESC_SIZE        (16*HIF_TX_DESC_NT)
+#define HIF_DESC_SIZE           (HIF_RX_DESC_SIZE + HIF_TX_DESC_SIZE)
+
+//#define FPPDIAG_CTL_BASE_ADDR	(HIF_DESC_BASEADDR + HIF_DESC_SIZE)
+#define FPPDIAG_CTL_BASE_ADDR	0x700000
+#define FPPDIAG_CTL_SIZE		256	/**< Must be at least 11*8 bytes */
+#define FPPDIAG_PAGE_BASE_ADDR	(FPPDIAG_CTL_BASE_ADDR + FPPDIAG_CTL_SIZE)
+#define FPPDIAG_PAGE_TOTAL_SIZE	(11 * 256) /**< 256 bytes per PE, 11 PEs */
+
+//#define UTIL_CODE_BASEADDR	(FPPDIAG_PAGE_BASE_ADDR + FPPDIAG_PAGE_TOTAL_SIZE)
+#define UTIL_CODE_BASEADDR	0x780000
+#define UTIL_CODE_SIZE		(128 * SZ_1K)
+
+#define UTIL_DDR_DATA_BASEADDR	(UTIL_CODE_BASEADDR + UTIL_CODE_SIZE)
+#define UTIL_DDR_DATA_SIZE	(64 * SZ_1K)
+
+#define CLASS_DDR_DATA_BASEADDR	(UTIL_DDR_DATA_BASEADDR + UTIL_DDR_DATA_SIZE)
+#define CLASS_DDR_DATA_SIZE	(32 * SZ_1K)
+
+#define TMU_DDR_DATA_BASEADDR	(CLASS_DDR_DATA_BASEADDR + CLASS_DDR_DATA_SIZE)
+#define TMU_DDR_DATA_SIZE	(32 * SZ_1K)
+
+//#define ROUTE_TABLE_BASEADDR	(TMU_DDR_DATA_BASEADDR + TMU_DDR_DATA_SIZE)
+#define ROUTE_TABLE_BASEADDR	0x800000
+#define ROUTE_TABLE_HASH_BITS_MAX	15	/**< 32K entries */
+#define ROUTE_TABLE_HASH_BITS	8	/**< 256 entries */
+#define ROUTE_TABLE_SIZE	((1 << ROUTE_TABLE_HASH_BITS_MAX) * CLASS_ROUTE_SIZE)
+
+#define	PFE_TOTAL_DATA_SIZE	(ROUTE_TABLE_BASEADDR + ROUTE_TABLE_SIZE)
+
+#if PFE_TOTAL_DATA_SIZE > (12 * SZ_1M)
+#error DDR mapping above 12MiB
+#endif
+
+/* LMEM Mapping */
+#define BMU1_LMEM_BASEADDR	0
+#define BMU1_BUF_COUNT		256
+#define BMU1_LMEM_SIZE		(LMEM_BUF_SIZE * BMU1_BUF_COUNT)
+
+
+#define CONFIG_DDR_PPFE_PHYS_BASEADDR	0x03800000
+#define CONFIG_DDR_PPFE_BASEADDR	0x83800000 
+
+
+#define GEMAC_NO_PHY 		1
+#define GEMAC_HAVE_SWITCH_PHY     2
+#define GEMAC_HAVE_SWITCH       	4
+
+
+typedef struct gemac_s {
+
+	void *gemac_base; 
+	void *egpi_base;
+
+	/* GEMAC config */
+	int gemac_mode;
+	int gemac_speed;
+	int gemac_duplex;
+        int flags;
+	/* phy iface */
+	int phy_address;
+	int phy_mode;
+	struct mii_dev *bus;
+
+} gemac_t;
+
+struct mdio_info {
+	void *reg_base;
+	char *name;
+};
+
+
+struct pfe {
+	unsigned long ddr_phys_baseaddr;
+	void *ddr_baseaddr;
+	void *cbus_baseaddr;
+};
+
+
+typedef struct ls1012a_eth_dev {
+
+	int gemac_port;
+
+	struct gemac_s *gem;
+	struct pfe      pfe;
+
+        struct eth_device *dev;
+#ifdef CONFIG_PHYLIB
+	struct phy_device *phydev;
+#endif
+} ls1012a_eth_dev_t;
+
+
+struct firmware {
+	u8 *data;
+};
+
+
+int pfe_probe(struct pfe *pfe);
+int pfe_remove(struct pfe *pfe);
+
+
+//#define dprint(fmt, arg...)	printf(fmt, ##arg)
+#define dprint(fmt, arg...)
+//#define dprint	printf
+
+
+#endif //_LS1012a_ETH_H_
+
diff --git a/drivers/net/pfe_eth/pfe_firmware.c b/drivers/net/pfe_eth/pfe_firmware.c
new file mode 100644
index 0000000..165eb3c
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe_firmware.c
@@ -0,0 +1,193 @@
+
+
+/** @file
+ *  Contains all the functions to handle parsing and loading of PE firmware files.
+ */
+
+#include "hal.h"
+#include "pfe_firmware.h"
+#include "pfe/pfe.h"
+
+
+/* CLASS-PE ELF file content */
+unsigned char class_fw_data[] __attribute__((aligned(sizeof(int)))) = {
+#include CLASS_FIRMWARE_FILENAME
+};
+
+/* TMU-PE ELF file content */
+unsigned char tmu_fw_data[] __attribute__((aligned(sizeof(int)))) = {
+#include TMU_FIRMWARE_FILENAME
+};
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+unsigned char util_fw_data[] = {
+#include UTIL_FIRMWARE_FILENAME
+};
+#endif
+
+/** PFE elf firmware loader.
+* Loads an elf firmware image into a list of PE's (specified using a bitmask)
+*
+* @param pe_mask	Mask of PE id's to load firmware to
+* @param fw		Pointer to the firmware image
+*
+* @return		0 on sucess, a negative value on error
+*
+*/
+int pfe_load_elf(int pe_mask, const struct firmware *fw)
+{
+	Elf32_Ehdr *elf_hdr = (Elf32_Ehdr *)fw->data;
+	Elf32_Half sections = be16_to_cpu(elf_hdr->e_shnum);
+	Elf32_Shdr *shdr = (Elf32_Shdr *) (fw->data + be32_to_cpu(elf_hdr->e_shoff));
+	int id, section;
+	int rc;
+
+	printf("%s: no of sections: %d\n", __func__, sections);
+
+	/* Some sanity checks */
+	if (strncmp(&elf_hdr->e_ident[EI_MAG0], ELFMAG, SELFMAG))
+	{
+		printf("%s: incorrect elf magic number\n", __func__);
+		return -1;
+	}
+
+	if (elf_hdr->e_ident[EI_CLASS] != ELFCLASS32)
+	{
+		printf("%s: incorrect elf class(%x)\n", __func__, elf_hdr->e_ident[EI_CLASS]);
+		return -1;
+	}
+
+	if (elf_hdr->e_ident[EI_DATA] != ELFDATA2MSB)
+	{
+		printf("%s: incorrect elf data(%x)\n", __func__, elf_hdr->e_ident[EI_DATA]);
+		return -1;
+	}
+
+	if (be16_to_cpu(elf_hdr->e_type) != ET_EXEC)
+	{
+		printf("%s: incorrect elf file type(%x)\n", __func__, be16_to_cpu(elf_hdr->e_type));
+		return -1;
+	}	
+
+	for (section = 0; section < sections; section++, shdr++)
+	{
+		if (!(be32_to_cpu(shdr->sh_flags) & (SHF_WRITE | SHF_ALLOC | SHF_EXECINSTR)))
+                        continue;
+		for (id = 0; id < MAX_PE; id++)
+			if (pe_mask & (1 << id))
+			{
+				rc = pe_load_elf_section(id, fw->data, shdr);
+				if (rc < 0)
+					goto err;
+			}
+		//printf("\n");
+	}
+
+	return 0;
+
+err:
+	return rc;
+}
+
+/** PFE firmware initialization.
+* Loads different firmware files from filesystem.
+* Initializes PE IMEM/DMEM and UTIL-PE DDR
+* Initializes control path symbol addresses (by looking them up in the elf firmware files
+* Takes PE's out of reset
+*
+* @return	0 on sucess, a negative value on error
+*
+*/
+int pfe_firmware_init(u8 *class_fw_loc, u8 *tmu_fw_loc, u8 *util_fw_loc)
+{
+	struct firmware class_fw, tmu_fw;
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+ 	struct firmware util_fw;
+#endif
+	int rc = 0;
+
+	printf("%s\n", __func__);
+#if 0
+	/*This testing purpose only */
+	printf("Copying default fw \n");
+	memcpy(class_fw_loc, class_fw_data, sizeof(class_fw_data));
+	memcpy(tmu_fw_loc, tmu_fw_data, sizeof(tmu_fw_data));
+	memcpy(util_fw_loc, util_fw_data, sizeof(util_fw_data));
+#endif
+
+	if (class_fw_loc)
+		class_fw.data = class_fw_loc;
+	else
+		class_fw.data = class_fw_data;
+
+	if (tmu_fw_loc)
+		tmu_fw.data = tmu_fw_loc;
+	else
+		tmu_fw.data = tmu_fw_data;
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+	if (util_fw_loc)
+		util_fw.data = util_fw_loc;
+	else
+		util_fw.data = util_fw_data;
+#endif
+
+	rc = pfe_load_elf(CLASS_MASK, &class_fw);
+	if (rc < 0) {
+		printf("%s: class firmware load failed\n", __func__);
+		goto err3;
+	}
+
+	printf("%s: class firmware loaded\n", __func__);
+
+	rc = pfe_load_elf(TMU_MASK, &tmu_fw);
+	if (rc < 0) {
+		printf("%s: tmu firmware load failed\n", __func__);
+		goto err3;
+	}
+
+	printf("%s: tmu firmware loaded\n", __func__);
+
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+	rc = pfe_load_elf(UTIL_MASK, &util_fw);
+	if (rc < 0) {
+		printf("%s: util firmware load failed\n", __func__);
+		goto err3;
+	}
+
+	printf("%s: util firmware loaded\n", __func__);
+
+	util_enable();
+#endif
+
+#if defined(CONFIG_LS1012A)
+	tmu_enable(0xb);
+#else
+	tmu_enable(0xf);
+#endif
+	class_enable();
+
+	gpi_enable(HGPI_BASE_ADDR);
+
+
+err3:
+	return rc;
+}
+
+/** PFE firmware cleanup
+* Puts PE's in reset
+*
+*
+*/
+void pfe_firmware_exit(void)
+{
+	printf("%s\n", __func__);
+
+	class_disable();
+	tmu_disable(0xf);
+#if !defined(CONFIG_UTIL_PE_DISABLED)
+	util_disable();
+#endif
+	hif_tx_disable();
+	hif_rx_disable();
+}
diff --git a/drivers/net/pfe_eth/pfe_firmware.h b/drivers/net/pfe_eth/pfe_firmware.h
new file mode 100644
index 0000000..2823162
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe_firmware.h
@@ -0,0 +1,20 @@
+
+
+/** @file
+ *  Contains all the defines to handle parsing and loading of PE firmware files.
+ */
+
+#ifndef __PFE_FIRMWARE_H__
+#define __PFE_FIRMWARE_H__
+
+
+#define CLASS_FIRMWARE_FILENAME		"class_sbl_elf.fw"
+#define TMU_FIRMWARE_FILENAME		   "tmu_sbl_elf.fw"
+#define UTIL_FIRMWARE_FILENAME		"util_sbl_elf.fw" 
+
+
+int pfe_firmware_init(u8 * clasS_fw_loc, u8 *tmu_fw_loc, u8 *util_fw_loc);
+void pfe_firmware_exit(void);
+
+
+#endif
diff --git a/drivers/net/pfe_eth/pfe_mod.h b/drivers/net/pfe_eth/pfe_mod.h
new file mode 100644
index 0000000..9436b72
--- /dev/null
+++ b/drivers/net/pfe_eth/pfe_mod.h
@@ -0,0 +1,140 @@
+/*
+ *  (C) Copyright 2011
+ *  Author : Mindspeed Technologes
+ *  
+ *  See file CREDITS for list of people who contributed to this
+ *  project.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License as
+ *  published by the Free Software Foundation; either version 2 of
+ *  the License, or (at your option) any later version.
+ *  
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA 02111-1307 USA
+ * */
+
+
+#ifndef _PFE_MOD_H_
+#define _PFE_MOD_H_
+
+#include <linux/device.h>
+
+#include "pfe/pfe.h"
+#include "pfe/cbus.h"
+#include "pfe/cbus/bmu.h"
+
+#include "pfe_driver.h"
+
+struct pfe;
+
+
+struct pfe {
+	unsigned long ddr_phys_baseaddr;
+	void *ddr_baseaddr;
+	void *cbus_baseaddr;
+	void *apb_baseaddr;
+	void *iram_baseaddr;
+	int hif_irq;
+	struct device *dev;
+	struct pci_dev *pdev;
+
+#if 0
+	struct pfe_ctrl ctrl;
+	struct pfe_hif hif;
+	struct pfe_eth eth;
+#endif
+};
+
+extern struct pfe *pfe;
+
+int pfe_probe(struct pfe *pfe);
+int pfe_remove(struct pfe *pfe);
+
+#ifndef SZ_1K
+#define SZ_1K 1024
+#endif
+
+#ifndef SZ_1M
+#define SZ_1M (1024 * 1024)
+#endif
+
+/* DDR Mapping */
+#if !defined(CONFIG_PLATFORM_PCI)
+#define UTIL_CODE_BASEADDR	0
+#define UTIL_CODE_SIZE		(128 * SZ_1K)
+#define UTIL_DDR_DATA_BASEADDR	(UTIL_CODE_BASEADDR + UTIL_CODE_SIZE)
+#define UTIL_DDR_DATA_SIZE	(64 * SZ_1K)
+#define CLASS_DDR_DATA_BASEADDR	(UTIL_DDR_DATA_BASEADDR + UTIL_DDR_DATA_SIZE)
+#define CLASS_DDR_DATA_SIZE	(32 * SZ_1K)
+#define TMU_DDR_DATA_BASEADDR	(CLASS_DDR_DATA_BASEADDR + CLASS_DDR_DATA_SIZE)
+#define TMU_DDR_DATA_SIZE	(32 * SZ_1K)
+#define ROUTE_TABLE_BASEADDR	(TMU_DDR_DATA_BASEADDR + TMU_DDR_DATA_SIZE)
+#define ROUTE_TABLE_HASH_BITS	15	/**< 32K entries */
+#define ROUTE_TABLE_SIZE	((1 << ROUTE_TABLE_HASH_BITS) * CLASS_ROUTE_SIZE)
+#define BMU2_DDR_BASEADDR	(ROUTE_TABLE_BASEADDR + ROUTE_TABLE_SIZE)
+#define BMU2_BUF_COUNT		(4096 - 256)			/**< This is to get a total DDR size of 12MiB */
+#define BMU2_DDR_SIZE		(DDR_BUF_SIZE * BMU2_BUF_COUNT)
+#define TMU_LLM_BASEADDR	(BMU2_DDR_BASEADDR + BMU2_DDR_SIZE)
+#define TMU_LLM_QUEUE_LEN	(16 * 256)			/**< Must be power of two and at least 16 * 8 = 128 bytes */
+#define TMU_LLM_SIZE		(4 * 16 * TMU_LLM_QUEUE_LEN)	/**< (4 TMU's x 16 queues x queue_len) */
+
+#if (TMU_LLM_BASEADDR + TMU_LLM_SIZE) > 0xC00000
+#error DDR mapping above 12MiB
+#endif
+
+#else
+
+#define UTIL_CODE_BASEADDR	0
+#if defined(CONFIG_UTIL_PE_DISABLED)
+#define UTIL_CODE_SIZE		(0 * SZ_1K)
+#else
+#define UTIL_CODE_SIZE		(8 * SZ_1K)
+#endif
+#define UTIL_DDR_DATA_BASEADDR	(UTIL_CODE_BASEADDR + UTIL_CODE_SIZE)
+#define UTIL_DDR_DATA_SIZE	(0 * SZ_1K)
+#define CLASS_DDR_DATA_BASEADDR	(UTIL_DDR_DATA_BASEADDR + UTIL_DDR_DATA_SIZE)
+#define CLASS_DDR_DATA_SIZE	(0 * SZ_1K)
+#define TMU_DDR_DATA_BASEADDR	(CLASS_DDR_DATA_BASEADDR + CLASS_DDR_DATA_SIZE)
+#define TMU_DDR_DATA_SIZE	(0 * SZ_1K)
+#define ROUTE_TABLE_BASEADDR	(TMU_DDR_DATA_BASEADDR + TMU_DDR_DATA_SIZE)
+#define ROUTE_TABLE_HASH_BITS	5	/**< 32 entries */
+#define ROUTE_TABLE_SIZE	((1 << ROUTE_TABLE_HASH_BITS) * CLASS_ROUTE_SIZE)
+#define BMU2_DDR_BASEADDR	(ROUTE_TABLE_BASEADDR + ROUTE_TABLE_SIZE)
+#define BMU2_BUF_COUNT		8
+#define BMU2_DDR_SIZE		(DDR_BUF_SIZE * BMU2_BUF_COUNT)
+#define TMU_LLM_BASEADDR	(BMU2_DDR_BASEADDR + BMU2_DDR_SIZE)
+#define TMU_LLM_QUEUE_LEN	(16 * 8)			/**< Must be power of two and at least 16 * 8 = 128 bytes */
+#define TMU_LLM_SIZE		(4 * 16 * TMU_LLM_QUEUE_LEN)	/**< (4 TMU's x 16 queues x queue_len) */
+#define HIF_DESC_BASEADDR	(TMU_LLM_BASEADDR + TMU_LLM_SIZE)
+#define HIF_RX_DESC_SIZE	(16*HIF_RX_DESC_NT)
+#define HIF_TX_DESC_SIZE	(16*HIF_TX_DESC_NT)
+#define HIF_DESC_SIZE		(HIF_RX_DESC_SIZE + HIF_TX_DESC_SIZE)
+#define HIF_RX_PKT_DDR_BASEADDR	(HIF_DESC_BASEADDR + HIF_DESC_SIZE)
+#define HIF_RX_PKT_DDR_SIZE	(HIF_RX_DESC_NT * DDR_BUF_SIZE)
+#define HIF_TX_PKT_DDR_BASEADDR	(HIF_RX_PKT_DDR_BASEADDR + HIF_RX_PKT_DDR_SIZE)
+#define HIF_TX_PKT_DDR_SIZE	(HIF_TX_DESC_NT * DDR_BUF_SIZE)
+#define ROUTE_BASEADDR		(HIF_TX_PKT_DDR_BASEADDR + HIF_TX_PKT_DDR_SIZE)
+#define ROUTE_SIZE		(2 * CLASS_ROUTE_SIZE)
+
+#if (ROUTE_BASEADDR + ROUTE_SIZE) > 0x10000
+#error DDR mapping above 64KiB
+#endif
+
+#define PFE_HOST_TO_PCI(addr)	(((u32)addr)- ((u32)DDR_BASE_ADDR))
+#define PFE_PCI_TO_HOST(addr)	(((u32)addr)+ ((u32)DDR_BASE_ADDR))
+#endif
+
+/* LMEM Mapping */
+#define BMU1_LMEM_BASEADDR	0
+#define BMU1_BUF_COUNT		256
+#define BMU1_LMEM_SIZE		(LMEM_BUF_SIZE * BMU1_BUF_COUNT)
+
+#endif /* _PFE_MOD_H */
diff --git a/drivers/net/pfe_eth/tmu_sbl_elf.fw b/drivers/net/pfe_eth/tmu_sbl_elf.fw
new file mode 100644
index 0000000..d9e8409
--- /dev/null
+++ b/drivers/net/pfe_eth/tmu_sbl_elf.fw
@@ -0,0 +1 @@
+0x7f,0x45,0x4c,0x46,0x01,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x6f,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x34,0x00,0x00,0x25,0x80,0x00,0x04,0x00,0x05,0x00,0x34,0x00,0x20,0x00,0x04,0x00,0x28,0x00,0x0a,0x00,0x09,0x00,0x00,0x00,0x01,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x04,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x10,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x6c,0x00,0x00,0x02,0x18,0x00,0x00,0x00,0x06,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x12,0x98,0x00,0x00,0x02,0x98,0x00,0x00,0x02,0x98,0x00,0x00,0x01,0x20,0x00,0x00,0x01,0x20,0x00,0x00,0x00,0x06,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x20,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x05,0x12,0x00,0x00,0x05,0x12,0x00,0x00,0x00,0x05,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x01,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2a,0x2a,0x2a,0x2a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x02,0x90,0x44,0x45,0x41,0x44,0x0c,0x08,0x04,0x00,0xc1,0x1c,0x00,0x0c,0x0d,0x09,0x05,0x01,0x0e,0x0a,0x06,0x02,0x0f,0x0b,0x07,0x03,0x3f,0xff,0xff,0xff,0xc1,0x26,0x00,0x48,0xc1,0x26,0x00,0x4c,0xc1,0x26,0x00,0x50,0xc1,0x26,0x00,0x60,0x69,0x6e,0x69,0x74,0x72,0x75,0x6e,0x20,0x73,0x74,0x6f,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x80,0x11,0x00,0x11,0x80,0x12,0x00,0x12,0x80,0x13,0x00,0x13,0x80,0x14,0x00,0x14,0x80,0x15,0x00,0x15,0x80,0x16,0x00,0x16,0x80,0x17,0x00,0x17,0x80,0xea,0x00,0xc8,0x00,0xe0,0x07,0xc8,0x34,0xea,0x00,0xcb,0x80,0xe0,0x01,0xcb,0xa0,0xe0,0x60,0x3c,0x00,0xcc,0x02,0xe0,0x60,0x3c,0x10,0xe0,0x00,0xd2,0x4c,0x3a,0x80,0xea,0x00,0xcb,0x80,0xe0,0x00,0xcb,0xa8,0xb8,0x47,0xb8,0xd7,0xb9,0x67,0xb9,0xf7,0xe0,0x01,0xba,0x07,0xe0,0x01,0xba,0x97,0xe0,0x01,0xbb,0x27,0xe0,0x01,0xbb,0xb7,0xe0,0x01,0xbc,0x47,0xe0,0x01,0xbc,0xd7,0xe0,0x01,0xbd,0x67,0xe0,0x01,0xbd,0xf7,0xe0,0x02,0xbe,0x07,0xe0,0x02,0xbe,0x97,0xe0,0x02,0xbf,0x27,0xe0,0x02,0xbf,0xb7,0xe0,0x60,0x3e,0x09,0xe0,0x60,0x3e,0x8a,0xe0,0x60,0x3f,0x0b,0xe0,0x60,0x3f,0x8c,0xbe,0x07,0xbe,0x97,0xbf,0x27,0xbf,0xb7,0xea,0x00,0xcb,0x80,0xe0,0x01,0xcb,0xa0,0x3c,0x6c,0xe0,0x00,0x00,0x82,0xe0,0x00,0x1f,0x83,0xe0,0x00,0x1f,0x05,0xbf,0x0f,0xbc,0x1f,0xbf,0x0f,0x3a,0x80,0x00,0xff,0xea,0x00,0x7f,0xd0,0xe8,0x00,0xc7,0x80,0xeb,0x82,0xcf,0x02,0xbf,0x0f,0xeb,0x82,0xcf,0x03,0xbf,0x2f,0xeb,0x82,0xcf,0x04,0xbf,0x4f,0xeb,0x82,0xcf,0x05,0xbf,0x6f,0xeb,0x82,0xcf,0x06,0xe0,0x01,0xbf,0x0f,0xeb,0x82,0xcf,0x07,0xe0,0x01,0xbf,0x2f,0xeb,0x82,0xcf,0x08,0xe0,0x01,0xbf,0x4f,0xeb,0x82,0xcf,0x09,0xe0,0x01,0xbf,0x6f,0xeb,0x82,0xcf,0x0a,0xe0,0x02,0xbf,0x0f,0xeb,0x82,0xcf,0x0b,0xe0,0x02,0xbf,0x2f,0xea,0x01,0x7f,0x20,0xe8,0x00,0xc7,0x00,0xeb,0x82,0xce,0x9c,0xbe,0x8e,0xeb,0x82,0xce,0x9d,0xbe,0xfe,0xeb,0x82,0xce,0x9e,0xe0,0x01,0xbe,0xee,0xeb,0x82,0xce,0x9f,0xe0,0x02,0xbe,0xde,0xeb,0x82,0xce,0xa0,0xe0,0x03,0xbe,0xce,0xeb,0x82,0xce,0xa1,0xe0,0x04,0xbe,0xbe,0xeb,0x82,0xce,0xa2,0xe0,0x05,0xbe,0xae,0xeb,0x82,0xce,0xa3,0xe0,0x06,0xbe,0x9e,0x17,0x0f,0xbf,0x3f,0xe0,0x01,0x17,0x70,0xbf,0x5f,0xe0,0x1e,0x17,0x00,0xbf,0x7f,0xe1,0xe0,0x17,0x00,0xe0,0x01,0xbf,0x1f,0x16,0x80,0x17,0x00,0xea,0x03,0x7d,0x00,0x15,0x82,0xe0,0x0c,0x37,0x42,0x3f,0xed,0xc6,0x01,0xe0,0xaa,0xae,0x7f,0x3e,0x6e,0xe2,0x00,0xc6,0x03,0xae,0x1f,0xc7,0x01,0xad,0xaf,0xe3,0xff,0xc7,0x7f,0x16,0x02,0xc6,0x83,0xe2,0x00,0xcf,0x10,0x01,0xee,0xea,0x01,0x7f,0xa0,0xe8,0x00,0xc7,0x80,0x16,0x81,0xbe,0xbf,0x16,0xa0,0xbf,0x4f,0xe0,0x02,0x17,0x00,0xe0,0x01,0xbe,0xbf,0xe0,0x04,0x16,0x80,0xbf,0x5f,0xe0,0x22,0x17,0x11,0xe0,0x01,0xbe,0xcf,0xe0,0x40,0x16,0x80,0xbf,0x1f,0x17,0x02,0xe0,0x01,0xbe,0xdf,0xe0,0x44,0x16,0xa2,0xe0,0x01,0xbf,0x2f,0xe0,0x20,0x15,0x80,0xe0,0x01,0xbe,0x8f,0x16,0x84,0xe0,0x08,0xaf,0x0f,0xe0,0x0b,0xaf,0x4f,0x17,0x08,0xe0,0x02,0xbe,0x9f,0xe0,0x00,0x16,0xc0,0xe0,0x03,0xbf,0x0f,0xe0,0x01,0x17,0x00,0xe0,0x02,0xbe,0xaf,0xe0,0x08,0x16,0x80,0xe0,0x03,0xbf,0x1f,0xe0,0x10,0x17,0x00,0xe0,0x02,0xbe,0xbf,0xe0,0x80,0x16,0x80,0xe0,0x03,0xbf,0x2f,0xe1,0x00,0x17,0x00,0xe0,0x02,0xbe,0xcf,0xe0,0x88,0x16,0xc4,0xe0,0x03,0xbf,0x3f,0xe1,0x11,0x17,0x08,0xe0,0x01,0xbe,0xff,0xe0,0x02,0xbf,0x6f,0xe0,0x00,0x1e,0x86,0xe0,0x00,0x1f,0x07,0xe0,0x01,0xae,0x0f,0xbd,0xef,0xe0,0x04,0xae,0x4f,0xbe,0x8e,0x00,0x00,0x17,0x00,0xa6,0x8f,0xbf,0x4d,0x00,0x00,0xe0,0x00,0x1e,0x08,0xa6,0xff,0xbe,0x3d,0x00,0x00,0xa6,0xff,0xbf,0x4d,0x00,0x00,0xe0,0x00,0x1e,0x09,0xe0,0x01,0xa6,0xef,0xbe,0x3d,0x00,0x00,0xe0,0x01,0xa6,0xef,0xbf,0x4d,0x00,0x00,0xe0,0x00,0x1e,0x0a,0xe0,0x02,0xa6,0xdf,0xbe,0x3d,0x00,0x00,0xe0,0x02,0xa6,0xdf,0xbf,0x4d,0x00,0x00,0x3d,0x6f,0xe0,0x00,0xc5,0x70,0x14,0x12,0xe0,0x0a,0x17,0x00,0xe0,0x04,0x16,0x50,0xe0,0x0e,0x16,0xd0,0xa4,0x8f,0xbc,0x09,0x00,0x00,0xa4,0x8f,0xbf,0x19,0x00,0x00,0xa4,0x8f,0xe0,0x01,0xbe,0x09,0x00,0x00,0xa4,0x8f,0xe0,0x01,0xbf,0x19,0x00,0x00,0xa4,0x8f,0xe0,0x01,0xbd,0xa9,0x00,0x00,0xa4,0x8f,0xe0,0x01,0xbe,0xb9,0x00,0x00,0xa4,0x8f,0xe0,0x01,0xbd,0xc9,0x00,0x00,0xa4,0x8f,0xe0,0x01,0xbe,0x59,0x00,0x00,0xa4,0x8f,0xe0,0x01,0xbe,0xe9,0x00,0x00,0xe1,0x80,0xa4,0xff,0xe0,0x01,0xbf,0x79,0x00,0x00,0x3f,0xfa,0x01,0xd8,0xea,0x00,0x7f,0xd0,0xe8,0x00,0xc7,0x80,0x3f,0x6f,0xe0,0x00,0x1e,0x0b,0xc7,0x28,0x15,0x81,0xa6,0x8f,0xbd,0x8d,0x00,0x00,0xe1,0x80,0xa6,0xaf,0xbe,0x1d,0x00,0x00,0x3f,0xfe,0x01,0xf8,0xea,0x03,0x7f,0xb0,0xe0,0x0a,0x15,0x81,0xe0,0x12,0x16,0x02,0xe0,0x22,0x16,0x84,0xe0,0x42,0x17,0x08,0xbd,0x8f,0xbe,0x1f,0xbe,0xaf,0xbf,0x3f,0xbd,0xcf,0xbe,0x5f,0xbe,0xef,0xbf,0x7f,0xe0,0x01,0xbd,0x8f,0xe0,0x01,0xbe,0x1f,0xe0,0x01,0xbe,0xaf,0xe0,0x01,0xbf,0x3f,0xe0,0x01,0xbd,0xcf,0xe0,0x01,0xbe,0x5f,0xe0,0x01,0xbe,0xef,0xe0,0x01,0xbf,0x7f,0x38,0x82,0xeb,0x82,0xcf,0xa6,0xa6,0x8f,0x3f,0xed,0xe2,0x00,0xc7,0x87,0xe0,0x01,0x2f,0xba,0xe4,0x0c,0x36,0xc3,0x3f,0xec,0xe2,0x00,0xc7,0x81,0xe0,0x01,0x27,0xb3,0x3d,0x6c,0x36,0xc3,0xea,0x00,0x7e,0x50,0xe3,0xff,0xc6,0xff,0x17,0x00,0x17,0x81,0xe2,0x07,0xc5,0x7f,0xe8,0x00,0xc6,0x00,0xe0,0x0b,0x35,0x5f,0xe2,0x00,0xc5,0x81,0x25,0x86,0xe0,0x0b,0x37,0xa3,0x3d,0x9c,0xa5,0x9b,0x3f,0x4b,0xc7,0x81,0xe2,0x00,0xcf,0x85,0x01,0xf3,0x3e,0xde,0xe0,0x01,0x26,0x96,0xe0,0x00,0x1f,0x03,0xa7,0xae,0xc7,0x81,0xbf,0xae,0xea,0x01,0x7f,0xa0,0xe8,0x00,0xc7,0x80,0xe0,0x02,0xa7,0x6f,0xe0,0x0e,0x3e,0xde,0x2f,0x0e,0xe0,0x01,0xa7,0x7f,0xe0,0x0e,0x3e,0xde,0x2f,0x0b,0xe0,0x01,0xa7,0x0f,0x17,0x80,0xe0,0x0e,0x3e,0xde,0x27,0x06,0x17,0x81,0x00,0x84,0x17,0x83,0x00,0x82,0x17,0x82,0xe0,0x0e,0x37,0xa2,0xe0,0x0b,0x37,0xa5,0x3d,0xae,0xea,0x01,0x7f,0x20,0xe8,0x00,0xc7,0x00,0x3d,0x9e,0xe0,0x01,0x8e,0x0b,0xa7,0x1b,0x2e,0x1d,0xe1,0xff,0x16,0xff,0x3f,0x7d,0x17,0x80,0x05,0x84,0xe4,0x0e,0x37,0x40,0x17,0x90,0xe2,0x01,0xcf,0x7f,0x05,0x83,0x37,0x48,0xc7,0x88,0xe2,0x00,0xcf,0x0f,0x05,0x83,0x37,0x44,0xc7,0x84,0xe2,0x00,0xcf,0x03,0x05,0x83,0x37,0x42,0xc7,0x82,0x16,0x82,0xe1,0x2e,0x3f,0x2d,0x3f,0x9e,0x00,0xab,0xe0,0x0e,0x3e,0xde,0x16,0x00,0x16,0x80,0x15,0x01,0xe0,0x09,0x36,0xa2,0xe0,0x09,0x3d,0x99,0xa4,0xb9,0xe0,0x09,0x3f,0x59,0x24,0x85,0xe0,0x09,0x35,0x3d,0x34,0xa8,0x3e,0x49,0xc6,0x81,0xe2,0x00,0xce,0x84,0x01,0xf1,0xe0,0x0d,0x37,0xa2,0xea,0x01,0x7f,0x20,0x37,0xa5,0x3f,0xad,0xe8,0x00,0xc7,0x00,0x3f,0x1f,0xa7,0x8e,0xbe,0x0f,0x00,0x00,0xa7,0x0e,0xc7,0x08,0xa7,0x8e,0x3e,0xef,0xe3,0x00,0xc6,0x80,0x26,0xfc,0xe4,0x0f,0x37,0xc8,0x3f,0x6f,0xe0,0x01,0xcf,0x00,0xe2,0x00,0xcf,0x87,0x02,0x04,0xe0,0x00,0x1e,0x8c,0x00,0x8b,0x3e,0xef,0xc6,0xf8,0xe2,0x00,0xce,0x83,0x02,0x84,0xe0,0x00,0x1e,0x8d,0x00,0x83,0xe0,0x00,0x1e,0x8e,0xbf,0x0d,0x00,0x00,0xe0,0x00,0x1e,0x83,0xa7,0x3d,0xc7,0x01,0xbf,0x3d,0xea,0x03,0x7f,0x30,0xe0,0x2f,0xa7,0x7e,0xe0,0x00,0x1f,0x8f,0xbf,0x0f,0x00,0x00,0x38,0x82,0xc0,0x78,0x78,0x82,0x79,0x01,0xe0,0x00,0x19,0x03,0xe0,0x00,0x1f,0x90,0xbf,0x82,0xdd,0xeb,0xe0,0x00,0x1f,0x91,0xbf,0x82,0xe0,0x00,0x19,0x04,0xa7,0x02,0xe0,0x00,0x1f,0x83,0x27,0x0a,0xe0,0x00,0x1f,0x04,0x16,0x81,0xbe,0x9e,0xe0,0x00,0x1f,0x12,0xbf,0x0f,0x00,0x00,0x00,0xff,0xa7,0x1f,0xc7,0x01,0xbf,0x1f,0xdf,0x21,0x00,0xef,0x47,0x43,0x43,0x3a,0x20,0x28,0x47,0x4e,0x55,0x29,0x20,0x34,0x2e,0x37,0x2e,0x31,0x00,0x00,0x2e,0x73,0x68,0x73,0x74,0x72,0x74,0x61,0x62,0x00,0x2e,0x70,0x6d,0x65,0x6d,0x00,0x2e,0x76,0x65,0x63,0x74,0x6f,0x72,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x70,0x65,0x73,0x74,0x61,0x74,0x75,0x73,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x67,0x6f,0x74,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x6c,0x69,0x74,0x34,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x62,0x73,0x73,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x73,0x74,0x61,0x63,0x6b,0x00,0x2e,0x63,0x6f,0x6d,0x6d,0x65,0x6e,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x06,0x00,0x01,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x05,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x19,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x80,0x00,0x00,0x10,0x80,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0xa0,0x00,0x00,0x10,0xa0,0x00,0x00,0x00,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x32,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0xb4,0x00,0x00,0x10,0xb4,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x3d,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0xf0,0x00,0x00,0x10,0xec,0x00,0x00,0x01,0xa8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x47,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x02,0x98,0x00,0x00,0x12,0x98,0x00,0x00,0x01,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x53,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x25,0x12,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x25,0x23,0x00,0x00,0x00,0x5c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
\ No newline at end of file
diff --git a/drivers/net/pfe_eth/util_sbl_elf.fw b/drivers/net/pfe_eth/util_sbl_elf.fw
new file mode 100644
index 0000000..7a34b86
--- /dev/null
+++ b/drivers/net/pfe_eth/util_sbl_elf.fw
@@ -0,0 +1 @@
+0x7f,0x45,0x4c,0x46,0x01,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x6f,0x00,0x00,0x00,0x01,0x03,0xf8,0x00,0x00,0x00,0x00,0x00,0x34,0x00,0x00,0x2c,0xd4,0x00,0x04,0x00,0x05,0x00,0x34,0x00,0x20,0x00,0x04,0x00,0x28,0x00,0x0c,0x00,0x0b,0x00,0x00,0x00,0x01,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x5c,0x00,0x00,0x03,0xb4,0x00,0x00,0x00,0x06,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x13,0xb4,0x00,0x00,0x03,0xb4,0x00,0x00,0x03,0xb4,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x1f,0x80,0x00,0x00,0x1f,0x80,0x00,0x00,0x1f,0x80,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x04,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x20,0x00,0x03,0xf8,0x00,0x00,0x03,0xf8,0x00,0x00,0x00,0x00,0x0c,0x30,0x00,0x00,0x0c,0x30,0x00,0x00,0x00,0x05,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2a,0x2a,0x2a,0x2a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x60,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x6c,0x00,0x00,0x03,0xa0,0x00,0x00,0x01,0xa0,0x00,0x00,0x01,0x5c,0x00,0x00,0x02,0xa0,0x00,0x00,0x00,0x00,0xc1,0x04,0x00,0x00,0xc1,0x05,0x00,0x00,0xc1,0x06,0x00,0x00,0x90,0x02,0x00,0x00,0x90,0x00,0x00,0x00,0x00,0x19,0x00,0x0a,0x00,0x19,0x00,0x00,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x0a,0x00,0x00,0x00,0x00,0x00,0xba,0x80,0x00,0x03,0xa8,0x0a,0xfb,0x04,0x69,0x3e,0x00,0x00,0x44,0x45,0x41,0x44,0xc1,0x04,0x00,0x0c,0xc1,0x04,0x00,0x04,0xc1,0x04,0x00,0x08,0xde,0xad,0xbe,0xef,0x66,0x61,0x69,0x6c,0x70,0x61,0x73,0x73,0x81,0x70,0x00,0x04,0x0c,0x80,0x09,0xc4,0x81,0x70,0x06,0x10,0x81,0x70,0x0f,0xa0,0x10,0x00,0x00,0x06,0x81,0x70,0x0f,0xa4,0x40,0x03,0x00,0x17,0x81,0x70,0x0f,0xa8,0x0c,0xbf,0x02,0x11,0x81,0x70,0x0f,0xac,0x81,0x71,0x00,0x04,0x81,0x71,0x00,0x0c,0x69,0x6e,0x69,0x74,0x72,0x75,0x6e,0x20,0x03,0x70,0x00,0x80,0x01,0x71,0x00,0x20,0x03,0x70,0x01,0x40,0x03,0x70,0x01,0xc0,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0x03,0x70,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xf8,0x00,0x00,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x03,0xf8,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x80,0x11,0x00,0x11,0x80,0x12,0x00,0x12,0x80,0x13,0x00,0x13,0x80,0x14,0x00,0x14,0x80,0x15,0x00,0x15,0x80,0x16,0x00,0x16,0x80,0x17,0x00,0x17,0x80,0xea,0x00,0xc8,0x00,0xe0,0x0b,0xc8,0x30,0xea,0x00,0xcb,0x80,0xe0,0x00,0xcb,0xa0,0xe0,0x60,0x3c,0x00,0xcc,0x02,0xe0,0x60,0x3c,0x10,0xe0,0x00,0xd4,0xec,0x3a,0x80,0xea,0x00,0xcb,0x80,0xe0,0x3f,0xcb,0xa8,0xb8,0x47,0xb8,0xd7,0xb9,0x67,0xb9,0xf7,0xe0,0x01,0xba,0x07,0xe0,0x01,0xba,0x97,0xe0,0x01,0xbb,0x27,0xe0,0x01,0xbb,0xb7,0xe0,0x01,0xbc,0x47,0xe0,0x01,0xbc,0xd7,0xe0,0x01,0xbd,0x67,0xe0,0x01,0xbd,0xf7,0xe0,0x02,0xbe,0x07,0xe0,0x02,0xbe,0x97,0xe0,0x02,0xbf,0x27,0xe0,0x02,0xbf,0xb7,0xe0,0x60,0x3e,0x09,0xe0,0x60,0x3e,0x8a,0xe0,0x60,0x3f,0x0b,0xe0,0x60,0x3f,0x8c,0xbe,0x07,0xbe,0x97,0xbf,0x27,0xbf,0xb7,0xea,0x00,0xcb,0x80,0xe0,0x00,0xcb,0xa0,0x3c,0x6c,0xe0,0x00,0x00,0x82,0xe0,0x00,0x1f,0x83,0xe0,0x00,0x1f,0x27,0xbf,0x0f,0xbc,0x1f,0xbf,0x0f,0x3a,0x80,0x00,0xff,0xe0,0x00,0x1f,0x85,0xe2,0x07,0xc5,0x7f,0xa7,0xaf,0xe4,0x0b,0x35,0xa0,0x3d,0xca,0xbd,0x9f,0xbc,0xaf,0xe1,0x80,0xbc,0x3f,0x00,0x00,0xa7,0x0f,0xe2,0x00,0xc7,0x01,0x27,0x7d,0x38,0x82,0xe0,0x00,0x1f,0x89,0xa6,0x8f,0x3f,0xed,0xe2,0x00,0xc7,0x81,0x27,0x8e,0xe0,0x00,0x1f,0x85,0xa7,0x0f,0xc7,0x0c,0xa7,0x8e,0xe2,0x00,0xc7,0x81,0x27,0xfd,0x17,0xfe,0x3e,0xdf,0xe0,0x00,0x1f,0x89,0xbe,0x8f,0xe0,0x00,0x1f,0x85,0xe4,0x0b,0x35,0xa0,0xa7,0x8f,0xe2,0x07,0xc5,0x7f,0xe0,0x0a,0x3d,0xca,0xbd,0x1f,0xbc,0xaf,0xbc,0x0f,0x00,0x00,0xe0,0x00,0x1f,0x09,0xa7,0x8e,0xcf,0x81,0xbf,0x8e,0x38,0x82,0xc0,0x7c,0x78,0x81,0x15,0x81,0xe2,0x3f,0xcc,0xff,0x05,0x85,0x3f,0x68,0x15,0x80,0x3c,0x69,0x3c,0xee,0xdf,0xbd,0x60,0x81,0xc0,0x04,0x38,0x82,0xc0,0x7c,0x78,0x81,0xe2,0x00,0xcd,0x04,0x02,0x90,0x3f,0xe8,0xe2,0x00,0xc7,0x83,0x27,0x8c,0x00,0x87,0xe0,0x2f,0x8f,0x79,0xe0,0x2f,0xaf,0x78,0xc7,0x81,0x00,0x82,0x17,0x80,0x3f,0xfa,0x01,0xf8,0x00,0x82,0xdf,0xde,0x60,0x81,0xc0,0x04,0x38,0x82,0xc0,0x7c,0x78,0x81,0x15,0x81,0xe2,0x3f,0xcc,0xff,0x05,0x85,0x3f,0x68,0x15,0x80,0x3c,0x69,0x3c,0xee,0xdf,0xa9,0x60,0x81,0xc0,0x04,0x38,0x82,0xe0,0x0c,0x35,0x45,0x3e,0xec,0x3f,0x69,0x3f,0xe8,0x00,0x94,0xa5,0x8e,0xc6,0xff,0xbd,0x8f,0xa5,0x9e,0xbd,0x9f,0xa5,0xae,0xbd,0xaf,0xa5,0xbe,0xbd,0xbf,0xa5,0xce,0xbd,0xcf,0xa5,0xde,0xbd,0xdf,0xa5,0xee,0xbd,0xef,0xa5,0xfe,0xc7,0x20,0xbd,0xff,0xc7,0xa0,0x2e,0xed,0xe0,0x0f,0x36,0x25,0x3c,0x1f,0x3c,0x9f,0x3f,0xea,0xe2,0x00,0xc7,0x90,0x27,0x8b,0xa7,0x89,0xbf,0x88,0xa7,0x99,0xbf,0x98,0xa7,0xa9,0xbf,0xa8,0xa7,0xb9,0xc4,0x90,0xbf,0xb8,0xc4,0x10,0x3f,0xea,0xe2,0x00,0xc7,0x88,0x27,0x87,0xa7,0x89,0xbf,0x88,0xa7,0x99,0xc4,0x88,0xbf,0x98,0xc4,0x08,0x3f,0xea,0xe2,0x00,0xc7,0x84,0x27,0x85,0xe1,0x80,0xa7,0x99,0xe1,0x80,0xbf,0x98,0x3f,0xea,0xe2,0x00,0xc7,0x82,0x27,0x85,0xe1,0x80,0x9f,0x99,0xe1,0x80,0xb7,0x98,0xe2,0x00,0xc5,0x01,0x25,0x03,0x8f,0x89,0xaf,0x88,0x38,0x82,0xc0,0x7c,0x78,0x81,0x3f,0xe9,0xe2,0x00,0xc7,0x81,0x27,0x87,0x25,0x06,0xe1,0x80,0x8f,0x99,0xc5,0x7f,0xe1,0x80,0xaf,0x98,0x3f,0xe9,0xe2,0x00,0xc7,0x82,0x27,0x89,0xe2,0x00,0xcd,0x01,0x05,0x86,0xe1,0x80,0x9f,0x99,0xc5,0x7e,0xe1,0x80,0xb7,0x98,0xdf,0x9c,0x60,0x81,0xc0,0x04,0x38,0x82,0xe2,0x00,0xcd,0x05,0x05,0x8a,0xe0,0x0e,0x3c,0x1a,0x00,0x8f,0xe0,0x2f,0x8f,0x79,0xe0,0x2f,0xaf,0x78,0xc7,0x81,0x00,0x82,0x17,0x80,0x3f,0xfa,0x01,0xf8,0x38,0x82,0xe1,0x80,0x8f,0x99,0xe1,0x80,0xaf,0x98,0x3f,0xe8,0xe2,0x00,0xc7,0x83,0xe0,0x0a,0x3f,0x28,0x2f,0xf7,0xc0,0x70,0x78,0x84,0x79,0x03,0x79,0x82,0x7a,0x01,0x3f,0xe9,0xe2,0x00,0xc7,0x83,0x3f,0x68,0xe2,0x00,0xcf,0x81,0x01,0x0e,0xe2,0x00,0xcf,0x82,0x01,0x86,0xe1,0x80,0x9e,0x19,0xc5,0x7e,0x17,0x90,0x00,0x90,0xe1,0x80,0x8e,0x19,0xc5,0x7f,0x17,0x98,0x00,0x8b,0x3f,0xe9,0xe1,0x80,0x8e,0x1f,0xc5,0x7d,0x9f,0x8f,0xe4,0x0c,0x36,0x20,0x3e,0x4f,0xc4,0x83,0x17,0x88,0x16,0xa0,0xe0,0x02,0x35,0x45,0x3e,0xaf,0x38,0xe2,0x3d,0xe9,0x00,0xbc,0xa1,0x8b,0x36,0x3f,0xe0,0x04,0x31,0xdd,0xe0,0x0c,0x3a,0x4c,0xbe,0x08,0x31,0xbf,0xc0,0xff,0xa6,0x1b,0xe0,0x04,0x36,0x5d,0xe0,0x03,0x3a,0x43,0xb9,0x98,0x36,0x3f,0xa1,0xab,0xe0,0x04,0x31,0xdd,0xe0,0x0c,0x3a,0x4c,0xbe,0x28,0x31,0xbf,0xa6,0x3b,0xe0,0x04,0x36,0x5d,0xe0,0x03,0x3a,0x43,0xb9,0xb8,0x36,0x3f,0xa1,0xcb,0xe0,0x04,0x31,0xdd,0xe0,0x0c,0x3a,0x4c,0xbe,0x48,0x31,0xbf,0xa6,0x5b,0xe0,0x04,0x36,0x5d,0xe0,0x03,0x3a,0x43,0xb9,0xd8,0x36,0x3f,0xa1,0xeb,0xe0,0x04,0x31,0xdd,0xe0,0x0c,0x3a,0x4c,0xbe,0x68,0x31,0xbf,0xa6,0x7b,0xc5,0xa0,0xe0,0x04,0x36,0x5d,0xe0,0x03,0x3a,0x43,0xb9,0xf8,0xc4,0x20,0x28,0xc5,0xe0,0x0b,0x31,0x25,0x3f,0x1b,0x3c,0x9b,0x3d,0xea,0xe2,0x00,0xc5,0x90,0x25,0x9e,0xa5,0x89,0x36,0x3f,0xe0,0x08,0x35,0xdd,0x3e,0x48,0xbe,0x0e,0x35,0xbf,0xa6,0x19,0xe0,0x08,0x36,0x5d,0xe0,0x0b,0x3c,0x4b,0xbd,0x9e,0x36,0x3f,0xa5,0xa9,0xe0,0x08,0x35,0xdd,0xe0,0x0c,0x3c,0x4c,0xbe,0x2e,0x35,0xbf,0xa6,0x39,0xc4,0x90,0xe0,0x08,0x36,0x5d,0xe0,0x0b,0x3c,0x4b,0xbd,0xbe,0xc7,0x10,0x3d,0xea,0xe2,0x00,0xc5,0x88,0x25,0x91,0xa5,0x89,0x36,0x3f,0xe0,0x08,0x35,0xdd,0xe0,0x0c,0x3c,0x4c,0xbe,0x0e,0x35,0xbf,0xa6,0x19,0xc4,0x88,0xe0,0x08,0x36,0x5d,0xe0,0x0b,0x3c,0x4b,0xbd,0x9e,0xc7,0x08,0x3d,0xea,0xe2,0x00,0xc5,0x84,0x25,0x8b,0xe0,0x0b,0x36,0x3f,0xe1,0x80,0xa6,0x19,0xe0,0x08,0x36,0x5d,0xe0,0x0b,0x3c,0x4b,0xe1,0x80,0xbd,0x9e,0xe2,0x00,0xc5,0x03,0x36,0x3f,0xe2,0x00,0xcd,0x02,0x01,0x0c,0xe2,0x00,0xcd,0x03,0x01,0x0d,0x15,0x80,0xe2,0x00,0xcd,0x01,0x01,0x91,0x8d,0x89,0xe4,0x0b,0x35,0xa8,0x00,0x8d,0x9d,0x89,0xe4,0x0b,0x35,0xa0,0x00,0x89,0x8c,0x29,0x9d,0x89,0x34,0x28,0xe4,0x0b,0x35,0xa0,0xe0,0x0b,0x3c,0x4b,0x00,0x81,0xe0,0x09,0x36,0xc3,0xe0,0x0a,0x3c,0x9a,0xe0,0x0d,0x35,0xdd,0x3e,0xcc,0x3e,0x6a,0xe2,0x00,0xc6,0x04,0x26,0x05,0xe1,0x80,0xbe,0x9e,0xe0,0x0d,0x35,0xbf,0x3f,0xea,0xe2,0x00,0xc7,0x82,0x27,0x87,0xe4,0x0f,0x36,0xc0,0xe1,0x80,0xb7,0x9e,0xe4,0x0d,0x36,0xa0,0xe2,0x00,0xc5,0x01,0x25,0x04,0xe4,0x0d,0x36,0xc8,0xae,0x8e,0x60,0x84,0x61,0x03,0x61,0x82,0x62,0x01,0xc0,0x10,0x38,0x82,0xc0,0x7c,0x78,0x81,0xe2,0x0f,0x3c,0xc8,0xe2,0x00,0xc7,0x83,0x2f,0x83,0xde,0xd4,0x00,0x82,0xde,0xee,0x60,0x81,0xc0,0x04,0x38,0x82,0xc0,0x54,0x78,0x86,0x79,0x05,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0x3a,0x69,0x3a,0xec,0xe2,0x00,0xc2,0x07,0xc2,0xf8,0x7c,0x09,0x39,0xeb,0xe0,0x02,0x3a,0xa4,0x7c,0x8a,0x3b,0x68,0x7d,0x88,0xc1,0x88,0x3d,0x72,0x3f,0xea,0xe2,0x00,0xc3,0x07,0x3c,0x63,0xe0,0x00,0x04,0xcd,0x3c,0xa4,0x3d,0x65,0x7f,0x87,0xde,0x30,0x67,0x08,0xe0,0x09,0x39,0x94,0xe0,0x06,0x3f,0x16,0x3c,0x66,0x3d,0x62,0xdf,0xcd,0x64,0x09,0x3c,0xe6,0x3d,0x62,0xde,0x24,0x63,0x09,0x67,0x87,0x3b,0x12,0x3a,0x1f,0x3f,0xe6,0xe2,0x00,0xc7,0x87,0x3a,0x25,0x7f,0x8b,0xe2,0x00,0xc3,0x03,0x00,0x9c,0x64,0x8a,0x3c,0x63,0x3c,0x92,0x3d,0x65,0xde,0x13,0x64,0x08,0x2b,0x07,0x67,0x0b,0x3c,0xe3,0x3c,0x1e,0x3d,0x65,0xde,0x40,0x00,0x86,0x67,0x8b,0x3c,0xe3,0x3c,0x1f,0x3d,0x65,0xdf,0xab,0x64,0x09,0x64,0x88,0x67,0x0b,0x3c,0x12,0x3c,0x9e,0x3d,0x65,0xdd,0xff,0x3a,0x25,0x39,0x15,0x3a,0x75,0x02,0xe4,0x22,0x26,0x64,0x8a,0x3c,0x63,0x3c,0x92,0x3d,0x64,0xde,0x03,0x67,0x8b,0x63,0x08,0x3c,0xe3,0x3b,0x1f,0x3c,0x66,0x3d,0x64,0xdf,0x93,0x64,0x09,0x3c,0xe6,0x3c,0x12,0x3d,0x64,0x00,0x94,0x64,0x8a,0xe0,0x0a,0x3a,0x1a,0x3c,0xa4,0x7f,0x87,0xdd,0xf1,0x67,0x08,0x67,0x87,0xe0,0x06,0x3f,0x16,0x3d,0x6f,0x3c,0x66,0xe0,0x09,0x39,0x94,0xdf,0x7f,0x67,0x87,0x64,0x09,0x3c,0xe6,0x3d,0x6f,0xdd,0xe3,0x60,0x86,0x61,0x05,0x61,0x84,0x62,0x03,0x62,0x82,0x63,0x01,0xc0,0x2c,0x38,0x82,0xc0,0x60,0x78,0x86,0x79,0x05,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0xe2,0x0f,0x3c,0xc8,0xe2,0x00,0xc7,0x87,0x3b,0x68,0x3f,0x69,0x27,0x84,0xdf,0x70,0xe0,0x00,0x00,0xc8,0x3f,0xe9,0xe2,0x00,0xc7,0x87,0x39,0x6a,0x3a,0x6b,0x3a,0xec,0x11,0x80,0x27,0xb2,0xe0,0x03,0x3e,0x2f,0x3d,0x73,0x3c,0x6b,0x3c,0xaf,0x04,0x90,0x3d,0x6c,0x7f,0x07,0x7f,0x88,0xdd,0xaa,0x67,0x88,0x3c,0x66,0xe0,0x09,0x3a,0x1f,0x3d,0x63,0xdd,0xa4,0x67,0x88,0xe0,0x02,0x3f,0x92,0x39,0x25,0x00,0x9c,0xe0,0x0a,0x3f,0x9a,0x7f,0x07,0x11,0x80,0x7f,0x88,0xdd,0xa7,0x67,0x88,0x3d,0x62,0x3c,0x66,0xe0,0x09,0x3a,0x1f,0xdd,0xa1,0x11,0x00,0x00,0x8e,0xe0,0x09,0x3f,0x13,0x3c,0x64,0x3d,0x65,0x7f,0x07,0xdd,0x8b,0xe0,0x08,0x3b,0x13,0x3c,0xe4,0x3d,0x65,0xdd,0x86,0x39,0x95,0x39,0x25,0x67,0x07,0x39,0x75,0x02,0xf1,0x21,0x0b,0x3c,0x64,0xe0,0x09,0x3f,0x13,0x3d,0x62,0xdd,0x89,0xe0,0x08,0x3b,0x13,0x3c,0xe4,0x3d,0x62,0xdd,0x84,0x60,0x86,0x61,0x05,0x61,0x84,0x62,0x03,0x62,0x82,0x63,0x01,0xc0,0x20,0x38,0x82,0xc0,0x54,0x78,0x86,0x79,0x05,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0x3f,0xe9,0xe2,0x00,0xc7,0x87,0x3f,0x68,0xe0,0x0d,0x3d,0x9f,0xe2,0x00,0xc7,0x07,0x7e,0x8b,0x3b,0x6c,0xe0,0x3f,0x12,0xff,0x3f,0x7f,0x3a,0x68,0x39,0xe9,0x39,0x6a,0xc3,0x78,0xe1,0x25,0x3a,0xa9,0x01,0xa7,0x00,0xb3,0x22,0x94,0xe0,0x0d,0x3d,0x9e,0x3c,0x6d,0x3c,0xe3,0x3d,0x66,0x7d,0x87,0x7f,0x08,0x7f,0x89,0x7e,0x8a,0xde,0xec,0x66,0x8a,0x3c,0x64,0x3c,0xed,0x3d,0x66,0xdd,0x42,0x65,0x87,0x67,0x08,0x67,0x89,0x00,0x8f,0x64,0x0b,0x3c,0xe3,0x3d,0x66,0x7d,0x87,0x7f,0x08,0x7f,0x89,0xdd,0x37,0x64,0x8b,0x3c,0x64,0x3d,0x66,0xde,0xd8,0x67,0x89,0x67,0x08,0x65,0x87,0x39,0x26,0x39,0x96,0x3a,0x16,0x39,0x76,0x02,0xda,0x21,0x17,0x22,0x8c,0xe0,0x05,0x3d,0x9e,0x3c,0x65,0x3c,0xe3,0x3d,0x62,0xde,0xc8,0x3c,0x64,0x3c,0xe5,0x3d,0x62,0xdd,0x2d,0x00,0x8b,0xe0,0x05,0x3d,0x9f,0x3c,0x65,0x3c,0xe3,0x3d,0x62,0xdd,0x26,0x3c,0x64,0x3c,0xe5,0x3d,0x62,0xde,0xb9,0x60,0x86,0x61,0x05,0x61,0x84,0x62,0x03,0x62,0x82,0x63,0x01,0xc0,0x2c,0x38,0x82,0xc0,0x6c,0x78,0x85,0x79,0x04,0x79,0x83,0x7a,0x02,0x7a,0x81,0xc6,0x7d,0x3a,0xe9,0x3d,0x7c,0x39,0xea,0xe2,0x00,0xc2,0x83,0x11,0x00,0x02,0x92,0xe0,0x04,0x3d,0x95,0x39,0x68,0x3c,0x64,0xdd,0x79,0x3f,0xe2,0xe2,0x00,0xc7,0x83,0x3f,0xf5,0x3c,0x62,0x3c,0xe4,0x3d,0x63,0x01,0x83,0xdd,0x70,0x00,0x83,0xdd,0x8a,0x00,0x81,0x3c,0x62,0x60,0x85,0x61,0x04,0x61,0x83,0x62,0x02,0x62,0x81,0xc0,0x14,0x38,0x82,0xe0,0x0a,0x3c,0x1a,0x00,0x83,0xe1,0x80,0xac,0x98,0x3c,0x7a,0x01,0xfd,0x38,0x82,0xe0,0x00,0x1f,0x28,0xa7,0x8e,0xe2,0x00,0xc7,0x81,0x27,0xfd,0x38,0x82,0xc0,0x5c,0x78,0x86,0x79,0x05,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0xe0,0x00,0x1a,0x89,0x3a,0x68,0xa7,0x85,0x39,0xe9,0xe2,0x00,0xc7,0x81,0x39,0x6a,0x27,0x89,0x7d,0x87,0xdf,0xe8,0xa7,0x05,0x17,0xfe,0xe0,0x0f,0x3f,0x5f,0xbf,0x85,0x65,0x87,0xe2,0x01,0xc9,0x00,0xe0,0x00,0x1f,0xa9,0xe0,0x00,0x1b,0x2a,0xeb,0x82,0xca,0x84,0x05,0x9b,0x3f,0x63,0xe0,0x01,0x16,0x80,0xe2,0x00,0xc7,0x07,0xe0,0x0e,0x3e,0xae,0x3e,0xe2,0xe4,0x0c,0x35,0xa0,0xe2,0x07,0xc6,0xff,0xe0,0x0d,0x3e,0x4d,0xbe,0x8f,0xb9,0x86,0xba,0x05,0x00,0x00,0x39,0x2e,0x7d,0x87,0x3a,0x1e,0x7f,0x88,0x39,0x9e,0xdf,0xc1,0x67,0x88,0x65,0x87,0xe4,0x0b,0x35,0xa0,0x3e,0xeb,0xe0,0x01,0xce,0x80,0x3a,0x23,0x00,0x90,0xbe,0x8f,0xb9,0x86,0xbf,0x05,0x00,0x00,0xe1,0xff,0xc1,0x00,0x7d,0x87,0xe0,0x01,0xc1,0x80,0x7e,0x89,0x7f,0x88,0xdf,0xac,0x67,0x88,0x66,0x89,0x65,0x87,0xe0,0x0e,0x3a,0x13,0xe2,0x01,0xc9,0x00,0x02,0xed,0xe0,0x0b,0x39,0x4b,0xbd,0x8f,0xb9,0x86,0xbf,0x05,0x00,0x00,0xe0,0x00,0x19,0x09,0xa7,0x82,0xcf,0x81,0xbf,0x82,0xdf,0x98,0xa7,0x02,0x17,0xfe,0xe0,0x0f,0x3f,0x5f,0xbf,0x82,0x60,0x86,0x61,0x05,0x61,0x84,0x62,0x03,0x62,0x82,0x63,0x01,0xc0,0x24,0x38,0x82,0xc0,0x7c,0x78,0x81,0xe0,0x00,0x1f,0x2b,0xe8,0x00,0x67,0x92,0xe0,0x00,0x1c,0x08,0xbf,0x1f,0xe0,0x02,0x15,0x00,0xe8,0x00,0x64,0x90,0xef,0xff,0xdd,0xfe,0xe8,0x00,0x64,0x0f,0xe0,0x00,0x1c,0x86,0xe1,0xfe,0xc4,0x00,0xe0,0x00,0x15,0x40,0xef,0xff,0xdd,0xf4,0xe8,0x00,0x64,0x8f,0xe8,0x00,0x64,0x10,0xe1,0xfe,0xc4,0x80,0xe0,0x00,0x15,0x40,0xef,0xff,0xdd,0xea,0xe0,0x00,0x1c,0x0a,0xe8,0x00,0x64,0x90,0xe0,0x02,0x15,0x00,0xef,0xff,0xdd,0xe2,0xe0,0x00,0x1f,0x06,0xe0,0x00,0x1e,0x8a,0x17,0x80,0xe0,0x2f,0x8d,0xfe,0xe0,0x2f,0x8e,0x7d,0x3d,0xfc,0x01,0x08,0xe0,0x00,0x1f,0x2c,0xe0,0x00,0x1f,0x83,0xbf,0x0f,0x17,0x01,0x00,0x8b,0xc7,0x81,0xe2,0x00,0xcf,0xc0,0x01,0xf0,0xe0,0x00,0x1f,0x2d,0xe0,0x00,0x1f,0x83,0xbf,0x0f,0x17,0x00,0xe8,0x00,0x67,0x92,0xbf,0x1f,0x60,0x81,0xc0,0x04,0x38,0x82,0xc0,0x7c,0x78,0x81,0xe8,0x00,0x67,0x92,0xe0,0x00,0x1f,0x2b,0xe0,0x00,0x1c,0x84,0xbf,0x1f,0xe1,0x6e,0x16,0x80,0xe0,0x00,0x1f,0xae,0xe0,0x00,0x1d,0xaf,0xa7,0x8f,0xbf,0x89,0xe1,0x2f,0x3f,0x8d,0xe0,0x00,0x1e,0xb0,0x3e,0x6f,0xa6,0x8d,0xce,0x02,0xbe,0x99,0x3e,0xfb,0xe0,0x00,0x1e,0xb1,0xe0,0x00,0x1d,0xb2,0xa6,0x8d,0xe0,0x6f,0x39,0xac,0xbe,0xa9,0x3e,0xfb,0xe0,0x00,0x1e,0xb3,0x3e,0x6f,0xa6,0x8d,0xe0,0x00,0x1d,0xb4,0xbe,0xb9,0xce,0x04,0xe0,0x6f,0x39,0xac,0x3e,0xfb,0xe0,0x00,0x1e,0xb5,0x3e,0x6f,0xa6,0x8d,0xce,0x08,0xe0,0x00,0x1d,0xb6,0xbe,0xc9,0xe0,0x6f,0x39,0xac,0x3e,0x6f,0x3e,0xfb,0xe0,0x00,0x1e,0xb7,0xce,0x10,0xa6,0x8d,0xe0,0x6f,0x39,0xac,0x3e,0x6f,0xbe,0xd9,0xce,0x20,0xeb,0x02,0xcd,0xf1,0xbf,0x0b,0xe2,0xcf,0xce,0xff,0xe0,0x6f,0x39,0xac,0x00,0x00,0xe0,0x00,0x1e,0x38,0x16,0x80,0xbe,0x8c,0x00,0x00,0xe0,0x00,0x1e,0xb9,0xe0,0x02,0x15,0x00,0xbd,0x0d,0x00,0x00,0x3d,0x6f,0xa5,0x8b,0xcd,0x40,0xbd,0xe9,0x3d,0xfe,0xe0,0x6f,0x39,0xaa,0xa7,0x0c,0x3e,0x6f,0xbf,0x79,0xe0,0x01,0xce,0x00,0xe2,0x00,0xcf,0x00,0xa7,0x0d,0xe0,0x6f,0x39,0xac,0x3e,0xef,0xe0,0x01,0xbf,0x09,0xe2,0x02,0xcf,0x00,0xe0,0x02,0xce,0x80,0xe8,0x00,0x67,0x12,0xe0,0x6f,0x39,0xad,0xbf,0x9e,0x15,0x20,0xe8,0x00,0x64,0x11,0xef,0xff,0xdd,0x48,0x60,0x81,0xc0,0x04,0x38,0x82,0xc0,0x7c,0x78,0x81,0xdf,0x36,0xe8,0x00,0x66,0x92,0xe0,0x00,0x1f,0x83,0xa7,0x1f,0xc7,0x01,0xbf,0x1f,0xa7,0x0d,0xc7,0x01,0xbf,0x0d,0xa7,0x2f,0xc7,0x01,0xbf,0x2f,0x00,0xf7,0x38,0x82,0xc0,0x7c,0x78,0x81,0xe0,0x00,0x1f,0x83,0xe0,0x00,0x1f,0x3a,0xbf,0x0f,0xe0,0x00,0x1f,0x3b,0xbf,0x0f,0xdf,0xe4,0xc0,0x64,0x79,0x05,0x39,0x60,0xc1,0x1c,0x78,0x86,0x79,0x84,0x7a,0x03,0x7a,0x82,0x7b,0x01,0xea,0x02,0xcf,0xf0,0xa7,0x1f,0x3b,0x60,0xe8,0x00,0xcf,0x01,0xc0,0x70,0xbf,0x1f,0x3a,0x60,0xc2,0x0b,0x32,0x43,0x32,0x23,0x00,0x00,0xe0,0x02,0xa7,0x7f,0xcf,0x0f,0xe0,0x02,0xbf,0x7f,0x00,0x00,0x17,0x00,0xea,0x06,0xcf,0xf0,0xbf,0x04,0xea,0x06,0xcc,0x70,0xbf,0x94,0x14,0x80,0xe0,0x00,0x19,0x87,0xe0,0x01,0x15,0x00,0xbc,0x03,0xea,0x02,0xca,0xf1,0xbc,0x93,0xef,0xff,0xde,0x71,0x3c,0x65,0x3c,0xe4,0x15,0x08,0xef,0xff,0xdc,0xf5,0x16,0x90,0xbe,0xb5,0x00,0x00,0xe0,0x00,0x1f,0xbc,0x17,0x00,0xbf,0x04,0x15,0x00,0xbf,0x94,0x14,0x80,0xe0,0x00,0x1c,0x3c,0xbd,0x33,0xe0,0x01,0x15,0x40,0xbc,0x23,0xbe,0x82,0xef,0xff,0xde,0x59,0xe0,0x00,0x1c,0x3d,0x3c,0xe4,0x15,0x08,0xef,0xff,0xdc,0xdc,0xa6,0x82,0xe0,0x01,0xbe,0xb5,0x00,0x00,0xe0,0x00,0x1c,0x3e,0xea,0x01,0x7c,0x90,0x15,0x0c,0xef,0xff,0xdc,0xd1,0xe0,0x00,0x1f,0xbf,0xe0,0x00,0x1f,0x40,0x16,0x81,0xbf,0x2f,0x16,0x00,0xe0,0x00,0x1f,0x41,0xbe,0x0f,0x14,0x80,0xbf,0x3f,0x15,0x83,0xe0,0x00,0x1f,0x42,0xbe,0x9f,0xe0,0x00,0x16,0x70,0xbf,0x4f,0x15,0x78,0xe0,0x00,0x1f,0x43,0xbf,0x5f,0xe0,0x00,0x1f,0x44,0xbf,0x6f,0xe0,0x00,0x1f,0x45,0xbf,0x7f,0xe0,0x00,0x1f,0x46,0xe0,0x01,0xbf,0x0f,0xe0,0x00,0x1f,0x47,0xe0,0x01,0xbf,0x1f,0xe0,0x00,0x1f,0x48,0xe0,0x01,0xbf,0x2f,0xe0,0x00,0x1f,0x49,0xe0,0x01,0xbf,0x3f,0xe0,0x00,0x1f,0x4a,0xe0,0x01,0xbf,0x4f,0xe0,0x00,0x1f,0x4b,0xe0,0x01,0xbf,0x5f,0xe0,0x00,0x1f,0x4c,0xe0,0x01,0xbf,0x6f,0xe0,0x00,0x1f,0x4d,0xe0,0x01,0xbf,0x7f,0xe7,0xff,0x17,0x30,0xe0,0x00,0x1f,0xce,0xaf,0x0f,0xe7,0xff,0x17,0x03,0xaf,0x1f,0x17,0x18,0xaf,0x2f,0x17,0x0b,0xaf,0x3f,0xe0,0x00,0x17,0x40,0xac,0xcf,0xac,0xdf,0xac,0xef,0xac,0xff,0xe0,0x01,0xad,0x4f,0x15,0x09,0xe0,0x01,0xac,0xef,0xe0,0x01,0xac,0xff,0xe0,0x01,0xad,0x8f,0xe0,0x01,0xae,0x1f,0xe0,0x01,0xae,0xaf,0xe0,0x01,0xaf,0x3f,0xe0,0x01,0xaf,0x5f,0xe0,0x02,0xad,0x8f,0xe0,0x02,0xae,0x1f,0xe0,0x02,0xac,0xcf,0xe0,0x02,0xac,0xdf,0x14,0x88,0xe0,0x02,0xac,0xef,0x14,0x80,0xe0,0x02,0xac,0xff,0x14,0xf0,0xe0,0x02,0xad,0x2f,0x15,0x40,0xe0,0x03,0xac,0x8f,0x14,0x80,0xe0,0x02,0xad,0x3f,0xe0,0x03,0xaf,0x1f,0xe0,0x03,0xac,0xaf,0xe0,0x03,0xac,0xbf,0xe0,0x03,0xad,0xcf,0xe0,0x03,0xae,0x5f,0xe0,0x03,0xae,0xef,0xe0,0x03,0xad,0x7f,0xe0,0x04,0xac,0x8f,0xe0,0x04,0xac,0x9f,0xe0,0x04,0xac,0xaf,0xe0,0x04,0xaf,0x3f,0xa7,0xd5,0x27,0x96,0xa6,0x13,0xa7,0x83,0x36,0x23,0xe0,0x0c,0x3f,0x9c,0xe0,0x00,0x1f,0xce,0x17,0x00,0xbf,0x0c,0xbf,0x9c,0xbe,0xf5,0x00,0x00,0xe0,0x01,0xa7,0xf5,0x2f,0xfe,0x17,0x01,0xea,0x02,0xcf,0xf1,0xe0,0x01,0xbf,0x5f,0x00,0x00,0x38,0x66,0x60,0x86,0x61,0x05,0x61,0x84,0x62,0x03,0x62,0x82,0x63,0x01,0xc0,0x1c,0x38,0x82,0x70,0x66,0x65,0x5f,0x31,0x32,0x5f,0x30,0x32,0x5f,0x31,0x2d,0x31,0x34,0x2d,0x67,0x36,0x33,0x36,0x61,0x65,0x61,0x35,0x2d,0x64,0x69,0x72,0x74,0x79,0x00,0x47,0x43,0x43,0x3a,0x20,0x28,0x47,0x4e,0x55,0x29,0x20,0x34,0x2e,0x37,0x2e,0x31,0x00,0x00,0x2e,0x73,0x68,0x73,0x74,0x72,0x74,0x61,0x62,0x00,0x2e,0x64,0x64,0x72,0x5f,0x74,0x65,0x78,0x74,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x70,0x65,0x73,0x74,0x61,0x74,0x75,0x73,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x67,0x6f,0x74,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x73,0x64,0x61,0x74,0x61,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x6c,0x69,0x74,0x34,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x62,0x73,0x73,0x00,0x2e,0x64,0x6d,0x65,0x6d,0x5f,0x73,0x74,0x61,0x63,0x6b,0x00,0x2e,0x76,0x65,0x63,0x74,0x6f,0x72,0x00,0x2e,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x00,0x2e,0x63,0x6f,0x6d,0x6d,0x65,0x6e,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x06,0x03,0xf8,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x0c,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x20,0x00,0x00,0x10,0x20,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x2e,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x50,0x00,0x00,0x10,0x50,0x00,0x00,0x00,0x6c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3a,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0xbc,0x00,0x00,0x10,0xbc,0x00,0x00,0x00,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x45,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x03,0x00,0x00,0x01,0x5c,0x00,0x00,0x11,0x5c,0x00,0x00,0x02,0x58,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4f,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0xb4,0x00,0x00,0x13,0xb4,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5b,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x1f,0x80,0x00,0x00,0x1f,0x80,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x2c,0x30,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6c,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x2c,0x4e,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2c,0x5f,0x00,0x00,0x00,0x75,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
\ No newline at end of file
diff --git a/include/configs/ls1012a_common.h b/include/configs/ls1012a_common.h
index 07ef7c6..3c4ab6c 100644
--- a/include/configs/ls1012a_common.h
+++ b/include/configs/ls1012a_common.h
@@ -109,6 +109,16 @@
 #define CONFIG_CMD_PING
 #undef CONFIG_CMD_IMLS
 
+/*  PPFE */
+#define CONFIG_FSL_PPFE
+
+#ifdef CONFIG_FSL_PPFE
+#define CONFIG_CMD_PFE_START 
+#define CONFIG_CMD_PFE_COMMANDS
+#define CONFIG_UTIL_PE_DISABLED
+
+#endif
+
 
 #define CONFIG_ARCH_EARLY_INIT_R
 
diff --git a/include/configs/ls1012aqds.h b/include/configs/ls1012aqds.h
index 488811b..1fa7b6f 100644
--- a/include/configs/ls1012aqds.h
+++ b/include/configs/ls1012aqds.h
@@ -14,16 +14,14 @@
 #define CONFIG_CHIP_SELECTS_PER_CTRL	1
 #define CONFIG_NR_DRAM_BANKS		2
 
-#ifdef CONFIG_SYS_DPAA_FMAN
-#define CONFIG_FMAN_ENET
+#ifdef CONFIG_FSL_PPFE
+/*#define CONFIG_CMD_PFE_START */
+#define EMAC1_PHY_ADDR          0x1e
+#define EMAC2_PHY_ADDR          0x1
 #define CONFIG_PHYLIB
 #define CONFIG_PHY_VITESSE
 #define CONFIG_PHY_REALTEK
-#define RGMII_PHY1_ADDR		0x1
-#define SGMII_CARD_PORT1_PHY_ADDR 0x1C
-#define SGMII_CARD_PORT2_PHY_ADDR 0x1D
-#define SGMII_CARD_PORT3_PHY_ADDR 0x1E
-#define SGMII_CARD_PORT4_PHY_ADDR 0x1F
+#define RGMII_RESET_WA
 #endif
 
 /*  MMC  */
@@ -142,6 +140,7 @@
 #define I2C_VOL_MONITOR_BUS_V_OVF      0x1
 #define I2C_VOL_MONITOR_BUS_V_SHIFT    3
 
+
 /* DSPI */
 #define CONFIG_FSL_DSPI
 #define CONFIG_FSL_DSPI1
diff --git a/include/configs/ls1012ardb.h b/include/configs/ls1012ardb.h
index 1629e19..1b72bf1 100644
--- a/include/configs/ls1012ardb.h
+++ b/include/configs/ls1012ardb.h
@@ -19,10 +19,12 @@
 #define CONFIG_SYS_MEMTEST_START	0x80000000
 #define CONFIG_SYS_MEMTEST_END		0x9fffffff
 
+#ifdef CONFIG_FSL_PPFE
+#define EMAC1_PHY_ADDR          0x2
+#define EMAC2_PHY_ADDR          0x1
 #define CONFIG_PHYLIB
 #define CONFIG_PHY_REALTEK
-#define SGMII_PHY1_ADDR		0x0
-#define RGMII_PHY2_ADDR		0x1
+#endif
 
 /*
 * USB
-- 
1.7.9.5

